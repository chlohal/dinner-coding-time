//if we're in a web worker
if (typeof importScripts === "function") {
    onmessage = function (event) {
        try {
            var data = event.data;
            if (data.function == "parse") {
                
                var result = window.parser.parse(wrap(data.args[0], data.args[1]));
                postMessage({
                    nonce: data.nonce,
                    data: unwrap(result, data.args[1])
                });
            }
        } catch(e) {
            postMessage({
                nonce: data.nonce,
                error: e.toString()
            });
            throw e;
        }
    }
}

function wrap(src, entryPoint) {
    if(entryPoint == "CLASS_BODY_MEMBER_DECLARATION") return `public class Wrap { ${src} }`;
    else return src;
}

function unwrap(ast, entryPoint) {
    if(entryPoint == "CLASS_BODY_MEMBER_DECLARATION") return ast.types[0].declaration.body.declarations[0];
    else return ast;
}

if (typeof window === "undefined") var window = {};

/*! For license information please see main.js.LICENSE.txt */
(() => { var e = { parser: (e, t, n) => n(8138), 5507: (e, t, n) => { e.exports = n(7089); }, 2106: (e, t, n) => { e.exports = n(2219) }, 5367: (e, t, n) => { e.exports = n(2453) }, 7800: (e, t, n) => { e.exports = n(259) }, 523: (e, t, n) => { e.exports = n(5113) }, 1698: (e, t, n) => { e.exports = n(4541) }, 6448: (e, t, n) => { e.exports = n(8202) }, 3304: (e, t, n) => { e.exports = n(4187) }, 1958: (e, t, n) => { e.exports = n(1121) }, 2576: (e, t, n) => { e.exports = n(3290) }, 1482: (e, t, n) => { e.exports = n(4241) }, 720: (e, t, n) => { e.exports = n(6486) }, 8640: (e, t, n) => { e.exports = n(7300) }, 6013: (e, t, n) => { e.exports = n(5576) }, 7640: (e, t, n) => { e.exports = n(1690) }, 4055: (e, t, n) => { e.exports = n(1927) }, 3505: (e, t, n) => { e.exports = n(678) }, 7671: (e, t, n) => { e.exports = n(8867) }, 153: (e, t, n) => { e.exports = n(411) }, 5947: (e, t, n) => { e.exports = n(8860) }, 3757: (e, t, n) => { e.exports = n(7324) }, 1674: (e, t, n) => { e.exports = n(2565) }, 5734: e => { e.exports = function (e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } }, 5416: (e, t, n) => { var r = n(3505); e.exports = function (e) { if (r(e)) return e } }, 575: e => { e.exports = function (e) { return e && e.__esModule ? e : { default: e } } }, 7462: (e, t, n) => { var r = n(153), a = n(3757), i = n(1674); e.exports = function (e, t) { if (void 0 !== i && a(Object(e))) { var n = [], u = !0, d = !1, o = void 0; try { for (var s, c = r(e); !(u = (s = c.next()).done) && (n.push(s.value), !t || n.length !== t); u = !0); } catch (e) { d = !0, o = e } finally { try { u || null == c.return || c.return() } finally { if (d) throw o } } return n } } }, 6109: e => { e.exports = function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } }, 6748: (e, t, n) => { var r = n(5416), a = n(7462), i = n(8674), u = n(6109); e.exports = function (e, t) { return r(e) || a(e, t) || i(e, t) || u() } }, 8674: (e, t, n) => { var r = n(4055), a = n(5947), i = n(5734); e.exports = function (e, t) { var n; if (e) { if ("string" == typeof e) return i(e, t); var u = a(n = Object.prototype.toString.call(e)).call(n, 8, -1); return "Object" === u && e.constructor && (u = e.constructor.name), "Map" === u || "Set" === u ? r(e) : "Arguments" === u || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u) ? i(e, t) : void 0 } } }, 8138: (e, t, n) => { const r = n(5618), a = n(2477), i = n(4390), u = new a([]), d = new i; e.exports = { parse: function (e, t = (e => e.compilationUnit())) { const n = r.tokenize(e); u.input = n.tokens; const a = t(u); if (u.errors.length > 0) { const e = u.errors[0]; throw Error("Sad sad panda, parsing errors detected in line: " + e.token.startLine + ", column: " + e.token.startColumn + "\n" + e.message) } return d.visit(a) } } }, 5618: (e, t, n) => { const r = n(7177), { allTokens: a } = n(803), i = new (0, r.Lexer)(a, { ensureOptimizations: !0 }); e.exports = i }, 2477: (e, t, n) => { const r = n(7177), { allTokens: a, tokens: i } = n(803), u = r.Parser, d = r.createTokenInstance(r.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN); Object.freeze(d); class o extends r.Parser { constructor(e) { super(e, a, { outputCst: !0 }); const t = this; t.RULE("compilationUnit", (() => { let e = !1; t.OPTION((() => { t.MANY((() => t.SUBRULE(t.annotation))), t.OR([{ ALT: () => t.SUBRULE(t.packageDeclaration) }, { ALT: () => { t.MANY2((() => { t.SUBRULE(t.typeDeclaration), e = !0 })) } }]) })), t.OPTION2({ GATE: () => !e, DEF: () => { t.MANY3((() => { t.SUBRULE2(t.importDeclaration) })), t.MANY4((() => { t.SUBRULE2(t.typeDeclaration) })) } }) })), t.RULE("packageDeclaration", (() => { t.CONSUME(i.Package), t.SUBRULE(t.qualifiedName), t.SUBRULE(t.semiColon) })), t.RULE("importDeclaration", (() => { t.CONSUME(i.Import), t.OPTION((() => { t.CONSUME(i.Static) })), t.SUBRULE(t.qualifiedName), t.OPTION2((() => { t.CONSUME(i.Dot), t.CONSUME(i.Star) })), t.SUBRULE(t.semiColon) })), t.RULE("typeDeclaration", (() => { t.MANY((() => { t.SUBRULE(t.classOrInterfaceModifier) })), t.OR([{ ALT: () => t.SUBRULE(t.classDeclaration) }, { ALT: () => t.SUBRULE(t.enumDeclaration) }, { ALT: () => t.SUBRULE(t.interfaceDeclaration) }, { ALT: () => t.SUBRULE(t.annotationTypeDeclaration) }]) })), t.RULE("modifier", (() => { t.OR([{ ALT: () => t.SUBRULE(t.classOrInterfaceModifier) }, { ALT: () => t.CONSUME(i.Native) }, { ALT: () => t.CONSUME(i.Synchronized) }, { ALT: () => t.CONSUME(i.Transient) }, { ALT: () => t.CONSUME(i.Volatile) }]) })), t.RULE("classOrInterfaceModifier", (() => { t.OR([{ ALT: () => t.SUBRULE(t.annotation) }, { ALT: () => t.CONSUME(i.Public) }, { ALT: () => t.CONSUME(i.Protected) }, { ALT: () => t.CONSUME(i.Private) }, { ALT: () => t.CONSUME(i.Static) }, { ALT: () => t.CONSUME(i.Abstract) }, { ALT: () => t.CONSUME(i.Final) }, { ALT: () => t.CONSUME(i.Strictfp) }]) })), t.RULE("variableModifier", (() => { t.OR([{ ALT: () => t.SUBRULE(t.annotation) }, { ALT: () => t.CONSUME(i.Final) }]) })), t.RULE("annotation", (() => { t.CONSUME(i.At), t.SUBRULE(t.qualifiedName), t.OPTION((() => { t.CONSUME(i.LBrace), t.OPTION2((() => { t.OR([{ ALT: () => { t.SUBRULE(t.expression) } }, { ALT: () => t.SUBRULE(t.elementValueArrayInitializer) }]), t.MANY((() => { t.CONSUME(i.Comma), t.SUBRULE2(t.elementValuePair) })) })), t.CONSUME(i.RBrace) })) })), t.RULE("elementValuePairs", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.elementValuePair) } }) })), t.RULE("elementValuePair", (() => { t.CONSUME(i.Identifier), t.CONSUME(i.Equals), t.SUBRULE(t.elementValue) })), t.RULE("elementValue", (() => { t.OR([{ ALT: () => t.SUBRULE(t.expression) }, { ALT: () => t.SUBRULE(t.elementValueArrayInitializer) }]) })), t.RULE("elementValueArrayInitializer", (() => { t.CONSUME(i.LCurly), t.OPTION((() => { t.SUBRULE(t.elementValue), t.MANY((() => { t.CONSUME(i.Comma), t.SUBRULE2(t.elementValue) })) })), t.OPTION2((() => { t.CONSUME2(i.Comma) })), t.CONSUME(i.RCurly) })), t.RULE("classDeclaration", (() => { t.CONSUME(i.Class), t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.typeParameters) })), t.OPTION2((() => { t.CONSUME(i.Extends), t.SUBRULE(t.typeType) })), t.OPTION3((() => { t.CONSUME(i.Implements), t.SUBRULE(t.typeList) })), t.SUBRULE(t.classBody) })), t.RULE("typeParameters", (() => { t.CONSUME(i.Less), t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.typeParameter) } }), t.CONSUME(i.Greater) })), t.RULE("typeParameter", (() => { t.MANY((() => { t.SUBRULE(t.annotation) })), t.CONSUME(i.Identifier), t.OPTION((() => { t.CONSUME(i.Extends), t.SUBRULE(t.typeBound) })) })), t.RULE("typeBound", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.And, DEF: () => { t.SUBRULE(t.typeType) } }) })), t.RULE("classBody", (() => { t.CONSUME(i.LCurly), t.MANY((() => { t.SUBRULE(t.classBodyDeclaration) })), t.CONSUME(i.RCurly) })), t.RULE("classBodyDeclaration", (() => { t.OPTION((() => { t.CONSUME(i.Static) })), t.OR([{ ALT: () => { t.SUBRULE(t.block) } }, { ALT: () => { t.MANY((() => { t.SUBRULE(t.modifier) })), t.SUBRULE(t.memberDeclaration) } }, { ALT: () => { t.SUBRULE(t.semiColon) } }]) })), t.RULE("memberDeclaration", (() => { t.OR([{ ALT: () => t.SUBRULE(t.fieldDeclarationOrMethodDeclarationOrConstructorDeclaration) }, { ALT: () => t.SUBRULE(t.genericMethodDeclarationOrGenericConstructorDeclaration) }, { ALT: () => t.SUBRULE(t.interfaceDeclaration) }, { ALT: () => t.SUBRULE(t.annotationTypeDeclaration) }, { ALT: () => t.SUBRULE(t.classDeclaration) }, { ALT: () => t.SUBRULE(t.enumDeclaration) }]) })), t.RULE("fieldDeclarationOrMethodDeclarationOrConstructorDeclaration", (() => { let e, n = !0, r = !0, a = !0; t.OR([{ ALT: () => { t.OPTION((() => { t.SUBRULE(t.annotation), a = !1 })), t.OR2([{ ALT: () => { e = t.CONSUME(i.Identifier), t.OR3([{ GATE: () => a, ALT: () => { t.SUBRULE(t.formalParameters), t.OPTION2((() => { t.CONSUME(i.Throws), t.SUBRULE(t.qualifiedNameList) })), t.SUBRULE(t.methodBody), n = !1, r = !1, e.isConstructorDeclaration = !0 } }, { ALT: () => { t.OPTION3((() => { t.SUBRULE(t.typeArguments) })), t.MANY({ GATE: () => this.LA(2).tokenType !== i.Class, DEF: () => { t.CONSUME(i.Dot), t.SUBRULE2(t.classOrInterfaceTypeElement) } }), a = !1 } }]) } }, { ALT: () => { e = t.SUBRULE(t.primitiveType), a = !1 } }]), t.MANY2({ GATE: () => !a, DEF: () => { t.CONSUME(i.LSquare).isTypeType = !0, t.CONSUME(i.RSquare) } }) } }, { ALT: () => { e = t.CONSUME(i.Void), a = !1, n = !1 } }]), t.OR4([{ GATE: () => r || n, ALT: () => { t.CONSUME2(i.Identifier), t.OR5([{ ALT: () => { t.MANY3((() => { t.CONSUME2(i.LSquare, { LABEL: "identifierDimension" }), t.CONSUME2(i.RSquare) })), t.OPTION4((() => { t.CONSUME(i.Equals), t.SUBRULE(t.variableInitializer) })), t.MANY4((() => { t.CONSUME(i.Comma), t.SUBRULE(t.variableDeclarator) })), t.SUBRULE(t.semiColon), e && (e.isFieldDeclaration = !0) } }, { ALT: () => { t.SUBRULE2(t.formalParameters), t.MANY5((() => { t.CONSUME3(i.LSquare), t.CONSUME3(i.RSquare) })), t.OPTION5((() => { t.CONSUME2(i.Throws), t.SUBRULE2(t.qualifiedNameList) })), t.SUBRULE2(t.methodBody), e && (e.isMethodDeclaration = !0) } }]) } }, { ALT: () => { } }]) })), t.RULE("methodDeclaration", (() => { t.SUBRULE(t.typeTypeOrVoid), t.CONSUME(i.Identifier), t.SUBRULE(t.formalParameters), t.MANY((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })), t.OPTION((() => { t.CONSUME(i.Throws), t.SUBRULE(t.qualifiedNameList) })), t.SUBRULE(t.methodBody) })), t.RULE("constructorDeclaration", (() => { t.CONSUME(i.Identifier), t.SUBRULE(t.formalParameters), t.OPTION((() => { t.CONSUME(i.Throws), t.SUBRULE(t.qualifiedNameList) })), t.SUBRULE(t.methodBody) })), t.RULE("genericMethodDeclarationOrGenericConstructorDeclaration", (() => { t.SUBRULE(t.typeParameters), t.OR([{ ALT: () => t.SUBRULE(t.methodDeclaration) }, { ALT: () => t.SUBRULE(t.constructorDeclaration) }]) })), t.RULE("fieldDeclaration", (() => { t.SUBRULE(t.typeType), t.SUBRULE(t.variableDeclarators), t.SUBRULE(t.semiColon) })), t.RULE("methodBody", (() => { t.OR([{ ALT: () => t.SUBRULE(t.block) }, { ALT: () => t.SUBRULE(t.semiColon) }]) })), t.RULE("enumDeclaration", (() => { t.CONSUME(i.Enum), t.CONSUME(i.Identifier), t.OPTION((() => { t.CONSUME(i.Implements), t.SUBRULE(t.typeList) })), t.CONSUME(i.LCurly), t.OPTION2((() => { t.SUBRULE(t.enumConstants) })), t.OPTION3((() => { t.CONSUME(i.Comma) })), t.OPTION4((() => { t.SUBRULE(t.enumBodyDeclarations) })), t.CONSUME(i.RCurly) })), t.RULE("enumConstants", (() => { t.SUBRULE(t.enumConstant), t.MANY({ GATE: () => this.LA(2).tokenType !== i.RCurly && this.LA(2).tokenType !== i.SemiColon, DEF: () => { t.CONSUME(i.Comma), t.SUBRULE2(t.enumConstant) } }) })), t.RULE("enumConstant", (() => { t.MANY((() => { t.SUBRULE(t.annotation) })), t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.arguments) })), t.OPTION2((() => { t.SUBRULE(t.classBody) })) })), t.RULE("enumBodyDeclarations", (() => { t.SUBRULE(t.semiColon), t.MANY((() => { t.SUBRULE(t.classBodyDeclaration) })) })), t.RULE("interfaceDeclaration", (() => { t.CONSUME(i.Interface), t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.typeParameters) })), t.OPTION2((() => { t.CONSUME(i.Extends), t.SUBRULE(t.typeList) })), t.SUBRULE(t.interfaceBody) })), t.RULE("interfaceBody", (() => { t.CONSUME(i.LCurly), t.MANY((() => { t.SUBRULE(t.interfaceBodyDeclaration) })), t.CONSUME(i.RCurly) })), t.RULE("interfaceBodyDeclaration", (() => { t.MANY((() => { t.SUBRULE(t.modifier) })), t.SUBRULE(t.interfaceMemberDeclaration) })), t.RULE("interfaceMemberDeclaration", (() => { t.OR([{ ALT: () => t.SUBRULE(t.constantDeclarationOrInterfaceMethodDeclaration) }, { ALT: () => t.SUBRULE(t.interfaceDeclaration) }, { ALT: () => t.SUBRULE(t.classDeclaration) }, { ALT: () => t.SUBRULE(t.enumDeclaration) }]) })), t.RULE("constantDeclarationOrInterfaceMethodDeclaration", (() => { let e = !0, n = !0; t.OR([{ ALT: () => { t.MANY((() => { t.SUBRULE(t.interfaceMethodModifier), e = !1 })), t.OPTION((() => { t.SUBRULE(t.typeParameters), e = !1 })), t.MANY2((() => { t.SUBRULE(t.annotation), e = !1 })), t.OR2([{ ALT: () => { t.SUBRULE(t.typeType), t.OPTION2({ GATE: () => e, DEF: () => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.constantDeclarator) } }), t.SUBRULE(t.semiColon), n = !1 } }) } }, { ALT: () => t.CONSUME(i.Void) }]), t.OR3([{ GATE: () => n, ALT: () => { t.CONSUME(i.Identifier), t.SUBRULE(t.formalParameters), t.MANY3((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })), t.OPTION3((() => { t.CONSUME(i.Throws), t.SUBRULE(t.qualifiedNameList) })), t.SUBRULE(t.methodBody) } }, { ALT: () => { } }]) } }]) })), t.RULE("constantDeclaration", (() => { t.SUBRULE(t.typeType), t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.constantDeclarator) } }), t.SUBRULE(t.semiColon) })), t.RULE("constantDeclarator", (() => { t.CONSUME(i.Identifier), t.MANY((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })), t.CONSUME(i.Equals), t.SUBRULE(t.variableInitializer) })), t.RULE("interfaceMethodDeclaration", (() => { t.MANY((() => { t.SUBRULE(t.interfaceMethodModifier) })), t.OPTION((() => { t.SUBRULE(t.typeParameters) })), t.MANY2((() => { t.SUBRULE(t.annotation) })), t.SUBRULE(t.typeTypeOrVoid), t.CONSUME(i.Identifier), t.SUBRULE(t.formalParameters), t.MANY3((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })), t.OPTION2((() => { t.CONSUME(i.Throws), t.SUBRULE(t.qualifiedNameList) })), t.SUBRULE(t.methodBody) })), t.RULE("interfaceMethodModifier", (() => { t.OR([{ ALT: () => t.SUBRULE(t.annotation) }, { ALT: () => t.CONSUME(i.Public) }, { ALT: () => t.CONSUME(i.Abstract) }, { ALT: () => t.CONSUME(i.Default) }, { ALT: () => t.CONSUME(i.Static) }, { ALT: () => t.CONSUME(i.Strictfp) }]) })), t.RULE("variableDeclarators", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.variableDeclarator) } }) })), t.RULE("variableDeclarator", (() => { t.SUBRULE(t.variableDeclaratorId), t.OPTION((() => { t.CONSUME(i.Equals), t.SUBRULE(t.variableInitializer) })) })), t.RULE("variableDeclaratorId", (() => { t.CONSUME(i.Identifier), t.MANY((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })) })), t.RULE("variableInitializer", (() => { t.OR([{ ALT: () => t.SUBRULE(t.arrayInitializer) }, { ALT: () => { t.SUBRULE(t.expression), t.OPTION((() => { t.CONSUME(i.Questionmark), t.SUBRULE2(t.expression), t.CONSUME(i.Colon), t.SUBRULE3(t.expression) })) } }]) })), t.RULE("arrayInitializer", (() => { t.CONSUME(i.LCurly), t.OPTION((() => { t.SUBRULE(t.variableInitializer), t.MANY({ GATE: () => this.LA(2).tokenType !== i.Comma && this.LA(2).tokenType !== i.RCurly, DEF: () => { t.CONSUME(i.Comma), t.SUBRULE2(t.variableInitializer) } }) })), t.OPTION2((() => { t.CONSUME2(i.Comma) })), t.CONSUME(i.RCurly) })), t.RULE("annotationTypeDeclaration", (() => { t.CONSUME(i.At), t.CONSUME(i.Interface), t.CONSUME(i.Identifier), t.SUBRULE(t.annotationTypeBody) })), t.RULE("annotationTypeBody", (() => { t.CONSUME(i.LCurly), t.MANY((() => { t.SUBRULE(t.annotationTypeElementDeclaration) })), t.CONSUME(i.RCurly) })), t.RULE("annotationTypeElementDeclaration", (() => { t.MANY((() => { t.SUBRULE(t.modifier) })), t.SUBRULE(t.annotationTypeElementRest) })), t.RULE("annotationTypeElementRest", (() => { t.OR([{ ALT: () => { t.SUBRULE(t.typeType), t.SUBRULE(t.annotationMethodRestOrConstantRest), t.SUBRULE(t.semiColon) } }, { ALT: () => { t.SUBRULE(t.classDeclaration), t.OPTION((() => { t.SUBRULE2(t.semiColon) })) } }, { ALT: () => { t.SUBRULE(t.interfaceDeclaration), t.OPTION2((() => { t.SUBRULE3(t.semiColon) })) } }, { ALT: () => { t.SUBRULE(t.enumDeclaration), t.OPTION3((() => { t.SUBRULE4(t.semiColon) })) } }, { ALT: () => { t.SUBRULE(t.annotationTypeDeclaration), t.OPTION4((() => { t.SUBRULE5(t.semiColon) })) } }]) })), t.RULE("annotationMethodRestOrConstantRest", (() => { t.OR([{ ALT: () => t.SUBRULE(t.annotationMethodRest) }, { ALT: () => t.SUBRULE(t.annotationConstantRest) }]) })), t.RULE("annotationMethodRest", (() => { t.CONSUME(i.Identifier), t.CONSUME(i.LBrace), t.CONSUME(i.RBrace), t.OPTION((() => { t.SUBRULE(t.defaultValue) })) })), t.RULE("annotationConstantRest", (() => { t.SUBRULE(t.variableDeclarators) })), t.RULE("defaultValue", (() => { t.CONSUME(i.Default), t.SUBRULE(t.elementValue) })), t.RULE("typeList", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.typeType) } }) })), t.RULE("typeType", (() => { t.OR([{ ALT: () => { t.SUBRULE(t.annotation), t.OPTION((() => { t.OR2([{ ALT: () => t.SUBRULE(t.classOrInterfaceType) }, { ALT: () => t.SUBRULE(t.primitiveType) }]), t.MANY((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })) })) } }, { ALT: () => { t.OR3([{ ALT: () => t.SUBRULE2(t.classOrInterfaceType) }, { ALT: () => t.SUBRULE2(t.primitiveType) }]), t.MANY2((() => { t.CONSUME2(i.LSquare), t.CONSUME2(i.RSquare) })) } }]) })), t.RULE("typeTypeOrVoid", (() => { t.OR([{ ALT: () => t.SUBRULE(t.typeType) }, { ALT: () => t.CONSUME(i.Void) }]) })), t.RULE("classOrInterfaceType", (() => { t.SUBRULE(t.classOrInterfaceTypeElement), t.MANY({ GATE: () => this.LA(2).tokenType !== i.Class, DEF: () => { t.CONSUME(i.Dot), t.SUBRULE2(t.classOrInterfaceTypeElement) } }) })), t.RULE("classOrInterfaceTypeElement", (() => { t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.typeArguments) })) })), t.RULE("typeArguments", (() => { t.CONSUME(i.Less), t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.typeArgument) } }), t.CONSUME(i.Greater) })), t.RULE("typeArgumentsOrOperatorExpressionRest", (() => { t.CONSUME(i.Less), t.OR([{ ALT: () => t.CONSUME(i.This) }, { ALT: () => t.CONSUME(i.Super) }, { ALT: () => t.SUBRULE(t.literal) }, { ALT: () => { let e = !0; t.SUBRULE(t.typeArgument), t.MANY((() => { t.CONSUME(i.Comma), t.SUBRULE2(t.typeArgument), e = !1 })); let n = !1; t.OPTION3({ GATE: () => e, DEF: () => { t.CONSUME(i.LBrace), t.OPTION4((() => { t.SUBRULE(t.expressionList) })), t.CONSUME(i.RBrace), t.MANY2((() => { t.SUBRULE(t.dimension) })), n = !0 } }), t.OPTION5({ GATE: () => !n, DEF: () => { t.CONSUME(i.Greater) } }) } }, { ALT: () => { t.CONSUME2(i.LBrace), t.SUBRULE2(t.expression), t.CONSUME2(i.RBrace) } }]) })), t.RULE("typeArgument", (() => { t.OR([{ ALT: () => t.SUBRULE(t.typeType) }, { ALT: () => t.CONSUME(i.Questionmark) }]), t.OPTION((() => { t.OR2([{ ALT: () => t.CONSUME(i.Extends) }, { ALT: () => t.CONSUME(i.Super) }]), t.SUBRULE2(t.typeType) })) })), t.RULE("qualifiedNameList", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.qualifiedName) } }) })), t.RULE("identifiers", (() => { t.CONSUME(i.LBrace), t.OPTION((() => { t.SUBRULE(t.identifierList) })), t.CONSUME(i.RBrace) })), t.RULE("identifierList", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.CONSUME(i.Identifier) } }) })), t.RULE("formalParameters", (() => { t.CONSUME(i.LBrace), t.OPTION((() => { t.SUBRULE(t.formalParameterList) })), t.CONSUME(i.RBrace) })), t.RULE("formalParameterList", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.formalParameter) } }) })), t.RULE("formalParameter", (() => { t.MANY((() => { t.SUBRULE(t.variableModifier) })), t.SUBRULE(t.typeType), t.OPTION((() => { t.CONSUME(i.DotDotDot) })), t.SUBRULE(t.variableDeclaratorId) })), t.RULE("block", (() => { t.CONSUME(i.LCurly), t.MANY((() => { t.SUBRULE(t.blockStatement) })), t.CONSUME(i.RCurly) })), t.RULE("blockStatement", (() => { let e = !1; t.MANY((() => { t.SUBRULE(t.classOrInterfaceModifier) })), t.OR([{ ALT: () => { t.OR2([{ ALT: () => { t.SUBRULE(t.expression), t.OR3([{ ALT: () => { t.CONSUME(i.Colon), t.SUBRULE(t.statement) } }, { ALT: () => { t.SUBRULE(t.semiColon), e = !0 } }, { ALT: () => { t.OPTION((() => { t.SUBRULE(t.typeArguments) })), t.MANY2({ GATE: () => this.LA(2).tokenType !== i.Class, DEF: () => { t.CONSUME(i.Dot), t.SUBRULE2(t.classOrInterfaceTypeElement) } }) } }]) } }]), t.OPTION2({ GATE: () => !e, DEF: () => { t.MANY3((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })), t.SUBRULE(t.variableDeclarators), t.SUBRULE2(t.semiColon) } }) } }, { ALT: () => t.SUBRULE(t.classDeclaration) }, { ALT: () => t.SUBRULE(t.interfaceDeclaration) }, { ALT: () => t.SUBRULE(t.statementWithStartingToken) }]) })), t.RULE("statement", (() => { t.OR([{ ALT: () => t.SUBRULE(t.statementWithStartingToken) }, { ALT: () => t.SUBRULE(t.expressionStatement) }, { ALT: () => t.SUBRULE(t.identifierStatement) }]) })), t.RULE("statementWithStartingToken", (() => { t.OR([{ ALT: () => t.SUBRULE(t.block) }, { ALT: () => t.SUBRULE(t.assertStatement) }, { ALT: () => t.SUBRULE(t.ifStatement) }, { ALT: () => t.SUBRULE(t.forStatement) }, { ALT: () => t.SUBRULE(t.whileStatement) }, { ALT: () => t.SUBRULE(t.doWhileStatement) }, { ALT: () => t.SUBRULE(t.tryStatement) }, { ALT: () => t.SUBRULE(t.switchStatement) }, { ALT: () => t.SUBRULE(t.synchronizedStatement) }, { ALT: () => t.SUBRULE(t.returnStatement) }, { ALT: () => t.SUBRULE(t.throwStatement) }, { ALT: () => t.SUBRULE(t.breakStatement) }, { ALT: () => t.SUBRULE(t.continueStatement) }, { ALT: () => t.SUBRULE(t.semiColonStatement) }]) })), t.RULE("assertStatement", (() => { t.CONSUME(i.Assert), t.SUBRULE(t.expression), t.OPTION((() => { t.CONSUME(i.Colon), t.SUBRULE2(t.expression) })), t.SUBRULE(t.semiColon) })), t.RULE("ifStatement", (() => { t.CONSUME(i.If), t.CONSUME(i.LBrace), t.SUBRULE(t.expression), t.CONSUME(i.RBrace), t.SUBRULE(t.statement), t.OPTION((() => { t.CONSUME(i.Else), t.SUBRULE2(t.statement) })) })), t.RULE("whileStatement", (() => { t.CONSUME(i.While), t.CONSUME(i.LBrace), t.SUBRULE(t.expression), t.CONSUME(i.RBrace), t.SUBRULE(t.statement) })), t.RULE("doWhileStatement", (() => { t.CONSUME(i.Do), t.SUBRULE(t.statement), t.CONSUME(i.While), t.CONSUME(i.LBrace), t.SUBRULE(t.expression), t.CONSUME(i.RBrace), t.SUBRULE(t.semiColon) })), t.RULE("tryStatement", (() => { t.CONSUME(i.Try), t.OPTION((() => { t.SUBRULE(t.resourceSpecification) })), t.SUBRULE(t.block), t.OPTION1((() => { t.OR([{ ALT: () => { t.SUBRULE(t.catchClause), t.MANY((() => { t.SUBRULE2(t.catchClause) })), t.OPTION2((() => { t.SUBRULE(t.finallyBlock) })) } }, { ALT: () => t.SUBRULE2(t.finallyBlock) }]) })) })), t.RULE("switchStatement", (() => { t.CONSUME(i.Switch), t.CONSUME(i.LBrace), t.SUBRULE(t.expression), t.CONSUME(i.RBrace), t.CONSUME(i.LCurly), t.MANY((() => { t.SUBRULE(t.switchBlockStatementGroup) })), t.CONSUME(i.RCurly) })), t.RULE("synchronizedStatement", (() => { t.CONSUME(i.Synchronized), t.CONSUME(i.LBrace), t.SUBRULE(t.expression), t.CONSUME(i.RBrace), t.SUBRULE(t.block) })), t.RULE("returnStatement", (() => { t.CONSUME(i.Return), t.OPTION((() => { t.SUBRULE(t.expression) })), t.SUBRULE(t.semiColon) })), t.RULE("throwStatement", (() => { t.CONSUME(i.Throw), t.SUBRULE(t.expression), t.SUBRULE(t.semiColon) })), t.RULE("breakStatement", (() => { t.CONSUME(i.Break), t.OPTION((() => { t.CONSUME(i.Identifier) })), t.SUBRULE(t.semiColon) })), t.RULE("continueStatement", (() => { t.CONSUME(i.Continue), t.OPTION((() => { t.CONSUME(i.Identifier) })), t.SUBRULE(t.semiColon) })), t.RULE("semiColonStatement", (() => { t.SUBRULE(t.semiColon) })), t.RULE("expressionStatement", (() => { t.SUBRULE(t.expression), t.SUBRULE(t.semiColon) })), t.RULE("identifierStatement", (() => { t.CONSUME(i.Identifier), t.CONSUME(i.Colon), t.SUBRULE(t.statement) })), t.RULE("catchClause", (() => { t.CONSUME(i.Catch), t.CONSUME(i.LBrace), t.MANY((() => { t.SUBRULE(t.variableModifier) })), t.SUBRULE(t.catchType), t.CONSUME(i.Identifier), t.CONSUME(i.RBrace), t.SUBRULE(t.block) })), t.RULE("catchType", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Or, DEF: () => { t.SUBRULE(t.qualifiedName) } }) })), t.RULE("finallyBlock", (() => { t.CONSUME(i.Finally), t.SUBRULE(t.block) })), t.RULE("resourceSpecification", (() => { t.CONSUME(i.LBrace), t.SUBRULE(t.resources), t.OPTION((() => { t.SUBRULE(t.semiColon) })), t.CONSUME(i.RBrace) })), t.RULE("resources", (() => { t.SUBRULE(t.resource), t.MANY({ GATE: () => this.LA(2).tokenType !== i.RBrace, DEF: () => { t.SUBRULE(t.semiColon), t.SUBRULE2(t.resource) } }) })), t.RULE("resource", (() => { t.MANY((() => { t.SUBRULE(t.variableModifier) })), t.SUBRULE(t.classOrInterfaceType), t.SUBRULE(t.variableDeclaratorId), t.CONSUME(i.Equals), t.SUBRULE(t.expression) })), t.RULE("switchBlockStatementGroup", (() => { t.SUBRULE(t.switchLabel), t.MANY((() => { t.SUBRULE2(t.switchLabel) })), t.MANY2((() => { t.SUBRULE2(t.blockStatement) })) })), t.RULE("switchLabel", (() => { t.OR([{ ALT: () => t.SUBRULE(t.switchLabelCase) }, { ALT: () => t.SUBRULE(t.switchLabelDefault) }]) })), t.RULE("switchLabelCase", (() => { t.CONSUME(i.Case), t.SUBRULE(t.expression), t.CONSUME(i.Colon) })), t.RULE("switchLabelDefault", (() => { t.CONSUME(i.Default), t.CONSUME(i.Colon) })), t.RULE("forStatement", (() => { t.CONSUME(i.For), t.CONSUME(i.LBrace), t.SUBRULE(t.forControl), t.CONSUME(i.RBrace), t.SUBRULE(t.statement) })), t.RULE("forControl", (() => { let e = !1; t.OPTION((() => { let n = !1; t.MANY((() => { t.SUBRULE(t.variableModifier), n = !0 })), t.SUBRULE(t.expression), t.OR([{ ALT: () => { t.SUBRULE(t.variableDeclaratorId), t.OR2([{ ALT: () => { t.CONSUME(i.Colon), t.SUBRULE2(t.expression), e = !0 } }, { ALT: () => { t.OPTION2((() => { t.CONSUME(i.Equals), t.SUBRULE(t.variableInitializer) })) } }]), t.MANY2({ GATE: () => !e, DEF: () => { t.CONSUME(i.Comma), t.SUBRULE(t.variableDeclarator) } }) } }, { GATE: !n, ALT: () => { t.MANY3((() => { t.CONSUME2(i.Comma), t.SUBRULE3(t.expression) })) } }]) })), t.OR3([{ GATE: () => !e, ALT: () => { t.SUBRULE(t.semiColon), t.OPTION3((() => { t.SUBRULE4(t.expression).optionalExpression = !0 })), t.SUBRULE2(t.semiColon), t.OPTION4((() => { t.SUBRULE(t.expressionList) })) } }, { ALT: () => { } }]) })), t.RULE("enhancedForControl", (() => { t.MANY((() => { t.SUBRULE(t.variableModifier) })), t.SUBRULE(t.typeType), t.SUBRULE(t.variableDeclaratorId), t.CONSUME(i.Colon), t.SUBRULE(t.expression) })), t.RULE("explicitGenericInvocationSuffix", (() => { t.OR([{ ALT: () => t.SUBRULE(t.super) }, { ALT: () => t.SUBRULE(t.identifierArguments) }]) })), t.RULE("identifierArguments", (() => { t.CONSUME(i.Identifier), t.SUBRULE(t.arguments) })), t.RULE("super", (() => { t.CONSUME(i.Super), t.SUBRULE(t.superSuffix) })), t.RULE("superSuffix", (() => { t.OR([{ ALT: () => t.SUBRULE(t.arguments) }, { ALT: () => t.SUBRULE(t.dotIdentifierArguments) }]) })), t.RULE("arguments", (() => { t.CONSUME(i.LBrace), t.OPTION((() => { t.SUBRULE(t.expressionList) })), t.CONSUME(i.RBrace) })), t.RULE("dotIdentifierArguments", (() => { t.CONSUME(i.Dot), t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.arguments) })) })), t.RULE("parExpression", (() => { t.CONSUME(i.LBrace), t.SUBRULE(t.expression), t.CONSUME(i.RBrace) })), t.RULE("expressionList", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Comma, DEF: () => { t.SUBRULE(t.expression) } }) })), t.RULE("methodInvocation", (() => { t.CONSUME(i.Identifier), t.CONSUME(i.LBrace), t.OPTION((() => { t.SUBRULE(t.expressionList) })), t.CONSUME(i.RBrace), t.MANY((() => { t.SUBRULE(t.dimension) })) })), t.RULE("expression", (() => { t.OR([{ ALT: () => { t.SUBRULE(t.atomic), t.OR2([{ ALT: () => t.SUBRULE(t.instanceofExpressionRest) }, { ALT: () => t.SUBRULE(t.squareExpressionRest) }, { ALT: () => t.SUBRULE(t.postfixExpressionRest) }, { ALT: () => { t.SUBRULE(t.ifElseExpressionRest) } }, { ALT: () => { t.SUBRULE(t.qualifiedExpressionRest), t.OR3([{ ALT: () => t.SUBRULE2(t.postfixExpressionRest) }, { ALT: () => { t.OR4([{ ALT: () => t.SUBRULE2(t.instanceofExpressionRest) }, { ALT: () => t.MANY((() => { t.SUBRULE(t.operatorExpressionRest) })) }]), t.OPTION((() => t.SUBRULE2(t.ifElseExpressionRest))) } }]) } }, { ALT: () => { t.CONSUME(i.Pointer), t.SUBRULE(t.lambdaBody) } }, { ALT: () => t.SUBRULE(t.methodReferenceRest) }, { ALT: () => { t.MANY2((() => { t.SUBRULE2(t.operatorExpressionRest), t.OPTION2((() => { t.SUBRULE3(t.ifElseExpressionRest) })) })) } }]) } }, { ALT: () => { t.SUBRULE(t.prefixExpression) } }, { ALT: () => { t.SUBRULE(t.parExpressionOrCastExpressionOrLambdaExpression) } }]) })), t.RULE("atomic", (() => { t.OR([{ ALT: () => t.SUBRULE(t.methodInvocation) }, { ALT: () => t.SUBRULE(t.primary) }, { ALT: () => t.SUBRULE(t.creator) }]) })), t.RULE("instanceofExpressionRest", (() => { t.CONSUME(i.Instanceof), t.SUBRULE(t.typeType), t.MANY((() => { t.SUBRULE(t.operatorExpressionRest) })) })), t.RULE("squareExpressionRest", (() => { t.CONSUME(i.LSquare), t.SUBRULE(t.expression), t.CONSUME(i.RSquare) })), t.RULE("postfixExpressionRest", (() => { t.OR([{ ALT: () => { t.CONSUME(i.PlusPlus) } }, { ALT: () => { t.CONSUME(i.MinusMinus) } }]) })), t.RULE("ifElseExpressionRest", (() => { t.CONSUME(i.Questionmark), t.SUBRULE(t.expression), t.CONSUME(i.Colon), t.SUBRULE2(t.expression) })), t.RULE("qualifiedExpressionRest", (() => { t.CONSUME(i.Dot), t.OR([{ ALT: () => t.SUBRULE(t.methodInvocation) }, { ALT: () => { t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.typeArgumentsOrOperatorExpressionRest) })), t.MANY((() => { t.SUBRULE(t.dimension) })) } }, { ALT: () => t.CONSUME(i.Class) }, { ALT: () => t.CONSUME(i.This) }, { ALT: () => t.CONSUME(i.Super) }, { ALT: () => t.SUBRULE(t.creatorOptionalNonWildcardInnerCreator) }, { ALT: () => t.SUBRULE(t.explicitGenericInvocation) }]), t.OR2([{ ALT: () => t.SUBRULE(t.qualifiedExpressionRest) }, { ALT: () => t.SUBRULE(t.methodReferenceRest) }, { ALT: () => { } }]) })), t.RULE("creatorOptionalNonWildcardInnerCreator", (() => { t.CONSUME(i.New), t.OPTION((() => { t.SUBRULE(t.nonWildcardTypeArguments) })), t.SUBRULE(t.innerCreator) })), t.RULE("prefixExpression", (() => { t.OR([{ ALT: () => { t.CONSUME(i.Plus) } }, { ALT: () => { t.CONSUME(i.Minus) } }, { ALT: () => { t.CONSUME(i.PlusPlus) } }, { ALT: () => { t.CONSUME(i.MinusMinus) } }, { ALT: () => { t.CONSUME(i.Tilde) } }, { ALT: () => { t.CONSUME(i.Exclamationmark) } }]), t.SUBRULE(t.expression) })), t.RULE("parExpressionOrCastExpressionOrLambdaExpression", (() => { t.CONSUME(i.LBrace), t.OR([{ ALT: () => { t.CONSUME(i.RBrace), t.CONSUME(i.Pointer), t.SUBRULE(t.lambdaBody) } }, { ALT: () => { let e = !1, n = 0; t.OPTION((() => { t.CONSUME(i.Final).cnt = n, e = !0 })), t.SUBRULE(t.expression), e ? t.SUBRULE2(t.variableDeclaratorId) : t.OPTION2((() => { t.SUBRULE(t.variableDeclaratorId), e = !0 })), t.MANY((() => { n++, t.CONSUME(i.Comma), e && t.OPTION3((() => { t.CONSUME2(i.Final).cnt = n })), t.SUBRULE2(t.expression), e && t.SUBRULE3(t.variableDeclaratorId) })), t.CONSUME2(i.RBrace), t.OR2([{ ALT: () => { t.CONSUME2(i.Pointer), t.SUBRULE2(t.lambdaBody) } }, { GATE: () => !e, ALT: () => { let e = !1; t.OPTION4((() => { t.SUBRULE(t.operator), e = !0 })), t.SUBRULE3(t.expression), t.MANY2({ GATE: () => e, DEF: () => { t.SUBRULE(t.operatorExpressionRest) } }), t.OPTION5({ GATE: () => e, DEF: () => { t.SUBRULE(t.ifElseExpressionRest) } }) } }, { GATE: () => !e, ALT: () => { t.SUBRULE(t.qualifiedExpressionRest), t.MANY3((() => { t.SUBRULE2(t.operatorExpressionRest) })), t.OR3([{ ALT: () => t.SUBRULE2(t.ifElseExpressionRest) }, { ALT: () => { } }]) } }, { GATE: () => !e, ALT: () => { t.SUBRULE3(t.ifElseExpressionRest) } }, { GATE: () => !e, ALT: () => { } }]) } }]) })), t.RULE("operator", (() => { t.OR([{ ALT: () => { t.CONSUME(i.Star) } }, { ALT: () => { t.CONSUME(i.Dash) } }, { ALT: () => { t.CONSUME(i.Percentage) } }, { ALT: () => { t.CONSUME(i.Plus) } }, { ALT: () => { t.CONSUME(i.Minus) } }, { ALT: () => { t.CONSUME(i.LessLess) } }, { ALT: () => { t.CONSUME(i.LessEquals) } }, { ALT: () => { t.CONSUME(i.GreaterEquals) } }, { ALT: () => { t.CONSUME(i.Greater), t.OPTION((() => { t.CONSUME2(i.Greater), t.OPTION2((() => { t.CONSUME3(i.Greater) })) })) } }, { ALT: () => { t.CONSUME(i.Less) } }, { ALT: () => { t.CONSUME(i.EqualsEquals) } }, { ALT: () => { t.CONSUME(i.ExclamationmarkEquals) } }, { ALT: () => { t.CONSUME(i.And) } }, { ALT: () => { t.CONSUME(i.Caret) } }, { ALT: () => { t.CONSUME(i.Or) } }, { ALT: () => { t.CONSUME(i.AndAnd) } }, { ALT: () => { t.CONSUME(i.OrOr) } }, { ALT: () => { t.CONSUME(i.Equals) } }, { ALT: () => { t.CONSUME(i.PlusEquals) } }, { ALT: () => { t.CONSUME(i.MinusEquals) } }, { ALT: () => { t.CONSUME(i.StarEquals) } }, { ALT: () => { t.CONSUME(i.DashEquals) } }, { ALT: () => { t.CONSUME(i.AndEquals) } }, { ALT: () => { t.CONSUME(i.OrEquals) } }, { ALT: () => { t.CONSUME(i.CaretEquals) } }, { ALT: () => { t.CONSUME(i.GreaterGreaterEquals) } }, { ALT: () => { t.CONSUME(i.GreaterGreaterGreaterEquals) } }, { ALT: () => { t.CONSUME(i.LessLessEquals) } }, { ALT: () => { t.CONSUME(i.PercentageEquals) } }]) })), t.RULE("operatorExpressionRest", (() => { const e = t.SUBRULE(t.operator); t.OR([{ ALT: () => t.SUBRULE(t.expression) }, { GATE: () => e.children.Equals.length > 0, ALT: () => t.SUBRULE(t.elementValueArrayInitializer) }]) })), t.RULE("methodReferenceRest", (() => { t.CONSUME(i.ColonColon), t.OPTION((() => { t.SUBRULE(t.typeArguments) })), t.OR([{ ALT: () => { t.CONSUME(i.Identifier) } }, { ALT: () => { t.CONSUME(i.New) } }]) })), t.RULE("lambdaExpression", (() => { t.SUBRULE(t.lambdaParameters), t.CONSUME(i.Pointer), t.SUBRULE(t.lambdaBody) })), t.RULE("lambdaParameters", (() => { t.OR([{ ALT: () => t.CONSUME(i.Identifier) }, { ALT: () => { t.CONSUME(i.LBrace), t.CONSUME(i.RBrace) } }, { ALT: () => { t.CONSUME2(i.LBrace), t.SUBRULE(t.formalParameterList), t.CONSUME2(i.RBrace) } }, { ALT: () => { t.CONSUME3(i.LBrace), t.SUBRULE(t.identifierList), t.CONSUME3(i.RBrace) } }]) })), t.RULE("lambdaBody", (() => { t.OR([{ ALT: () => t.SUBRULE(t.expression) }, { ALT: () => t.SUBRULE(t.block) }]) })), t.RULE("classType", (() => { t.MANY((() => { t.SUBRULE(t.annotation) })), t.SUBRULE(t.classOrInterfaceType) })), t.RULE("creator", (() => { t.CONSUME(i.New), t.OR([{ ALT: () => t.SUBRULE(t.nonWildcardCreator) }, { ALT: () => t.SUBRULE(t.simpleCreator) }]) })), t.RULE("nonWildcardCreator", (() => { t.SUBRULE(t.nonWildcardTypeArguments), t.SUBRULE(t.createdName), t.SUBRULE(t.classCreatorRest) })), t.RULE("simpleCreator", (() => { t.SUBRULE(t.createdName), t.OR([{ ALT: () => t.SUBRULE(t.arrayCreatorRest) }, { ALT: () => t.SUBRULE(t.classCreatorRest) }]) })), t.RULE("createdName", (() => { t.OR([{ ALT: () => t.SUBRULE(t.identifierName) }, { ALT: () => t.SUBRULE(t.primitiveType) }]) })), t.RULE("identifierName", (() => { t.AT_LEAST_ONE_SEP({ SEP: i.Dot, DEF: () => { t.SUBRULE(t.identifierNameElement) } }) })), t.RULE("identifierNameElement", (() => { t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.nonWildcardTypeArgumentsOrDiamond) })) })), t.RULE("innerCreator", (() => { t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.nonWildcardTypeArgumentsOrDiamond) })), t.SUBRULE(t.classCreatorRest) })), t.RULE("arrayCreatorRest", (() => { t.CONSUME(i.LSquare), t.OR([{ ALT: () => { t.CONSUME(i.RSquare), t.MANY((() => { t.CONSUME2(i.LSquare), t.CONSUME2(i.RSquare) })), t.SUBRULE(t.arrayInitializer) } }, { ALT: () => { t.SUBRULE(t.expression), t.CONSUME3(i.RSquare), t.MANY2((() => { t.CONSUME4(i.LSquare), t.SUBRULE2(t.expression), t.CONSUME4(i.RSquare) })), t.MANY3((() => { t.CONSUME5(i.LSquare), t.CONSUME5(i.RSquare) })) } }]) })), t.RULE("classCreatorRest", (() => { t.SUBRULE(t.arguments), t.OPTION((() => { t.SUBRULE(t.classBody) })) })), t.RULE("explicitGenericInvocation", (() => { t.SUBRULE(t.nonWildcardTypeArguments), t.SUBRULE(t.explicitGenericInvocationSuffix) })), t.RULE("typeArgumentsOrDiamond", (() => { t.OR([{ ALT: () => t.SUBRULE(t.emptyDiamond) }, { ALT: () => t.SUBRULE(t.typeArguments) }]) })), t.RULE("nonWildcardTypeArgumentsOrDiamond", (() => { t.OR([{ ALT: () => t.SUBRULE(t.emptyDiamond) }, { ALT: () => t.SUBRULE(t.nonWildcardTypeArguments) }]) })), t.RULE("emptyDiamond", (() => { t.CONSUME(i.Less), t.CONSUME(i.Greater) })), t.RULE("nonWildcardTypeArguments", (() => { t.CONSUME(i.Less), t.SUBRULE(t.typeList), t.CONSUME(i.Greater) })), t.RULE("qualifiedName", (() => { t.CONSUME(i.Identifier), t.MANY({ GATE: () => this.LA(2).tokenType === i.Identifier, DEF: () => { t.CONSUME(i.Dot), t.CONSUME2(i.Identifier) } }) })), t.RULE("primary", (() => { t.OR([{ ALT: () => { t.SUBRULE(t.thisOrSuper) } }, { ALT: () => t.SUBRULE(t.literal) }, { ALT: () => { t.OR2([{ ALT: () => { t.SUBRULE(t.annotation), t.OPTION2((() => { t.OR3([{ ALT: () => { t.CONSUME(i.Identifier), t.OPTION3((() => { t.SUBRULE(t.typeArguments) })) } }, { ALT: () => t.SUBRULE(t.primitiveType) }]), t.MANY((() => { t.CONSUME(i.LSquare), t.CONSUME(i.RSquare) })) })) } }, { ALT: () => { t.OR4([{ ALT: () => { t.SUBRULE(t.identifierOrIdentifierWithTypeArgumentsOrOperatorExpression) } }, { ALT: () => t.SUBRULE2(t.primitiveType) }]), t.MANY2((() => { t.SUBRULE(t.dimension) })) } }]) } }, { ALT: () => t.CONSUME(i.Void) }, { ALT: () => { t.SUBRULE(t.nonWildcardTypeArguments), t.OR5([{ ALT: () => t.SUBRULE(t.explicitGenericInvocationSuffix) }, { ALT: () => { t.CONSUME2(i.This), t.SUBRULE2(t.arguments) } }]) } }]) })), t.RULE("identifierOrIdentifierWithTypeArgumentsOrOperatorExpression", (() => { t.CONSUME(i.Identifier), t.OPTION((() => { t.SUBRULE(t.typeArgumentsOrOperatorExpressionRest) })) })), t.RULE("dimension", (() => { t.CONSUME(i.LSquare), t.OPTION((() => t.SUBRULE(t.expression))), t.CONSUME(i.RSquare) })), t.RULE("thisOrSuper", (() => { t.OR([{ ALT: () => { t.CONSUME(i.This) } }, { ALT: () => { t.CONSUME(i.Super) } }]), t.OPTION((() => t.SUBRULE(t.arguments))) })), t.RULE("literal", (() => { t.OR([{ ALT: () => t.SUBRULE(t.integerLiteral) }, { ALT: () => t.SUBRULE(t.floatLiteral) }, { ALT: () => t.CONSUME(i.CharLiteral) }, { ALT: () => t.SUBRULE(t.stringLiteral) }, { ALT: () => t.SUBRULE(t.booleanLiteral) }, { ALT: () => t.CONSUME(i.Null) }]) })), t.RULE("stringLiteral", (() => { t.CONSUME(i.StringLiteral) })), t.RULE("booleanLiteral", (() => { t.OR([{ ALT: () => t.CONSUME(i.True) }, { ALT: () => t.CONSUME(i.False) }]) })), t.RULE("integerLiteral", (() => { t.OR([{ ALT: () => t.CONSUME(i.DecimalLiteral) }, { ALT: () => t.CONSUME(i.HexLiteral) }, { ALT: () => t.CONSUME(i.OctLiteral) }, { ALT: () => t.CONSUME(i.BinaryLiteral) }]) })), t.RULE("floatLiteral", (() => { t.OR([{ ALT: () => t.CONSUME(i.FloatLiteral) }, { ALT: () => t.CONSUME(i.HexFloatLiteral) }]) })), t.RULE("primitiveType", (() => { t.OR([{ ALT: () => t.CONSUME(i.Boolean) }, { ALT: () => t.CONSUME(i.Char) }, { ALT: () => t.CONSUME(i.Byte) }, { ALT: () => t.CONSUME(i.Short) }, { ALT: () => t.CONSUME(i.Int) }, { ALT: () => t.CONSUME(i.Long) }, { ALT: () => t.CONSUME(i.Float) }, { ALT: () => t.CONSUME(i.Double) }]) })), t.RULE("semiColon", (() => { t.OR([{ ALT: () => t.CONSUME(i.SemiColon) }, { ALT: () => t.CONSUME(i.SemiColonWithFollowEmptyLine) }]) })), u.performSelfAnalysis(this) } LA(e) { if (1 === e) { let t = super.LA(e); for (; r.tokenMatcher(t, i.LineComment) || r.tokenMatcher(t, i.JavaDocComment) || r.tokenMatcher(t, i.TraditionalComment) || r.tokenMatcher(t, i.LineCommentStandalone) || r.tokenMatcher(t, i.JavaDocCommentStandalone) || r.tokenMatcher(t, i.TraditionalCommentStandalone);) { const n = t; if (super.consumeToken(), t = super.LA(e), !this.isEmptyComment(n)) { const e = this.CST_STACK[this.CST_STACK.length - 1]; "classBody" !== e.name && "interfaceBody" !== e.name && "block" !== e.name || (r.tokenMatcher(n, i.LineCommentStandalone) || r.tokenMatcher(n, i.JavaDocCommentStandalone) || r.tokenMatcher(n, i.TraditionalCommentStandalone) || this.lastToken && this.lastToken.startLine !== n.startLine && r.tokenMatcher(t, i.RCurly) && (r.tokenMatcher(n, i.LineComment) || r.tokenMatcher(n, i.JavaDocComment) || r.tokenMatcher(n, i.TraditionalComment))) && ("classBody" === e.name ? this.addCommentStandAlone(e, "classBodyDeclaration", n) : "interfaceBody" === e.name ? this.addCommentStandAlone(e, "interfaceBodyDeclaration", n) : "block" === e.name && this.addCommentStandAlone(e, "blockStatement", n)) } } return this.lastToken = t, t } if (e > 1) return this.LAgreater1(e) } addCommentStandAlone(e, t, n) { e.children[t] || (e.children[t] = []), e.children[t].push({ name: n.image.startsWith("//") ? "LineCommentStandalone" : "JavaDocTraditionalCommentStandalone", children: { image: n.image } }), n.added = !0 } LAgreater1(e) { let t = this.currIdx; for (let n = 0; n < e; n++)t = this.skipComments(t + 1); return this.input[t] || d } skipComments(e) { let t = this.input[e]; for (; t && (r.tokenMatcher(t, i.LineComment) || r.tokenMatcher(t, i.JavaDocComment) || r.tokenMatcher(t, i.TraditionalComment) || r.tokenMatcher(t, i.LineCommentStandalone) || r.tokenMatcher(t, i.JavaDocCommentStandalone) || r.tokenMatcher(t, i.TraditionalCommentStandalone));)e++, t = this.input[e]; return e } cstPostTerminal(e, t) { super.cstPostTerminal(e, t); const n = this.CST_STACK[this.CST_STACK.length - 1]; if ("semiColon" === n.name) { const e = super.LA(1); r.tokenMatcher(e, i.LineComment) && !e.added && (n.children.SemiColon && e.startLine === n.children.SemiColon[0].startLine || n.children.SemiColonWithFollowEmptyLine && e.startLine === n.children.SemiColonWithFollowEmptyLine[0].startLine) && (e.trailing = !0, e.added = !0, this.CST_STACK[this.CST_STACK.length - 2].children[i.LineComment.tokenName] = [e]) } else { let e = -1, t = super.LA(e); for (; !t.added && (r.tokenMatcher(t, i.LineComment) || r.tokenMatcher(t, i.TraditionalComment) || r.tokenMatcher(t, i.JavaDocComment) || r.tokenMatcher(t, i.LineCommentStandalone) || r.tokenMatcher(t, i.TraditionalCommentStandalone) || r.tokenMatcher(t, i.JavaDocCommentStandalone));)this.isEmptyComment(t) || super.cstPostTerminal(t.tokenType.tokenName.replace("Standalone", ""), t), e--, t = super.LA(e) } } isEmptyComment(e) { return r.tokenMatcher(e, i.LineComment) && "//" === e.image.replace(/[\s]*/g, "") || r.tokenMatcher(e, i.JavaDocComment) && "//" === e.image.replace(/[\s\n\r*]*/g, "") || r.tokenMatcher(e, i.TraditionalComment) && "//" === e.image.replace(/[\s\n\r*]*/g, "") || r.tokenMatcher(e, i.LineCommentStandalone) && "//" === e.image.replace(/[\s]*/g, "") || r.tokenMatcher(e, i.JavaDocCommentStandalone) && "//" === e.image.replace(/[\s\n\r*]*/g, "") || r.tokenMatcher(e, i.TraditionalCommentStandalone) && "//" === e.image.replace(/[\s\n\r*]*/g, "") } } e.exports = o }, 803: (e, t, n) => { const r = n(7177), a = n(3414), i = {}; function u(e, t) { i[e] = a.build(t, i) } function d(e, t) { return a.build(e, i, t) } u("Digits", "[0-9]([0-9_]*[0-9])?"), u("ExponentPart", "[eE][+-]?{{Digits}}"), u("HexDigit", "[0-9a-fA-F]"), u("HexDigits", "{{HexDigit}}(({{HexDigit}}|'_')*{{HexDigit}})?"); const o = r.createToken, s = o({ name: "Identifier", pattern: /[a-zA-Z_\\$][a-zA-Z_\\$0-9]*/ }); function c(e) { return e.longer_alt = s, o(e) } const f = c({ name: "Package", pattern: /package/, label: "'package'" }), l = c({ name: "Case", pattern: /case/, label: "'case'" }), p = c({ name: "Catch", pattern: /catch/, label: "'catch'" }), h = c({ name: "Finally", pattern: /finally/, label: "'finally'" }), m = c({ name: "Default", pattern: /default/, label: "'default'" }), E = c({ name: "Import", pattern: /import/, label: "'import'" }), y = c({ name: "Boolean", pattern: /boolean/, label: "'boolean'" }), T = c({ name: "Char", pattern: /char/, label: "'char'" }), S = c({ name: "Byte", pattern: /byte/, label: "'byte'" }), v = c({ name: "Short", pattern: /short/, label: "'short'" }), R = c({ name: "Int", pattern: /int/, label: "'int'" }), L = c({ name: "Long", pattern: /long/, label: "'long'" }), A = c({ name: "Float", pattern: /float/, label: "'float'" }), O = c({ name: "Double", pattern: /double/, label: "'double'" }), b = c({ name: "Void", pattern: /void/, label: "'void'" }), I = c({ name: "Public", pattern: /public/, label: "'public'" }), N = c({ name: "Protected", pattern: /protected/, label: "'protected'" }), g = c({ name: "Private", pattern: /private/, label: "'private'" }), _ = c({ name: "Static", pattern: /static/, label: "'static'" }), U = c({ name: "Abstract", pattern: /abstract/, label: "'abstract'" }), C = c({ name: "Final", pattern: /final/, label: "'final'" }), x = c({ name: "Native", pattern: /native/, label: "'native'" }), M = c({ name: "Synchronized", pattern: /synchronized/, label: "'synchronized'" }), P = c({ name: "Transient", pattern: /transient/, label: "'transient'" }), k = c({ name: "Extends", pattern: /extends/, label: "'extends'" }), D = c({ name: "Implements", pattern: /implements/, label: "'implements'" }), B = c({ name: "New", pattern: /new/, label: "'new'" }), w = c({ name: "This", pattern: /this/, label: "'this'" }), F = c({ name: "Super", pattern: /super/, label: "'super'" }), G = c({ name: "Throws", pattern: /throws/, label: "'throws'" }), Y = c({ name: "Throw", pattern: /throw/, label: "'throw'" }), V = c({ name: "Return", pattern: /return/, label: "'return'" }), W = c({ name: "Break", pattern: /break/, label: "'break'" }), q = c({ name: "Continue", pattern: /continue/, label: "'continue'" }), j = c({ name: "If", pattern: /if/, label: "'if'" }), K = c({ name: "Else", pattern: /else/, label: "'else'" }), H = c({ name: "While", pattern: /while/, label: "'while'" }), z = c({ name: "Do", pattern: /do/, label: "'do'" }), X = c({ name: "Try", pattern: /try/, label: "'try'" }), $ = c({ name: "Switch", pattern: /switch/, label: "'switch'" }), J = c({ name: "For", pattern: /for/, label: "'for'" }), Z = c({ name: "True", pattern: /true/, label: "'true'" }), Q = c({ name: "False", pattern: /false/, label: "'false'" }), ee = c({ name: "Null", pattern: /null/, label: "'null'" }), te = c({ name: "Assert", pattern: /assert/, label: "'assert'" }), ne = c({ name: "Instanceof", pattern: /instanceof/, label: "'instanceof'" }), re = c({ name: "Volatile", pattern: /volatile/, label: "'volatile'" }), ae = c({ name: "Strictfp", pattern: /strictfp/, label: "'strictfp'" }), ie = c({ name: "Class", pattern: /class/, label: "'class'" }), ue = c({ name: "Enum", pattern: /enum/, label: "'enum'" }), de = c({ name: "Interface", pattern: /interface/, label: "'interface'" }), oe = o({ name: "LBrace", pattern: /\(/, label: "'('" }), se = o({ name: "RBrace", pattern: /\)/, label: "')'" }), ce = o({ name: "LCurly", pattern: "{", label: "'{'" }), fe = o({ name: "RCurly", pattern: /}/, label: "'}'" }), le = o({ name: "LSquare", pattern: /\[/, label: "'['" }), pe = o({ name: "RSquare", pattern: /]/, label: "']'" }), he = o({ name: "Pointer", pattern: /->/, label: "'->'" }), me = o({ name: "Less", pattern: /</, label: "'<'" }), Ee = o({ name: "LessEquals", pattern: /<=/, label: "'<='" }), ye = o({ name: "LessLess", pattern: /<</, label: "'<<'" }), Te = o({ name: "LessLessEquals", pattern: /<<=/, label: "'<<='" }), Se = o({ name: "Greater", pattern: />/, label: "'>'" }), ve = o({ name: "GreaterEquals", pattern: />=/, label: "'>='" }), Re = o({ name: "GreaterGreaterEquals", pattern: />>=/, label: "'>>='" }), Le = o({ name: "GreaterGreaterGreaterEquals", pattern: />>>=/, label: "'>>>='" }), Ae = o({ name: "DotDotDot", pattern: /\.\.\./, label: "'...'" }), Oe = o({ name: "Dot", pattern: /\./, label: "'.'" }), be = o({ name: "Comma", pattern: /,/, label: "','" }), Ie = o({ name: "SemiColonWithFollowEmptyLine", pattern: /;[ \t]*(\r\n|\r[^\n]|\n)[ \t]*(\r\n|\r|\n)/, label: "';'", line_breaks: !0 }), Ne = o({ name: "SemiColon", pattern: /;/, label: "';'" }), ge = o({ name: "ColonColon", pattern: /::/, label: "'::'" }), _e = o({ name: "Colon", pattern: /:/, label: "':'" }), Ue = o({ name: "Equals", pattern: /=/, label: "'='" }), Ce = o({ name: "EqualsEquals", pattern: /==/, label: "'=='" }), xe = o({ name: "Minus", pattern: /-/, label: "'-'" }), Me = o({ name: "MinusEquals", pattern: /-=/, label: "'-='" }), Pe = o({ name: "MinusMinus", pattern: /--/, label: "'--'" }), ke = o({ name: "Plus", pattern: /\+/, label: "'+'" }), De = o({ name: "PlusEquals", pattern: /\+=/, label: "'+='" }), Be = o({ name: "PlusPlus", pattern: /\+\+/, label: "'++'" }), we = o({ name: "And", pattern: /&/, label: "'&'" }), Fe = o({ name: "AndAnd", pattern: /&&/, label: "'&&'" }), Ge = o({ name: "AndEquals", pattern: /&=/, label: "'&='" }), Ye = o({ name: "At", pattern: /@/, label: "'@'" }), Ve = o({ name: "Caret", pattern: /\^/, label: "'^'" }), We = o({ name: "CaretEquals", pattern: /\^=/, label: "'^='" }), qe = o({ name: "Questionmark", pattern: /\?/, label: "'?'" }), je = o({ name: "Exclamationmark", pattern: /!/, label: "'!'" }), Ke = o({ name: "ExclamationmarkEquals", pattern: /!=/, label: "'!='" }), He = o({ name: "Tilde", pattern: /~/, label: "'~'" }), ze = o({ name: "Or", pattern: /\|/, label: "'|'" }), Xe = o({ name: "OrEquals", pattern: /\|=/, label: "'|='" }), $e = o({ name: "OrOr", pattern: /\|\|/, label: "'||'" }), Je = o({ name: "Star", pattern: /\*/, label: "'*'" }), Ze = o({ name: "StarEquals", pattern: /\*=/, label: "'*='" }), Qe = o({ name: "Dash", pattern: /\//, label: "'/'" }), et = o({ name: "DashEquals", pattern: /\/=/, label: "'/='" }), tt = o({ name: "Percentage", pattern: /%/, label: "'%'" }), nt = o({ name: "PercentageEquals", pattern: /%=/, label: "'%='" }), rt = o({ name: "BinaryLiteral", pattern: d("0[bB][01]([01_]*[01])?[lL]?"), label: "'BinaryLiteral'" }), at = o({ name: "OctLiteral", pattern: d("0_*[0-7]([0-7_]*[0-7])?[lL]?"), label: "'OctLiteral'" }), it = o({ name: "HexLiteral", pattern: d("0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?[lL]?"), label: "'HexLiteral'" }), ut = o({ name: "FloatLiteral", pattern: d("-?({{Digits}}\\.{{Digits}}?|\\.{{Digits}}){{ExponentPart}}?[fFdD]?|{{Digits}}({{ExponentPart}}[fFdD]?|[fFdD])"), label: "'FloatLiteral'" }), dt = o({ name: "HexFloatLiteral", pattern: d("0[xX]({{HexDigits}}\\.?|{{HexDigits}}?\\.{{HexDigits}})[pP][+-]?{{Digits}}[fFdD]?"), label: "'HexFloatLiteral'" }), ot = o({ name: "DecimalLiteral", pattern: d("-?(0|[1-9]({{Digits}}?|_+{{Digits}}))[lL]?"), label: "'DecimalLiteral'" }), st = o({ name: "CharLiteral", pattern: d("'((\\')|[^']|(\\\\)|(\\\\(u[a-zA-Z0-9]{4})?))'"), start_chars_hint: ["'"], label: "'CharLiteral'" }), ct = o({ name: "StringLiteral", pattern: d('"[^"\\\\]*(\\\\.[^"\\\\]*)*"'), label: "'StringLiteral'" }), ft = o({ name: "LineComment", pattern: /\/\/[^\n\r]*/ }), lt = o({ name: "LineCommentStandalone", pattern: /\/\/[^\n\r]*((\n|[\r][^\n]|\r\n)s*){2,}/, line_breaks: !0 }), pt = o({ name: "JavaDocComment", pattern: /\/\*\*([^*]|\*(?!\/))*\*\//, line_breaks: !0 }), ht = o({ name: "JavaDocCommentStandalone", pattern: /\/\*\*([^*]|\*(?!\/))*\*\/(((\n)|([\r][^\n])|(\r\n))\s*){2,}/, line_breaks: !0 }), mt = o({ name: "TraditionalComment", pattern: /\/\*([^*]|\*(?!\/))*\*\//, line_breaks: !0 }), Et = o({ name: "TraditionalCommentStandalone", pattern: /\/\*([^*]|\*(?!\/))*\*\/(((\n)|([\r][^\n])|(\r\n))\s*){2,}/, line_breaks: !0 }), yt = o({ name: "WhiteSpace", pattern: /\s+/, group: r.Lexer.SKIPPED, line_breaks: !0 }), Tt = [yt, lt, ft, ht, pt, Et, mt, y, T, S, v, de, R, L, A, O, b, I, N, g, _, U, p, h, C, x, M, P, k, D, B, w, F, G, Y, V, W, q, j, K, H, z, X, $, J, Z, Q, ee, te, ne, re, ae, ie, ue, E, f, m, l, rt, at, dt, it, ut, ot, st, ct, s, Ae, Oe, be, Ie, Ne, ge, _e, Ce, Ke, Ue, Be, De, ke, he, Pe, Me, xe, Fe, Ge, we, $e, Xe, ze, oe, se, ce, fe, le, pe, Te, ye, Ee, me, Re, Le, ve, Se, Ye, We, Ve, Ze, Je, et, Qe, nt, tt, qe, je, He]; e.exports = { allTokens: Tt, tokens: { WhiteSpace: yt, LineCommentStandalone: lt, LineComment: ft, JavaDocCommentStandalone: ht, JavaDocComment: pt, TraditionalCommentStandalone: Et, TraditionalComment: mt, Boolean: y, Char: T, Byte: S, Short: v, Interface: de, Int: R, Long: L, Float: A, Double: O, Void: b, Public: I, Protected: N, Private: g, Static: _, Abstract: U, Catch: p, Finally: h, Final: C, Native: x, Synchronized: M, Transient: P, Extends: k, Implements: D, New: B, This: w, Super: F, Throws: G, Throw: Y, Return: V, Break: W, Continue: q, If: j, Else: K, While: H, Do: z, Try: X, Switch: $, For: J, True: Z, False: Q, Null: ee, Assert: te, Instanceof: ne, Volatile: re, Strictfp: ae, Class: ie, Enum: ue, Import: E, Package: f, Default: m, Case: l, BinaryLiteral: rt, HexFloatLiteral: dt, HexLiteral: it, OctLiteral: at, FloatLiteral: ut, DecimalLiteral: ot, CharLiteral: st, StringLiteral: ct, Identifier: s, DotDotDot: Ae, Dot: Oe, Comma: be, SemiColonWithFollowEmptyLine: Ie, SemiColon: Ne, ColonColon: ge, Colon: _e, EqualsEquals: Ce, ExclamationmarkEquals: Ke, Equals: Ue, PlusPlus: Be, PlusEquals: De, Plus: ke, Pointer: he, MinusMinus: Pe, MinusEquals: Me, Minus: xe, AndAnd: Fe, AndEquals: Ge, And: we, OrOr: $e, OrEquals: Xe, Or: ze, LBrace: oe, RBrace: se, LCurly: ce, RCurly: fe, LSquare: le, RSquare: pe, LessLessEquals: Te, LessLess: ye, LessEquals: Ee, Less: me, GreaterGreaterEquals: Re, GreaterGreaterGreaterEquals: Le, GreaterEquals: ve, Greater: Se, At: Ye, CaretEquals: We, Caret: Ve, StarEquals: Ze, Star: Je, DashEquals: et, Dash: Qe, PercentageEquals: nt, Percentage: tt, Questionmark: qe, Exclamationmark: je, Tilde: He } } }, 4390: (e, t, n) => { const r = new (n(2477))([]).getBaseCstVisitorConstructor(), a = n(7177).MismatchedTokenException; e.exports = class extends r { constructor() { super(), this.validateVisitor() } compilationUnit(e) { let t = []; e.annotation && e.annotation.map((e => t.push(this.visit(e)))); const n = this.visit(e.packageDeclaration); null != n && t.length > 0 && (n.modifiers = t, t = []); const r = []; e.importDeclaration && e.importDeclaration.map((e => r.push(this.visit(e)))); const a = []; if (e.typeDeclaration && (e.typeDeclaration.map((e => a.push(this.visit(e)))), a.length > 0 && t.length > 0)) for (let e = t.length - 1; e >= 0; e--)a[0].modifiers.unshift(t[e]); return { type: "COMPILATION_UNIT", package: n, imports: r, types: a } } packageDeclaration(e) { return { type: "PACKAGE_DECLARATION", modifiers: [], name: this.visit(e.qualifiedName) } } importDeclaration(e) { const t = !!e.Static, n = this.visit(e.qualifiedName); return !!e.Star && n.name.push({ type: "IDENTIFIER", value: "*" }), { type: "IMPORT_DECLARATION", static: t, name: n } } typeDeclaration(e) { const t = []; let n; return e.classOrInterfaceModifier && e.classOrInterfaceModifier.map((e => t.push(this.visit(e)))), e.classDeclaration ? n = this.visit(e.classDeclaration) : e.enumDeclaration ? n = this.visit(e.enumDeclaration) : e.interfaceDeclaration ? n = this.visit(e.interfaceDeclaration) : e.annotationTypeDeclaration && (n = this.visit(e.annotationTypeDeclaration)), { type: "TYPE_DECLARATION", modifiers: t, declaration: n } } modifier(e) { if (e.classOrInterfaceModifier) return this.visit(e.classOrInterfaceModifier); let t = ""; return e.Native ? t = "native" : e.Synchronized ? t = "synchronized" : e.Transient ? t = "transient" : e.Volatile && (t = "volatile"), { type: "MODIFIER", value: t } } classOrInterfaceModifier(e) { if (e.annotation) return this.visit(e.annotation); let t = ""; return e.Public ? t = "public" : e.Protected ? t = "protected" : e.Private ? t = "private" : e.Static ? t = "static" : e.Abstract ? t = "abstract" : e.Final ? t = "final" : e.Strictfp && (t = "strictfp"), { type: "MODIFIER", value: t } } variableModifier(e) { if (e.annotation) return this.visit(e.annotation); let t = ""; return e.Final && (t = "final"), { type: "MODIFIER", value: t } } annotation(e) { const t = this.visit(e.qualifiedName), n = !!e.LBrace; let r; if (n) { if (e.expression) { r = []; let t = this.visit(e.expression); "OPERATOR_EXPRESSION" === t.type && (t = { type: "ELEMENT_VALUE_PAIR", key: t.left, value: t.right }), r.push(t) } else if (e.elementValueArrayInitializer) { r = []; const t = this.visit(e.elementValueArrayInitializer); r.push(t) } e.elementValuePair && e.elementValuePair.map((e => r.push(this.visit(e)))) } return { type: "ANNOTATION", name: t, hasBraces: n, values: r } } elementValuePairs(e) { const t = []; return e.elementValuePair && e.elementValuePair.map((e => t.push(this.visit(e)))), { type: "ELEMENT_VALUE_PAIRS", pairs: t } } elementValuePair(e) { return { type: "ELEMENT_VALUE_PAIR", key: this.identifier(e.Identifier[0]), value: this.visit(e.elementValue) } } elementValue(e) { return e.expression ? this.visit(e.expression) : e.elementValueArrayInitializer ? this.visit(e.elementValueArrayInitializer) : void 0 } elementValueArrayInitializer(e) { const t = []; return e.elementValue && e.elementValue.map((e => t.push(this.visit(e)))), { type: "ELEMENT_VALUE_ARRAY_INITIALIZER", values: t } } classDeclaration(e) { const t = this.identifier(e.Identifier[0]), n = this.visit(e.classBody); return { type: "CLASS_DECLARATION", name: t, typeParameters: this.visit(e.typeParameters), extends: this.visit(e.typeType), implements: this.visit(e.typeList), body: n } } typeParameters(e) { const t = []; return e.typeParameter && e.typeParameter.map((e => t.push(this.visit(e)))), { type: "TYPE_PARAMETERS", list: t } } typeParameter(e) { const t = []; e.annotation && e.annotation.map((e => t.push(this.visit(e)))); const n = this.identifier(e.Identifier[0]), r = this.visit(e.typeBound); return { type: "TYPE_PARAMETER", modifiers: t, name: n, typeBound: r } } typeBound(e) { const t = []; return e.typeType && e.typeType.map((e => t.push(this.visit(e)))), { type: "TYPE_BOUND", list: t } } classBody(e) { const t = []; return e.classBodyDeclaration && e.classBodyDeclaration.map((e => t.push(this.visit(e)))), { type: "CLASS_BODY", declarations: t } } classBodyDeclaration(e) { if (e.commentStandalone) return this.visit(e.commentStandalone); if (e.block) return { type: "CLASS_BODY_BLOCK", static: !!e.Static, block: this.visit(e.block) }; if (e.memberDeclaration) { const t = []; e.modifier && e.modifier.map((e => t.push(this.visit(e)))), e.Static && t.unshift({ type: "MODIFIER", value: "static" }); const n = this.visit(e.memberDeclaration), r = n.followedEmptyLine || !1; return { type: "CLASS_BODY_MEMBER_DECLARATION", modifiers: t, declaration: n, followedEmptyLine: r } } return e.semiColon ? { type: "SEMI_COLON_STATEMENT" } : void 0 } LineCommentStandalone(e) { return { type: "COMMENT_STANDALONE", value: e.image.replace(/[\n\r]*/g, "") } } JavaDocTraditionalCommentStandalone(e) { return { type: "COMMENT_STANDALONE", value: e.image.replace(/\*\/[\n\r]*/g, "*/") } } memberDeclaration(e) { return e.interfaceDeclaration ? this.visit(e.interfaceDeclaration) : e.annotationTypeDeclaration ? this.visit(e.annotationTypeDeclaration) : e.classDeclaration ? this.visit(e.classDeclaration) : e.enumDeclaration ? this.visit(e.enumDeclaration) : e.genericMethodDeclarationOrGenericConstructorDeclaration ? this.visit(e.genericMethodDeclarationOrGenericConstructorDeclaration) : e.fieldDeclarationOrMethodDeclarationOrConstructorDeclaration ? this.visit(e.fieldDeclarationOrMethodDeclarationOrConstructorDeclaration) : void 0 } fieldDeclarationOrMethodDeclarationOrConstructorDeclaration(e) { if (e.Identifier) { if (e.Identifier[0].isConstructorDeclaration) return { type: "CONSTRUCTOR_DECLARATION", name: this.identifier(e.Identifier[0]), parameters: this.visit(e.formalParameters), throws: this.visit(e.qualifiedNameList), body: this.visit(e.methodBody) }; let t; if (e.Void) t = { type: "VOID" }; else { const n = []; e.annotation && e.annotation.map((e => n.push(this.visit(e)))); const r = []; let a; if (e.LSquare && e.LSquare.map((e => { e.isTypeType && r.push({ type: "DIMENSION" }) })), e.primitiveType) a = this.visit(e.primitiveType), t = 0 === n.length && 0 === r.length ? a : { type: "TYPE_TYPE", modifiers: n, value: a, dimensions: r }; else if (e.Identifier) { const a = this.identifier(e.Identifier[0]), i = this.visit(e.typeArguments); t = i || e.classOrInterfaceTypeElement ? { type: "CLASS_OR_INTERFACE_TYPE_ELEMENT", name: a, typeArguments: i } : a; const u = [t]; e.classOrInterfaceTypeElement && e.classOrInterfaceTypeElement.map((e => u.push(this.visit(e)))), t = 1 === u.length ? u[0] : { type: "CLASS_OR_INTERFACE_TYPE", elements: u }, 0 === n.length && 0 === r.length || (t = { type: "TYPE_TYPE", modifiers: n, value: t, dimensions: r }) } } if (e.primitiveType && e.primitiveType[0].isMethodDeclaration || e.Void && e.Void[0].isMethodDeclaration || e.Identifier && e.Identifier[0].isMethodDeclaration) { const n = this.identifier(e.Identifier[e.Identifier[0].isMethodDeclaration ? 1 : 0]), r = this.visit(e.formalParameters), a = []; e.LSquare && e.LSquare.map((e => { e.isTypeType || a.push({ type: "DIMENSION" }) })); const i = this.visit(e.qualifiedNameList), u = this.visit(e.methodBody); return { type: "METHOD_DECLARATION", typeType: t, name: n, parameters: r, dimensions: a, throws: i, body: u } } if (e.primitiveType && e.primitiveType[0].isFieldDeclaration || e.Identifier && e.Identifier[0].isFieldDeclaration) { const n = this.identifier(e.Identifier[e.primitiveType ? 0 : 1]), r = []; e.identifierDimension && e.identifierDimension.map((() => r.push({ type: "DIMENSION" }))); const a = [{ type: "VARIABLE_DECLARATOR", id: { type: "VARIABLE_DECLARATOR_ID", id: n, dimensions: r }, init: this.visit(e.variableInitializer) }]; return e.variableDeclarator && e.variableDeclarator.map((e => a.push(this.visit(e)))), { type: "FIELD_DECLARATION", typeType: t, variableDeclarators: { type: "VARIABLE_DECLARATORS", list: a }, followedEmptyLine: this.visit(e.semiColon).followedEmptyLine } } } } methodDeclaration(e) { const t = this.visit(e.typeTypeOrVoid), n = this.identifier(e.Identifier[0]), r = this.visit(e.formalParameters), a = []; e.LSquare && e.LSquare.map((() => a.push({ type: "DIMENSION" }))); const i = this.visit(e.qualifiedNameList), u = this.visit(e.methodBody); return { type: "METHOD_DECLARATION", typeType: t, name: n, parameters: r, dimensions: a, throws: i, body: u } } constructorDeclaration(e) { return { type: "CONSTRUCTOR_DECLARATION", name: this.identifier(e.Identifier[0]), parameters: this.visit(e.formalParameters), throws: this.visit(e.qualifiedNameList), body: this.visit(e.methodBody) } } genericMethodDeclarationOrGenericConstructorDeclaration(e) { const t = this.visit(e.typeParameters); return e.methodDeclaration ? { type: "GENERIC_METHOD_DECLARATION", typeParameters: t, methodDeclaration: this.visit(e.methodDeclaration) } : e.constructorDeclaration ? { type: "GENERIC_CONSTRUCTOR_DECLARATION", typeParameters: t, constructorDeclaration: this.visit(e.constructorDeclaration) } : void 0 } fieldDeclaration(e) { return { type: "FIELD_DECLARATION", typeType: this.visit(e.typeType), variableDeclarators: this.visit(e.variableDeclarators), followedEmptyLine: this.visit(e.semiColon).followedEmptyLine } } methodBody(e) { if (e.block) return this.visit(e.block); e.semiColon } enumDeclaration(e) { return { type: "ENUM_DECLARATION", name: this.identifier(e.Identifier[0]), implements: this.visit(e.typeList), enumConstants: this.visit(e.enumConstants), body: this.visit(e.enumBodyDeclarations) } } enumConstants(e) { const t = []; return e.enumConstant && e.enumConstant.map((e => t.push(this.visit(e)))), { type: "ENUM_CONSTANTS", list: t } } enumConstant(e) { const t = []; e.annotation && e.annotation.map((e => t.push(this.visit(e)))); const n = this.identifier(e.Identifier[0]), r = this.visit(e.arguments), a = this.visit(e.classBody); return { type: "ENUM_CONSTANT", modifiers: t, name: n, arguments: r, body: a } } enumBodyDeclarations(e) { const t = []; return e.classBodyDeclaration && e.classBodyDeclaration.map((e => t.push(this.visit(e)))), { type: "ENUM_BODY_DECLARATIONS", declarations: t } } interfaceDeclaration(e) { return { type: "INTERFACE_DECLARATION", name: this.identifier(e.Identifier[0]), typeParameters: this.visit(e.typeParameters), extends: this.visit(e.typeList), body: this.visit(e.interfaceBody) } } interfaceBody(e) { const t = []; return e.interfaceBodyDeclaration && e.interfaceBodyDeclaration.map((e => t.push(this.visit(e)))), { type: "INTERFACE_BODY", declarations: t } } interfaceBodyDeclaration(e) { if (e.commentStandalone) return this.visit(e.commentStandalone); const t = []; e.modifier && e.modifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.interfaceMemberDeclaration), r = n.followedEmptyLine || !1; return { type: "INTERFACE_BODY_DECLARATION", modifiers: t, declaration: n, followedEmptyLine: r } } interfaceMemberDeclaration(e) { return e.constantDeclarationOrInterfaceMethodDeclaration ? this.visit(e.constantDeclarationOrInterfaceMethodDeclaration) : e.interfaceDeclaration ? this.visit(e.interfaceDeclaration) : e.classDeclaration ? this.visit(e.classDeclaration) : e.enumDeclaration ? this.visit(e.enumDeclaration) : void 0 } constantDeclarationOrInterfaceMethodDeclaration(e) { if (e.semiColon) { const t = this.visit(e.typeType), n = []; e.constantDeclarator && e.constantDeclarator.map((e => n.push(this.visit(e)))); const r = this.visit(e.semiColon).followedEmptyLine; return { type: "CONSTANT_DECLARATION", typeType: t, declarators: n, followedEmptyLine: r } } if (e.methodBody) { const t = []; e.interfaceMethodModifier && e.interfaceMethodModifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.typeParameters); let r; e.typeType ? r = this.visit(e.typeType) : e.Void && (r = { type: "VOID" }); const a = this.identifier(e.Identifier[0]), i = this.visit(e.formalParameters), u = []; e.LSquare && e.LSquare.map((() => u.push({ type: "DIMENSION" }))); const d = this.visit(e.qualifiedNameList), o = this.visit(e.methodBody); return { type: "INTERFACE_METHOD_DECLARATION", modifiers: t, typeParameters: n, typeType: r, name: a, parameters: i, dimensions: u, throws: d, body: o } } } constantDeclaration(e) { const t = this.visit(e.typeType), n = []; e.constantDeclarator && e.constantDeclarator.map((e => n.push(this.visit(e)))); const r = this.visit(e.semiColon).followedEmptyLine; return { type: "CONSTANT_DECLARATION", typeType: t, declarators: n, followedEmptyLine: r } } constantDeclarator(e) { const t = this.identifier(e.Identifier[0]), n = []; e.LSquare && e.LSquare.map((() => n.push({ type: "DIMENSION" }))); const r = this.visit(e.variableInitializer); return { type: "CONSTANT_DECLARATOR", name: t, dimensions: n, init: r } } interfaceMethodDeclaration(e) { const t = []; e.interfaceMethodModifier && e.interfaceMethodModifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.typeParameters), r = this.visit(e.typeTypeOrVoid), a = this.identifier(e.Identifier[0]), i = this.visit(e.formalParameters), u = []; e.LSquare && e.LSquare.map((() => u.push({ type: "DIMENSION" }))); const d = this.visit(e.qualifiedNameList), o = this.visit(e.methodBody); return { type: "INTERFACE_METHOD_DECLARATION", modifiers: t, typeParameters: n, typeType: r, name: a, parameters: i, dimensions: u, throws: d, body: o } } interfaceMethodModifier(e) { if (e.annotation) return this.visit(e.annotation); let t = ""; return e.Public ? t = "public" : e.Abstract ? t = "abstract" : e.Default ? t = "default" : e.Static ? t = "static" : e.Strictfp && (t = "strictfp"), { type: "MODIFIER", value: t } } variableDeclarators(e) { const t = []; return e.variableDeclarator && e.variableDeclarator.map((e => t.push(this.visit(e)))), { type: "VARIABLE_DECLARATORS", list: t } } variableDeclarator(e) { return { type: "VARIABLE_DECLARATOR", id: this.visit(e.variableDeclaratorId), init: this.visit(e.variableInitializer) } } variableDeclaratorId(e) { const t = this.identifier(e.Identifier[0]), n = []; return e.LSquare && e.LSquare.map((() => n.push({ type: "DIMENSION" }))), { type: "VARIABLE_DECLARATOR_ID", id: t, dimensions: n } } variableInitializer(e) { return e.Questionmark ? { type: "IF_ELSE_EXPRESSION", condition: this.visit(e.expression[0]), if: this.visit(e.expression[1]), else: this.visit(e.expression[2]) } : e.expression ? this.visit(e.expression) : e.arrayInitializer ? this.visit(e.arrayInitializer) : void 0 } arrayInitializer(e) { const t = []; return e.variableInitializer && e.variableInitializer.map((e => t.push(this.visit(e)))), { type: "ARRAY_INITIALIZER", variableInitializers: t } } annotationTypeDeclaration(e) { return { type: "ANNOTATION_TYPE_DECLARATION", name: this.identifier(e.Identifier[0]), body: this.visit(e.annotationTypeBody) } } annotationTypeBody(e) { const t = []; return e.annotationTypeElementDeclaration && e.annotationTypeElementDeclaration.map((e => t.push(this.visit(e)))), { type: "ANNOTATION_TYPE_BODY", declarations: t } } annotationTypeElementDeclaration(e) { const t = []; e.modifier && e.modifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.annotationTypeElementRest); return { type: "ANNOTATION_TYPE_ELEMENT_DECLARATION", modifiers: t, declaration: n } } annotationTypeElementRest(e) { return e.classDeclaration ? this.visit(e.classDeclaration) : e.enumDeclaration ? this.visit(e.enumDeclaration) : e.interfaceDeclaration ? this.visit(e.interfaceDeclaration) : e.annotationTypeDeclaration ? this.visit(e.annotationTypeDeclaration) : { type: "ANNOTATION_TYPE_ELEMENT_REST", typeType: this.visit(e.typeType), name: this.visit(e.annotationMethodRestOrConstantRest) } } annotationMethodRestOrConstantRest(e) { return e.annotationMethodRest ? this.visit(e.annotationMethodRest) : e.annotationConstantRest ? this.visit(e.annotationConstantRest) : void 0 } annotationMethodRest(e) { return { type: "ANNOTATION_METHOD_REST", name: this.identifier(e.Identifier[0]), defaultValue: this.visit(e.defaultValue) } } annotationConstantRest(e) { if (e.variableDeclarators) return this.visit(e.variableDeclarators) } defaultValue(e) { return { type: "DEFAULT_VALUE", value: this.visit(e.elementValue) } } typeList(e) { const t = []; return e.typeType && e.typeType.map((e => t.push(this.visit(e)))), { type: "TYPE_LIST", list: t } } typeType(e) { const t = []; e.annotation && e.annotation.map((e => t.push(this.visit(e)))); const n = []; let r; if (e.LSquare && e.LSquare.map((() => n.push({ type: "DIMENSION" }))), e.primitiveType) { if (r = this.visit(e.primitiveType), 0 === t.length && 0 === n.length) return r } else if (e.classOrInterfaceType && (r = this.visit(e.classOrInterfaceType), 0 === t.length && 0 === n.length)) return r; return r ? { type: "TYPE_TYPE", modifiers: t, value: r, dimensions: n } : t[0] } typeTypeOrVoid(e) { return e.typeType ? this.visit(e.typeType) : e.Void ? { type: "VOID" } : void 0 } classOrInterfaceType(e) { const t = []; return e.classOrInterfaceTypeElement && e.classOrInterfaceTypeElement.map((e => t.push(this.visit(e)))), 1 === t.length ? t[0] : { type: "CLASS_OR_INTERFACE_TYPE", elements: t } } classOrInterfaceTypeElement(e) { const t = this.identifier(e.Identifier[0]), n = this.visit(e.typeArguments); return n ? { type: "CLASS_OR_INTERFACE_TYPE_ELEMENT", name: t, typeArguments: n } : t } typeArguments(e) { const t = []; return e.typeArgument && e.typeArgument.map((e => t.push(this.visit(e)))), { type: "TYPE_ARGUMENTS", value: { type: "TYPE_LIST", list: t } } } typeArgumentsOrOperatorExpressionRest(e) { if (e.This) return { type: "OPERATOR_EXPRESSION_REST", operator: { type: "OPERATOR", operator: "<" }, expression: { type: "THIS" } }; if (e.Super) return { type: "OPERATOR_EXPRESSION_REST", operator: { type: "OPERATOR", operator: "<" }, expression: { type: "SUPER" } }; if (e.typeArgument) { let t = this.visit(e.typeArgument); if (e.Less) { const n = []; if (e.typeArgument && e.typeArgument.map((e => n.push(this.visit(e)))), !e.Greater) { let t = n[0]; if (e.LBrace) { let n; e.expressionList && (n = this.visit(e.expressionList)); const r = []; if (e.dimension && e.dimension.map((e => r.push(this.visit(e)))), "IDENTIFIER" === t.argument.type) t = { type: "METHOD_INVOCATION", name: t.argument, parameters: n, dimensions: r }; else if ("CLASS_OR_INTERFACE_TYPE" === t.argument.type) { let e, a; for (let i = 0; i < t.argument.elements.length; i++)if (i !== t.argument.elements.length - 1) { const n = { type: "QUALIFIED_EXPRESSION", expression: t.argument.elements[i], rest: void 0 }; 0 === i ? (e = n, a = n) : (a.rest = n, a = n) } else a.rest = { type: "METHOD_INVOCATION", name: t.argument.elements[i], parameters: n, dimensions: r }; t = e } } return { type: "OPERATOR_EXPRESSION_REST", operator: { type: "OPERATOR", operator: "<" }, expression: t } } t = { type: "TYPE_LIST", list: n } } return { type: "TYPE_ARGUMENTS", value: t } } return e.literal ? { type: "OPERATOR_EXPRESSION_REST", operator: { type: "OPERATOR", operator: "<" }, expression: this.visit(e.literal) } : e.expression ? { type: "OPERATOR_EXPRESSION_REST", operator: { type: "OPERATOR", operator: "<" }, expression: { type: "PAR_EXPRESSION", expression: this.visit(e.expression) } } : void 0 } typeArgument(e) { const t = !!e.Questionmark; let n, r, a; return n = t ? { type: "QUESTIONMARK" } : this.visit(e.typeType[0]), e.Super ? r = t ? this.visit(e.typeType[0]) : this.visit(e.typeType[1]) : e.Extends && (a = t ? this.visit(e.typeType[0]) : this.visit(e.typeType[1])), { type: "TYPE_ARGUMENT", argument: n, super: r, extends: a } } qualifiedNameList(e) { const t = []; return e.qualifiedName && e.qualifiedName.map((e => t.push(this.visit(e)))), { type: "QUALIFIED_NAME_LIST", list: t } } identifiers(e) { return { type: "IDENTIFIERS", identifiers: this.visit(e.identifierList) } } identifierList(e) { const t = []; return e.Identifier && e.Identifier.map((e => t.push(e.image))), { type: "IDENTIFIER_LIST", list: t } } formalParameters(e) { return { type: "FORMAL_PARAMETERS", parameters: this.visit(e.formalParameterList) || [] } } formalParameterList(e) { const t = []; e.formalParameter && e.formalParameter.map((e => t.push(this.visit(e)))); for (let e = 0; e < t.length; e++)if (t[e].dotDotDot && e + 1 < t.length) throw new a('Only last parameter is allowed with "..."', void 0); return t } formalParameter(e) { const t = []; e.variableModifier && e.variableModifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.typeType), r = this.visit(e.variableDeclaratorId), a = !!e.DotDotDot; return { type: "FORMAL_PARAMETER", modifiers: t, typeType: n, id: r, dotDotDot: a } } block(e) { const t = []; return e.blockStatement && e.blockStatement.map((e => t.push(this.visit(e)))), { type: "BLOCK", statements: t } } blockStatement(e) { if (e.commentStandalone) return this.visit(e.commentStandalone); if (e.expression) { let t = this.visit(e.expression); if ("PRIMITIVE_TYPE" === t.type) { if (e.Colon) throw new a("Primitive type with colon found", void 0); if (e.typeArguments || e.Dot) throw new a("Primitive type with type arguments or dot found", void 0) } if ("IDENTIFIER" !== t.type) { if (e.Colon) throw new a("Only identifier is allowed with colon", void 0); if (e.typeArguments || e.Dot) throw new a("Only identifier is allowed with type arguments or dot", void 0) } if ("IDENTIFIER" === t.type && e.Colon) { if (e.classOrInterfaceModifier) throw new a("Identifier statement is not allowed to have annotations or modifiers.", void 0); if (e.LSquare || e.variableDeclarators) throw new a("Identifier statement is not allowed to have squares or variable declarators", void 0); return { type: "IDENTIFIER_STATEMENT", identifier: t, statement: this.visit(e.statement) } } const n = this.visit(e.semiColon).followedEmptyLine; if ("IDENTIFIER" === t.type || "PRIMITIVE_TYPE" === t.type) { const r = []; e.classOrInterfaceModifier && e.classOrInterfaceModifier.map((e => { const t = this.visit(e); if ("MODIFIER" === t.type && ("public" === t.value || "protected" === t.value || "private" === t.value || "static" === t.value || "abstract" === t.value || "strictfp" === t.value)) throw new a("Locale variable declaration can't have a public, protected, private, static, abstract or strictfp modifier.", void 0); r.push(t) })); const i = this.visit(e.variableDeclarators); return { type: "EXPRESSION_STATEMENT", expression: { type: "LOCAL_VARIABLE_DECLARATION", modifiers: r, typeType: t, declarators: i }, followedEmptyLine: n } } if ("IDENTIFIER" === t.type || e.semiColon) { if (e.variableDeclarators) { const n = this.visit(e.variableDeclarators); if (e.classOrInterfaceModifier || e.LSquare) { const n = []; e.classOrInterfaceModifier && e.classOrInterfaceModifier.map((e => n.push(this.visit(e)))); const r = []; e.LSquare && e.LSquare.map((() => r.push({ type: "DIMENSION" }))), t = { type: "TYPE_TYPE", modifiers: n, value: t, dimensions: r } } return { type: "FIELD_DECLARATION", typeType: t, variableDeclarators: n, followedEmptyLine: this.visit(e.semiColon).followedEmptyLine } } return { type: "EXPRESSION_STATEMENT", expression: t, followedEmptyLine: n } } } if (e.classDeclaration || e.interfaceDeclaration) { const t = []; let n; return e.classOrInterfaceModifier && e.classOrInterfaceModifier.map((e => t.push(this.visit(e)))), e.classDeclaration && (n = this.visit(e.classDeclaration)), e.interfaceDeclaration && (n = this.visit(e.interfaceDeclaration)), { type: "LOCAL_TYPE_DECLARATION", modifiers: t, declaration: n } } return e.statementWithStartingToken ? this.visit(e.statementWithStartingToken) : void 0 } statement(e) { return e.statementWithStartingToken ? this.visit(e.statementWithStartingToken) : e.identifierStatement ? this.visit(e.identifierStatement) : e.expressionStatement ? this.visit(e.expressionStatement) : void 0 } statementWithStartingToken(e) { return e.block ? this.visit(e.block) : e.assertStatement ? this.visit(e.assertStatement) : e.ifStatement ? this.visit(e.ifStatement) : e.whileStatement ? this.visit(e.whileStatement) : e.forStatement ? this.visit(e.forStatement) : e.doWhileStatement ? this.visit(e.doWhileStatement) : e.tryStatement ? this.visit(e.tryStatement) : e.switchStatement ? this.visit(e.switchStatement) : e.synchronizedStatement ? this.visit(e.synchronizedStatement) : e.returnStatement ? this.visit(e.returnStatement) : e.throwStatement ? this.visit(e.throwStatement) : e.breakStatement ? this.visit(e.breakStatement) : e.continueStatement ? this.visit(e.continueStatement) : e.semiColonStatement ? this.visit(e.semiColonStatement) : void 0 } assertStatement(e) { const t = this.visit(e.expression[0]); let n; return e.expression.length > 1 && (n = this.visit(e.expression[1])), { type: "ASSERT_STATEMENT", booleanExpression: t, valueExpression: n } } ifStatement(e) { const t = this.visit(e.expression), n = this.visit(e.statement[0]); let r; return e.statement.length > 1 && (r = this.visit(e.statement[1])), { type: "IF_STATEMENT", condition: t, body: n, else: r } } whileStatement(e) { return { type: "WHILE_STATEMENT", condition: this.visit(e.expression), body: this.visit(e.statement) } } doWhileStatement(e) { return { type: "DO_WHILE_STATEMENT", body: this.visit(e.statement), condition: this.visit(e.expression) } } tryStatement(e) { const t = this.visit(e.resourceSpecification), n = this.visit(e.block), r = []; e.catchClause && e.catchClause.map((e => r.push(this.visit(e)))); const a = this.visit(e.finallyBlock); return { type: "TRY_STATEMENT", resourceSpecification: t, body: n, catchClauses: r, finally: a } } switchStatement(e) { const t = this.visit(e.expression), n = []; return e.switchBlockStatementGroup && e.switchBlockStatementGroup.map((e => n.push(this.visit(e)))), { type: "SWITCH_STATEMENT", condition: t, statementGroups: n } } synchronizedStatement(e) { return { type: "SYNCHRONIZED_STATEMENT", condition: this.visit(e.expression), body: this.visit(e.block) } } returnStatement(e) { return { type: "RETURN_STATEMENT", expression: this.visit(e.expression) } } throwStatement(e) { return { type: "THROW_STATEMENT", expression: this.visit(e.expression) } } breakStatement(e) { let t; return e.Identifier && (t = this.identifier(e.Identifier[0])), { type: "BREAK_STATEMENT", identifier: t } } continueStatement(e) { let t; return e.Identifier && (t = this.identifier(e.Identifier[0])), { type: "CONTINUE_STATEMENT", identifier: t } } semiColonStatement() { return { type: "SEMI_COLON_STATEMENT" } } expressionStatement(e) { return { type: "EXPRESSION_STATEMENT", expression: this.visit(e.expression), followedEmptyLine: this.visit(e.semiColon).followedEmptyLine } } identifierStatement(e) { return { type: "IDENTIFIER_STATEMENT", identifier: this.identifier(e.Identifier[0]), statement: this.visit(e.statement) } } catchClause(e) { const t = []; e.variableModifier && e.variableModifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.catchType), r = this.identifier(e.Identifier[0]), a = this.visit(e.block); return { type: "CATCH_CLAUSE", modifiers: t, catchType: n, id: r, block: a } } catchType(e) { const t = []; return e.qualifiedName && e.qualifiedName.map((e => t.push(this.visit(e)))), { type: "CATCH_TYPE", list: t } } finallyBlock(e) { return { type: "FINALLY_BLOCK", block: this.visit(e.block) } } resourceSpecification(e) { return { type: "RESOURCE_SPECIFICATION", resources: this.visit(e.resources) } } resources(e) { const t = []; return e.resource && e.resource.map((e => t.push(this.visit(e)))), { type: "RESOURCES", resources: t } } resource(e) { const t = []; e.variableModifier && e.variableModifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.classOrInterfaceType), r = this.visit(e.variableDeclaratorId), a = this.visit(e.expression); return { type: "RESOURCE", modifiers: t, typeType: n, id: r, expression: a } } switchBlockStatementGroup(e) { const t = []; e.switchLabel && e.switchLabel.map((e => t.push(this.visit(e)))); const n = []; return e.blockStatement && e.blockStatement.map((e => n.push(this.visit(e)))), { type: "SWITCH_BLOCK_STATEMENT_GROUP", labels: t, statements: n } } switchLabel(e) { return e.switchLabelCase ? this.visit(e.switchLabelCase) : e.switchLabelDefault ? this.visit(e.switchLabelDefault) : void 0 } switchLabelCase(e) { return { type: "SWITCH_LABEL_CASE", expression: this.visit(e.expression) } } switchLabelDefault() { return { type: "SWITCH_LABEL_DEFAULT" } } forStatement(e) { return { type: "FOR_STATEMENT", forControl: this.visit(e.forControl), body: this.visit(e.statement) } } forControl(e) { if (e.Colon) { const t = { type: "ENHANCED_FOR_CONTROL", declaration: void 0, expression: void 0 }, n = []; e.variableModifier && e.variableModifier.map((e => n.push(this.visit(e)))); const r = this.visit(e.expression[0]), a = { type: "VARIABLE_DECLARATORS", list: [{ type: "VARIABLE_DECLARATOR", id: this.visit(e.variableDeclaratorId), init: this.visit(e.variableInitializer) }] }; return e.variableDeclarator && e.variableDeclarator.map((e => a.list.push(this.visit(e)))), t.declaration = { type: "LOCAL_VARIABLE_DECLARATION", modifiers: n, typeType: r, declarators: a }, t.expression = this.visit(e.expression[1]), t } if (e.semiColon && 2 == e.semiColon.length) { const t = { type: "BASIC_FOR_CONTROL", forInit: void 0, expression: void 0, expressionList: void 0 }; if (e.expression && e.expression[e.expression.length - 1].optionalExpression && (t.expression = this.visit(e.expression[e.expression.length - 1])), t.expressionList = this.visit(e.expressionList), e.variableDeclaratorId) { const n = []; e.variableModifier && e.variableModifier.map((e => n.push(this.visit(e)))); const r = this.visit(e.expression), a = { type: "VARIABLE_DECLARATORS", list: [{ type: "VARIABLE_DECLARATOR", id: this.visit(e.variableDeclaratorId), init: this.visit(e.variableInitializer) }] }; return e.variableDeclarator && e.variableDeclarator.map((e => a.list.push(this.visit(e)))), t.forInit = { type: "LOCAL_VARIABLE_DECLARATION", modifiers: n, typeType: r, declarators: a }, t } if (e.expression) { const n = []; for (let t = 0; t < e.expression.length; t++)e.expression[t].optionalExpression || n.push(this.visit(e.expression[t])); n.length > 0 && (t.forInit = { type: "EXPRESSION_LIST", list: n }) } return t } } enhancedForControl(e) { const t = []; e.variableModifier && e.variableModifier.map((e => t.push(this.visit(e)))); const n = this.visit(e.typeType), r = this.visit(e.variableDeclaratorId), a = this.visit(e.expression); return { type: "ENHANCED_FOR_CONTROL", modifiers: t, typeType: n, id: r, iterator: a } } explicitGenericInvocationSuffix(e) { return e.super ? this.visit(e.super) : e.identifierArguments ? this.visit(e.identifierArguments) : void 0 } identifierArguments(e) { return { type: "IDENTIFIER_ARGUMENTS", name: this.identifier(e.Identifier[0]), arguments: this.visit(e.arguments) } } super(e) { return { type: "SUPER", arguments: this.visit(e.superSuffix) } } superSuffix(e) { return e.arguments ? this.visit(e.arguments) : e.dotIdentifierArguments ? this.visit(e.dotIdentifierArguments) : void 0 } arguments(e) { return e.expressionList ? this.visit(e.expressionList) : { type: "EXPRESSION_LIST", list: [] } } dotIdentifierArguments(e) { return { type: "DOT_IDENTIFIER_ARGUMENTS", name: this.identifier(e.Identifier[0]), arguments: this.visit(e.arguments) } } parExpression(e) { return { type: "PAR_EXPRESSION", expression: this.visit(e.expression) } } expressionList(e) { const t = []; return e.expression && e.expression.map((e => t.push(this.visit(e)))), { type: "EXPRESSION_LIST", list: t } } methodInvocation(e) { const t = this.identifier(e.Identifier[0]), n = this.visit(e.expressionList), r = []; return e.dimension && e.dimension.map((e => r.push(this.visit(e)))), { type: "METHOD_INVOCATION", name: t, parameters: n, dimensions: r } } expression(e) { if (e.atomic) { const t = this.visit(e.atomic); if (e.squareExpressionRest) return { type: "SQUARE_EXPRESSION", expression: t, squareExpression: this.visit(e.squareExpressionRest).expression }; if (e.ifElseExpressionRest && !e.operatorExpressionRest && !e.qualifiedExpressionRest) { const n = this.visit(e.ifElseExpressionRest); return { type: "IF_ELSE_EXPRESSION", condition: t, if: n.if, else: n.else } } if (e.qualifiedExpressionRest) { let n = { type: "QUALIFIED_EXPRESSION", expression: t, rest: this.visit(e.qualifiedExpressionRest) }; if (e.instanceofExpressionRest) { const t = this.visit(e.instanceofExpressionRest); n = { type: "INSTANCEOF_EXPRESSION", expression: n, instanceof: t.typeType }, t.operatorExpressionRest && (n = { type: "OPERATOR_EXPRESSION", left: n, operator: t.operatorExpressionRest.operator, right: t.operatorExpressionRest.expression }) } if (e.postfixExpressionRest && (n = { type: "POSTFIX_EXPRESSION", postfix: this.visit(e.postfixExpressionRest).value, expression: n }), e.operatorExpressionRest) { const t = this.visit(e.operatorExpressionRest); n = { type: "OPERATOR_EXPRESSION", left: n, operator: t.operator, right: t.expression } } if (e.ifElseExpressionRest) { const t = this.visit(e.ifElseExpressionRest); return { type: "IF_ELSE_EXPRESSION", condition: n, if: t.if, else: t.else } } return n } if (e.postfixExpressionRest) return { type: "POSTFIX_EXPRESSION", postfix: this.visit(e.postfixExpressionRest).value, expression: t }; if (e.instanceofExpressionRest) { const n = this.visit(e.instanceofExpressionRest), r = { type: "INSTANCEOF_EXPRESSION", expression: t, instanceof: n.typeType }; return n.operatorExpressionRest ? { type: "OPERATOR_EXPRESSION", left: r, operator: n.operatorExpressionRest.operator, right: n.operatorExpressionRest.expression } : r } if (e.operatorExpressionRest) { const n = this.visit(e.operatorExpressionRest), r = { type: "OPERATOR_EXPRESSION", left: t, operator: n.operator, right: n.expression }; if (e.ifElseExpressionRest) { const t = this.visit(e.ifElseExpressionRest); return { type: "IF_ELSE_EXPRESSION", condition: r, if: t.if, else: t.else } } return r } if (e.Pointer) { if ("IDENTIFIER" !== t.type) throw new a("Found lambda expression but left side is not an identifier", void 0); return { type: "LAMBDA_EXPRESSION", parameters: { type: "IDENTIFIERS", identifiers: { type: "IDENTIFIER_LIST", list: [t] } }, body: this.visit(e.lambdaBody) } } if (e.methodReferenceRest) { const n = this.visit(e.methodReferenceRest); return { type: "METHOD_REFERENCE", reference: t, typeArguments: n.typeArguments, name: n.name } } return t } return e.prefixExpression ? this.visit(e.prefixExpression) : e.parExpressionOrCastExpressionOrLambdaExpression ? this.visit(e.parExpressionOrCastExpressionOrLambdaExpression) : void 0 } atomic(e) { return e.methodInvocation ? this.visit(e.methodInvocation) : e.primary ? this.visit(e.primary) : e.creator ? this.visit(e.creator) : void 0 } instanceofExpressionRest(e) { const t = this.visit(e.typeType); let n; return e.operatorExpressionRest && (n = this.visit(e.operatorExpressionRest)), { type: "INSTANCEOF_EXPRESSION_REST", typeType: t, operatorExpressionRest: n } } squareExpressionRest(e) { return { type: "SQUARE_EXPRESSION_REST", expression: this.visit(e.expression) } } postfixExpressionRest(e) { let t; return e.PlusPlus && (t = "++"), e.MinusMinus && (t = "--"), { type: "POSTFIX_EXPRESSION_REST", value: t } } ifElseExpressionRest(e) { return { type: "IF_ELSE_EXPRESSION_REST", if: this.visit(e.expression[0]), else: this.visit(e.expression[1]) } } operator(e) { let t; return e.Star && (t = "*"), e.Dash && (t = "/"), e.Percentage && (t = "%"), e.Plus && (t = "+"), e.Minus && (t = "-"), e.LessLess && (t = "<<"), e.Greater && (2 === e.Greater.length && (t = ">>"), 3 === e.Greater.length && (t = ">>>")), e.LessEquals && (t = "<="), e.GreaterEquals && (t = ">="), e.Greater && 1 === e.Greater.length && (t = ">"), e.Less && (t = "<"), e.EqualsEquals && (t = "=="), e.ExclamationmarkEquals && (t = "!="), e.And && (t = "&"), e.Caret && (t = "^"), e.Or && (t = "|"), e.AndAnd && (t = "&&"), e.OrOr && (t = "||"), e.Equals && (t = "="), e.PlusEquals && (t = "+="), e.MinusEquals && (t = "-="), e.StarEquals && (t = "*="), e.DashEquals && (t = "/="), e.AndEquals && (t = "&="), e.OrEquals && (t = "|="), e.CaretEquals && (t = "^="), e.GreaterGreaterEquals && (t = ">>="), e.GreaterGreaterGreaterEquals && (t = ">>>="), e.LessLessEquals && (t = "<<="), e.PercentageEquals && (t = "%="), { type: "OPERATOR", operator: t } } operatorExpressionRest(e) { const t = this.visit(e.operator); let n; if (e.expression ? n = this.visit(e.expression) : e.elementValueArrayInitializer && (n = this.visit(e.elementValueArrayInitializer)), t) return { type: "OPERATOR_EXPRESSION_REST", operator: t, expression: n } } qualifiedExpressionRest(e) { let t; if (e.Identifier) { if (t = this.identifier(e.Identifier[0]), e.typeArgumentsOrOperatorExpressionRest) { const n = this.visit(e.typeArgumentsOrOperatorExpressionRest); t = "OPERATOR_EXPRESSION_REST" === n.type ? { type: "OPERATOR_EXPRESSION", left: t, operator: n.operator, right: n.expression } : { type: "CLASS_OR_INTERFACE_TYPE_ELEMENT", name: t, typeArguments: n } } if (e.dimension) { const n = []; e.dimension && e.dimension.map((e => n.push(this.visit(e)))), "IDENTIFIER" === t.type ? t = { type: "CLASS_OR_INTERFACE_TYPE_ELEMENT", name: t, dimensions: n } : "CLASS_OR_INTERFACE_TYPE_ELEMENT" === t.type && (t.dimensions = n) } } if (e.methodInvocation && (t = this.visit(e.methodInvocation)), e.This && (t = { type: "THIS" }), e.Super && (t = { type: "SUPER" }), e.Class && (t = { type: "CLASS" }), e.creatorOptionalNonWildcardInnerCreator && (t = this.visit(e.creatorOptionalNonWildcardInnerCreator)), e.explicitGenericInvocation && (t = this.visit(e.explicitGenericInvocation)), e.qualifiedExpressionRest) return { type: "QUALIFIED_EXPRESSION", expression: t, rest: this.visit(e.qualifiedExpressionRest) }; if (e.methodReferenceRest) { const n = this.visit(e.methodReferenceRest); return { type: "METHOD_REFERENCE", reference: t, typeArguments: n.typeArguments, name: n.name } } return t } parExpressionOrCastExpressionOrLambdaExpression(e) { if (e.Pointer) { const t = this.visit(e.lambdaBody); let n; if (n = e.variableDeclaratorId ? { type: "FORMAL_PARAMETERS", parameters: [] } : { type: "IDENTIFIERS", identifiers: void 0 }, e.expression) if (e.variableDeclaratorId) { n.parameters = []; for (let t = 0; t < e.expression.length; t++) { const r = this.visit(e.expression[t]), a = this.visit(e.variableDeclaratorId[t]), i = []; e.Final && void 0 !== e.Final.find((e => e.cnt === t)) && i.push({ type: "MODIFIER", value: "final" }), n.parameters.push({ type: "FORMAL_PARAMETER", modifiers: i, typeType: r, id: a, dotDotDot: !1 }) } } else n.identifiers = { type: "IDENTIFIER_LIST", list: [] }, n.identifiers.list = [], e.expression && e.expression.map((e => { const t = this.visit(e); if ("IDENTIFIER" !== t.type) throw new a("Found lambda expression but left side is not an identifier", void 0); n.identifiers.list.push(t) })); return { type: "LAMBDA_EXPRESSION", parameters: n, body: t } } if (e.Final) throw new a("Found cast expression or parenthis expression with final modifier", void 0); if (e.expression.length >= 2) { const t = this.visit(e.expression[0]), n = this.visit(e.expression[1]); if (e.operator) return { type: "OPERATOR_EXPRESSION", left: t, operator: this.visit(e.operator), right: n }; if ("IDENTIFIER" !== t.type && "CLASS_OR_INTERFACE_TYPE_ELEMENT" !== t.type && "TYPE_TYPE" !== t.type && "PRIMITIVE_TYPE" !== t.type && "QUALIFIED_EXPRESSION" !== t.type) throw new a("Found cast expression but cast expression is not an Identifier", void 0); return { type: "CAST_EXPRESSION", castType: t, expression: n } } if (1 !== e.expression.length) throw new a("Found parenthesis expression with annotations, typeArguments or Squares", void 0); const t = this.visit(e.expression), n = { type: "PAR_EXPRESSION", expression: t }; if (e.qualifiedExpressionRest) { const r = { type: "QUALIFIED_EXPRESSION", expression: n, rest: this.visit(e.qualifiedExpressionRest) }; if (e.operatorExpressionRest) { const t = this.visit(e.operatorExpressionRest), n = { type: "OPERATOR_EXPRESSION", left: r, operator: t.operator, right: t.expression }; let a; if (e.ifElseExpressionRest && (a = this.visit(e.ifElseExpressionRest)), n && a) return { type: "IF_ELSE_EXPRESSION", condition: n, if: a.if, else: a.else }; if (n) return n; if (a) return { type: "IF_ELSE_EXPRESSION", condition: r, if: a.if, else: a.else } } if (e.operator || e.ifElseExpressionRest) { let n, a; if (e.operator && (n = { type: "OPERATOR_EXPRESSION", left: r, operator: this.visit(e.operator), right: t }), e.ifElseExpressionRest && (a = this.visit(e.ifElseExpressionRest)), n && a) return { type: "IF_ELSE_EXPRESSION", condition: n, if: a.if, else: a.else }; if (n) return n; if (a) return { type: "IF_ELSE_EXPRESSION", condition: r, if: a.if, else: a.else } } return r } if (e.ifElseExpressionRest) { const t = this.visit(e.ifElseExpressionRest); return { type: "IF_ELSE_EXPRESSION", condition: n, if: t.if, else: t.else } } return n } creatorOptionalNonWildcardInnerCreator(e) { return { type: "CREATOR_OPTIONAL_NON_WILDCARD_INNER_CREATOR", typeArguments: this.visit(e.nonWildcardTypeArguments), innerCreator: this.visit(e.innerCreator) } } prefixExpression(e) { let t; return e.Plus && (t = "+"), e.Minus && (t = "-"), e.PlusPlus && (t = "++"), e.MinusMinus && (t = "--"), e.Tilde && (t = "~"), e.Exclamationmark && (t = "!"), { type: "PREFIX_EXPRESSION", prefix: t, expression: this.visit(e.expression) } } methodReferenceRest(e) { let t; return e.Identifier ? t = this.identifier(e.Identifier[0]) : e.New && (t = { type: "NEW" }), { type: "METHOD_REFERENCE_REST", typeArguments: this.visit(e.typeArguments), name: t } } lambdaExpression(e) { return { type: "LAMBDA_EXPRESSION", parameters: this.visit(e.lambdaParameters), body: this.visit(e.lambdaBody) } } lambdaParameters(e) { if (e.Identifier) return this.identifier(e.Identifier[0]); if (e.formalParameterList) { return { type: "FORMAL_PARAMETERS", parameters: this.visit(e.formalParameterList) || [] } } return e.identifierList ? { type: "IDENTIFIERS", identifiers: this.visit(e.identifierList) } : e.LBrace ? { type: "FORMAL_PARAMETERS", parameters: [] } : void 0 } lambdaBody(e) { return e.block ? this.visit(e.block) : e.expression ? this.visit(e.expression) : void 0 } classType(e) { const t = []; e.annotation && e.annotation.map((e => t.push(this.visit(e)))); const n = this.visit(e.classOrInterfaceType); return { type: "CLASS_TYPE", annotations: t, classOrInterfaceType: n } } creator(e) { return e.nonWildcardCreator ? this.visit(e.nonWildcardCreator) : e.simpleCreator ? this.visit(e.simpleCreator) : void 0 } nonWildcardCreator(e) { return { type: "NON_WILDCARD_CREATOR", typeArguments: this.visit(e.nonWildcardTypeArguments), name: this.visit(e.createdName), rest: this.visit(e.classCreatorRest) } } simpleCreator(e) { const t = this.visit(e.createdName); let n; return e.arrayCreatorRest && (n = this.visit(e.arrayCreatorRest)), e.classCreatorRest && (n = this.visit(e.classCreatorRest)), { type: "SIMPLE_CREATOR", name: t, rest: n } } createdName(e) { return e.identifierName ? this.visit(e.identifierName) : e.primitiveType ? this.visit(e.primitiveType) : void 0 } identifierName(e) { const t = []; return e.identifierNameElement && e.identifierNameElement.map((e => t.push(this.visit(e)))), { type: "IDENTIFIER_NAME", elements: t } } identifierNameElement(e) { return { type: "IDENTIFIER_NAME_ELEMENT", id: this.identifier(e.Identifier[0]), typeArguments: this.visit(e.nonWildcardTypeArgumentsOrDiamond) } } innerCreator(e) { return { type: "INNER_CREATOR", id: this.identifier(e.Identifier[0]), typeArguments: this.visit(e.nonWildcardTypeArgumentsOrDiamond), rest: this.visit(e.classCreatorRest) } } arrayCreatorRest(e) { const t = [], n = []; e.expression && e.expression.map((e => { const r = { type: "DIMENSION", expression: this.visit(e) }; n.push(r), t.push(r) })); for (let r = 0; r < e.LSquare.length - n.length; r++)t.push({ type: "DIMENSION" }); const r = this.visit(e.arrayInitializer); return { type: "ARRAY_CREATOR_REST", dimensions: t, arrayInitializer: r } } classCreatorRest(e) { return { type: "CLASS_CREATOR_REST", arguments: this.visit(e.arguments), body: this.visit(e.classBody) } } explicitGenericInvocation(e) { return { type: "GENERIC_INVOCATION", typeArguments: this.visit(e.nonWildcardTypeArguments), invocation: this.visit(e.explicitGenericInvocationSuffix) } } typeArgumentsOrDiamond(e) { return e.emptyDiamond ? { type: "TYPE_ARGUMENTS", value: void 0 } : e.typeArguments ? this.visit(e.typeArguments) : void 0 } nonWildcardTypeArgumentsOrDiamond(e) { return e.emptyDiamond ? { type: "TYPE_ARGUMENTS", value: void 0 } : e.nonWildcardTypeArguments ? this.visit(e.nonWildcardTypeArguments) : void 0 } emptyDiamond() { } nonWildcardTypeArguments(e) { return { type: "TYPE_ARGUMENTS", value: this.visit(e.typeList) } } qualifiedName(e) { const t = []; return e.Identifier && e.Identifier.map((e => t.push(this.identifier(e)))), { type: "QUALIFIED_NAME", name: t } } primary(e) { if (e.nonWildcardTypeArguments) { const t = this.visit(e.nonWildcardTypeArguments); let n; return e.explicitGenericInvocationSuffix && (n = this.visit(e.explicitGenericInvocationSuffix)), e.arguments && (n = { type: "THIS", arguments: this.visit(e.arguments) }), { type: "GENERIC_INVOCATION", typeArguments: t, invocation: n } } if (e.thisOrSuper) return this.visit(e.thisOrSuper); if (e.literal) return this.visit(e.literal); if (e.Void) return { type: "VOID" }; const t = []; e.annotation && e.annotation.map((e => t.push(this.visit(e)))); const n = []; let r; if (e.dimension && e.dimension.map((e => n.push(this.visit(e)))), e.primitiveType) { if (r = this.visit(e.primitiveType), 0 === t.length && 0 === n.length) return r } else if (e.Identifier && e.Identifier) { const t = this.identifier(e.Identifier[0]), n = this.visit(e.typeArguments); r = n ? { type: "CLASS_OR_INTERFACE_TYPE_ELEMENT", name: t, typeArguments: n } : t } else e.identifierOrIdentifierWithTypeArgumentsOrOperatorExpression && e.identifierOrIdentifierWithTypeArgumentsOrOperatorExpression && (r = this.visit(e.identifierOrIdentifierWithTypeArgumentsOrOperatorExpression)); return r ? 0 === t.length && 0 === n.length ? r : { type: "TYPE_TYPE", modifiers: t, value: r, dimensions: n } : t[0] } identifierOrIdentifierWithTypeArgumentsOrOperatorExpression(e) { const t = this.identifier(e.Identifier[0]); if (e.typeArgumentsOrOperatorExpressionRest) { const n = this.visit(e.typeArgumentsOrOperatorExpressionRest); return "OPERATOR_EXPRESSION_REST" === n.type ? { type: "OPERATOR_EXPRESSION", left: t, operator: n.operator, right: n.expression } : { type: "CLASS_OR_INTERFACE_TYPE_ELEMENT", name: t, typeArguments: n } } return t } dimension(e) { return e.expression ? { type: "DIMENSION", expression: this.visit(e.expression) } : { type: "DIMENSION" } } thisOrSuper(e) { return e.This ? e.arguments ? { type: "THIS", arguments: this.visit(e.arguments) } : { type: "THIS" } : e.Super ? e.arguments ? { type: "SUPER", arguments: this.visit(e.arguments) } : { type: "SUPER" } : void 0 } literal(e) { if (e.integerLiteral) return this.visit(e.integerLiteral); if (e.floatLiteral) return this.visit(e.floatLiteral); if (e.CharLiteral) { let t = e.CharLiteral[0].image; return t = "'''" === t ? "'\\''" : JSON.stringify(t).slice(1, -1), { type: "CHAR_LITERAL", value: t } } return e.stringLiteral ? this.visit(e.stringLiteral) : e.booleanLiteral ? this.visit(e.booleanLiteral) : e.Null ? { type: "NULL" } : void 0 } stringLiteral(e) { return { type: "STRING_LITERAL", value: e.StringLiteral[0].image } } booleanLiteral(e) { let t; return e.True && (t = "true"), e.False && (t = "false"), { type: "BOOLEAN_LITERAL", value: t } } integerLiteral(e) { return e.DecimalLiteral ? { type: "DECIMAL_LITERAL", value: e.DecimalLiteral[0].image } : e.HexLiteral ? { type: "HEX_LITERAL", value: e.HexLiteral[0].image } : e.OctLiteral ? { type: "OCT_LITERAL", value: e.OctLiteral[0].image } : e.BinaryLiteral ? { type: "BINARY_LITERAL", value: e.BinaryLiteral[0].image } : void 0 } floatLiteral(e) { return e.FloatLiteral ? { type: "FLOAT_LITERAL", value: e.FloatLiteral[0].image } : e.HexFloatLiteral ? { type: "HEX_FLOAT_LITERAL", value: e.HexFloatLiteral[0].image } : void 0 } hexFloatLiteral(e) { return { type: "HEX_FLOAT_LITERAL", value: e.HexFloatLiteral[0].image } } primitiveType(e) { let t = ""; return e.Boolean ? t = "boolean" : e.Char ? t = "char" : e.Byte ? t = "byte" : e.Short ? t = "short" : e.Int ? t = "int" : e.Long ? t = "long" : e.Float ? t = "float" : e.Double && (t = "double"), { type: "PRIMITIVE_TYPE", value: t } } semiColon(e) { return { type: "SEMI_COLON", followedEmptyLine: !!e.SemiColonWithFollowEmptyLine } } identifier(e) { return { type: "IDENTIFIER", value: e.image } } commentStandalone(e) { return e.LineCommentStandalone ? this.LineCommentStandalone(e.LineCommentStandalone[0]) : e.JavaDocCommentStandalone ? this.JavaDocTraditionalCommentStandalone(e.JavaDocCommentStandalone[0]) : e.TraditionalCommentStandalone ? this.JavaDocTraditionalCommentStandalone(e.TraditionalCommentStandalone[0]) : void 0 } visit(e) { let t = super.visit(e); return t = this.addCommentsToAst(e, t), t } addCommentsToAst(e, t) { return e && (e.constructor === Array ? e.map((e => this.addComment(e, t))) : this.addComment(e, t)), t } addComment(e, t) { const n = e.children.LineComment || e.children.TraditionalComment || e.children.JavaDocComment; t && n && (!t.comment && n && (t.comments = []), e.children.LineComment && e.children.LineComment.map((e => t.comments.unshift(this.getComment(e)))), e.children.TraditionalComment && e.children.TraditionalComment.map((e => t.comments.unshift(this.getComment(e)))), e.children.JavaDocComment && e.children.JavaDocComment.map((e => t.comments.unshift(this.getComment(e))))) } getComment(e) { return { ast_type: "comment", value: e.image.startsWith("//") ? e.image.replace(/[\n\r]*/g, "") : e.image.replace(/\*\/[\n\r]*/g, "*/"), leading: !e.trailing, trailing: !!e.trailing } } } }, 7177: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(5391), a = n(9337), i = n(58), u = n(7477), d = n(6371), o = n(2), s = n(9722), c = n(3375), f = n(7611), l = n(8516), p = n(6627), h = {}; h.VERSION = d.VERSION, h.Parser = r.Parser, h.ParserDefinitionErrorType = r.ParserDefinitionErrorType, h.Lexer = a.Lexer, h.LexerDefinitionErrorType = a.LexerDefinitionErrorType, h.EOF = i.EOF, h.tokenName = i.tokenName, h.tokenLabel = i.tokenLabel, h.tokenMatcher = i.tokenMatcher, h.createToken = i.createToken, h.createTokenInstance = i.createTokenInstance, h.EMPTY_ALT = r.EMPTY_ALT, h.defaultParserErrorProvider = o.defaultParserErrorProvider, h.isRecognitionException = u.isRecognitionException, h.EarlyExitException = u.EarlyExitException, h.MismatchedTokenException = u.MismatchedTokenException, h.NotAllInputParsedException = u.NotAllInputParsedException, h.NoViableAltException = u.NoViableAltException, h.Flat = f.Flat, h.Repetition = f.Repetition, h.RepetitionWithSeparator = f.RepetitionWithSeparator, h.RepetitionMandatory = f.RepetitionMandatory, h.RepetitionMandatoryWithSeparator = f.RepetitionMandatoryWithSeparator, h.Option = f.Option, h.Alternation = f.Alternation, h.NonTerminal = f.NonTerminal, h.Terminal = f.Terminal, h.Rule = f.Rule, h.GAstVisitor = c.GAstVisitor, h.serializeGrammar = f.serializeGrammar, h.serializeProduction = f.serializeProduction, h.resolveGrammar = l.resolveGrammar, h.defaultGrammarResolverErrorProvider = o.defaultGrammarResolverErrorProvider, h.validateGrammar = l.validateGrammar, h.defaultGrammarValidatorErrorProvider = o.defaultGrammarValidatorErrorProvider, h.assignOccurrenceIndices = l.assignOccurrenceIndices, h.clearCache = function () { console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n\t It performs no action other than printing this message.\n\t Please avoid using it as it will be completely removed in the future") }, h.createSyntaxDiagramsCode = s.createSyntaxDiagramsCode, h.generateParserFactory = p.generateParserFactory, h.generateParserModule = p.generateParserModule, e.exports = h }, 9722: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6371); t.createSyntaxDiagramsCode = function (e, t) { var n = void 0 === t ? {} : t, a = n.resourceBase, i = void 0 === a ? "https://unpkg.com/chevrotain@" + r.VERSION + "/diagrams/" : a, u = n.css; return "\n\x3c!-- This is a generated file --\x3e\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n\n<link rel='stylesheet' href='" + (void 0 === u ? "https://unpkg.com/chevrotain@" + r.VERSION + "/diagrams/diagrams.css" : u) + "'>\n\n<script src='" + i + "vendor/railroad-diagrams.js'><\/script>\n<script src='" + i + "src/diagrams_builder.js'><\/script>\n<script src='" + i + "src/diagrams_behavior.js'><\/script>\n<script src='" + i + 'src/main.js\'><\/script>\n\n<div id="diagrams" align="center"></div>    \n\n<script>\n    window.serializedGrammar = ' + JSON.stringify(e, null, "  ") + ';\n<\/script>\n\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n' } }, 6828: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = n(58), i = n(7611), u = "\n"; function d(e) { return "\nfunction " + e.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    chevrotain.Parser.call(this, [], tokenVocabulary, config)\n\n    const $ = this\n\n    " + o(e.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    chevrotain.Parser.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + e.name + ".prototype = Object.create(chevrotain.Parser.prototype)\n" + e.name + ".prototype.constructor = " + e.name + "    \n    " } function o(e) { return r.map(e, (function (e) { return s(e, 1) })).join("\n") } function s(e, t) { var n = y(t, '$.RULE("' + e.name + '", function() {') + u; return (n += E(e.definition, t + 1)) + (y(t + 1, "})") + u) } function c(e, t) { var n = a.tokenName(e.terminalType); return y(t, "$.CONSUME" + e.idx + "(this.tokensMap." + n + ")" + u) } function f(e, t) { return y(t, "$.SUBRULE" + e.idx + "($." + e.nonTerminalName + ")" + u) } function l(e, t) { var n = y(t, "$.OR" + e.idx + "([") + u; return (n += r.map(e.definition, (function (e) { return p(e, t + 1) })).join(",\n")) + (u + y(t, "])\n")) } function p(e, t) { var n = y(t, "{") + u; return e.name && (n += y(t + 1, 'NAME: "' + e.name + '",') + u), n += y(t + 1, "ALT: function() {") + u, n += E(e.definition, t + 1), (n += y(t + 1, "}") + u) + y(t, "}") } function h(e, t, n) { var r = y(n, "$." + (e + t.idx) + "("); return t.name || t.separator ? (r += "{\n", t.name && (r += y(n + 1, 'NAME: "' + t.name + '"') + "," + u), t.separator && (r += y(n + 1, "SEP: this.tokensMap." + a.tokenName(t.separator)) + "," + u), r += "DEF: " + m(t.definition, n + 2) + u, r += y(n, "}") + u) : r += m(t.definition, n + 1), r + (y(n, ")") + u) } function m(e, t) { var n = "function() {\n"; return (n += E(e, t)) + (y(t, "}") + u) } function E(e, t) { var n = ""; return r.forEach(e, (function (e) { n += function (e, t) { if (e instanceof i.NonTerminal) return f(e, t); if (e instanceof i.Option) return h("OPTION", e, t); if (e instanceof i.RepetitionMandatory) return h("AT_LEAST_ONE", e, t); if (e instanceof i.RepetitionMandatoryWithSeparator) return h("AT_LEAST_ONE_SEP", e, t); if (e instanceof i.RepetitionWithSeparator) return h("MANY_SEP", e, t); if (e instanceof i.Repetition) return h("MANY", e, t); if (e instanceof i.Alternation) return l(e, t); if (e instanceof i.Terminal) return c(e, t); if (e instanceof i.Flat) return E(e.definition, t); throw Error("non exhaustive match") }(e, t + 1) })), n } function y(e, t) { return Array(4 * e + 1).join(" ") + t } t.genUmdModule = function (e) { return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + d(e) + "\n    \nreturn {\n    " + e.name + ": " + e.name + " \n}\n}));\n" }, t.genWrapperFunction = function (e) { return "    \n" + d(e) + "\nreturn new " + e.name + "(tokenVocabulary, config)    \n" }, t.genClass = d, t.genAllRules = o, t.genRule = s, t.genTerminal = c, t.genNonTerminal = f, t.genAlternation = l, t.genSingleAlt = p }, 6627: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6828); t.generateParserFactory = function (e) { var t = r.genWrapperFunction({ name: e.name, rules: e.rules }), a = new Function("tokenVocabulary", "config", "chevrotain", t); return function (t) { return a(e.tokenVocabulary, t, n(7177)) } }, t.generateParserModule = function (e) { return r.genUmdModule({ name: e.name, rules: e.rules }) } }, 8965: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382); t.classNameFromInstance = function (e) { return u(e.constructor) }; var a = /^\s*function\s*(\S*)\s*\(/, i = "name"; function u(e) { return e.name || e.toString().match(a)[1] } t.functionName = u, t.defineNameProp = function (e, t) { var n = Object.getOwnPropertyDescriptor(e, i); return !(!r.isUndefined(n) && !n.configurable || (Object.defineProperty(e, i, { enumerable: !1, configurable: !0, writable: !1, value: t }), 0)) }; var d = function () { function e() { this._state = {} } return e.prototype.keys = function () { return r.keys(this._state) }, e.prototype.values = function () { return r.values(this._state) }, e.prototype.put = function (e, t) { this._state[e] = t }, e.prototype.putAll = function (e) { this._state = r.assign(this._state, e._state) }, e.prototype.get = function (e) { return this._state[e] }, e.prototype.containsKey = function (e) { return r.has(this._state, e) }, e.prototype.clear = function () { this._state = {} }, e }(); t.HashTable = d }, 7850: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.IN = "_~IN~_" }, 3348: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(6382), u = n(8965), d = n(4445), o = n(7611), s = n(3375); t.addTerminalToCst = function (e, t, n) { void 0 === e.children[n] ? e.children[n] = [t] : e.children[n].push(t) }, t.addNoneTerminalToCst = function (e, t, n) { void 0 === e.children[t] ? e.children[t] = [n] : e.children[t].push(n) }; var c = function (e) { function t(t) { var n = e.call(this) || this; return n.result = [], n.ruleIdx = t, n } return a(t, e), t.prototype.collectNamedDSLMethod = function (e, t, n) { if (!i.isUndefined(e.name)) { var r = void 0; if (e instanceof o.Option || e instanceof o.Repetition || e instanceof o.RepetitionMandatory || e instanceof o.Alternation) r = new t({ definition: e.definition, idx: e.idx }); else { if (!(e instanceof o.RepetitionMandatoryWithSeparator || e instanceof o.RepetitionWithSeparator)) throw Error("non exhaustive match"); r = new t({ definition: e.definition, idx: e.idx, separator: e.separator }) } var a = [r], u = d.getKeyForAutomaticLookahead(this.ruleIdx, n, e.idx); this.result.push({ def: a, key: u, name: e.name, orgProd: e }) } }, t.prototype.visitOption = function (e) { this.collectNamedDSLMethod(e, o.Option, d.OPTION_IDX) }, t.prototype.visitRepetition = function (e) { this.collectNamedDSLMethod(e, o.Repetition, d.MANY_IDX) }, t.prototype.visitRepetitionMandatory = function (e) { this.collectNamedDSLMethod(e, o.RepetitionMandatory, d.AT_LEAST_ONE_IDX) }, t.prototype.visitRepetitionMandatoryWithSeparator = function (e) { this.collectNamedDSLMethod(e, o.RepetitionMandatoryWithSeparator, d.AT_LEAST_ONE_SEP_IDX) }, t.prototype.visitRepetitionWithSeparator = function (e) { this.collectNamedDSLMethod(e, o.RepetitionWithSeparator, d.MANY_SEP_IDX) }, t.prototype.visitAlternation = function (e) { var t = this; this.collectNamedDSLMethod(e, o.Alternation, d.OR_IDX); var n = e.definition.length > 1; i.forEach(e.definition, (function (r, a) { if (!i.isUndefined(r.name)) { var u = r.definition; u = n ? [new o.Option({ definition: r.definition })] : r.definition; var s = d.getKeyForAltIndex(t.ruleIdx, d.OR_IDX, e.idx, a); t.result.push({ def: u, key: s, name: r.name, orgProd: r }) } })) }, t }(s.GAstVisitor); t.NamedDSLMethodsCollectorVisitor = c, t.analyzeCst = function (e, t) { var n = { dictDef: new u.HashTable, allRuleNames: [] }; return i.forEach(e, (function (e) { var r = t.get(e.name); n.allRuleNames.push(e.name); var a = new c(r); e.accept(a), i.forEach(a.result, (function (t) { t.def, t.key; var r = t.name; n.allRuleNames.push(e.name + r) })) })), n } }, 3650: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r, a = n(6382), i = n(8965), u = n(6460); function d(e, t) { for (var n = a.keys(e), r = n.length, i = 0; i < r; i++)for (var u = e[n[i]], d = u.length, o = 0; o < d; o++) { var s = u[o]; void 0 === s.tokenTypeIdx && (void 0 !== s.fullName ? this[s.fullName](s.children, t) : this[s.name](s.children, t)) } } function o(e, t) { var n = s(e, t), r = f(e, t); return n.concat(r) } function s(e, t) { var n = a.map(t, (function (t) { if (!a.isFunction(e[t])) return { msg: "Missing visitor method: <" + t + "> on " + i.functionName(e.constructor) + " CST Visitor.", type: r.MISSING_METHOD, methodName: t } })); return a.compact(n) } t.defaultVisit = d, t.createBaseSemanticVisitorConstructor = function (e, t) { var n = function () { }; return i.defineNameProp(n, e + "BaseSemantics"), (n.prototype = { visit: function (e, t) { if (a.isArray(e) && (e = e[0]), !a.isUndefined(e)) return void 0 !== e.fullName ? this[e.fullName](e.children, t) : this[e.name](e.children, t) }, validateVisitor: function () { var e = o(this, t); if (!a.isEmpty(e)) { var n = a.map(e, (function (e) { return e.msg })); throw Error("Errors Detected in CST Visitor <" + i.functionName(this.constructor) + ">:\n\t" + n.join("\n\n").replace(/\n/g, "\n\t")) } } }).constructor = n, n._RULE_NAMES = t, n }, t.createBaseVisitorConstructorWithDefaults = function (e, t, n) { var r = function () { }; i.defineNameProp(r, e + "BaseSemanticsWithDefaults"); var u = Object.create(n.prototype); return a.forEach(t, (function (e) { u[e] = d })), (r.prototype = u).constructor = r, r }, function (e) { e[e.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", e[e.MISSING_METHOD = 1] = "MISSING_METHOD" }(r = t.CstVisitorDefinitionError || (t.CstVisitorDefinitionError = {})), t.validateVisitor = o, t.validateMissingCstMethods = s; var c = ["constructor", "visit", "validateVisitor"]; function f(e, t) { var n = []; for (var d in e) u.validTermsPattern.test(d) && a.isFunction(e[d]) && !a.contains(c, d) && !a.contains(t, d) && n.push({ msg: "Redundant visitor method: <" + d + "> on " + i.functionName(e.constructor) + " CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\nFor utility methods on visitor classes use methods names that do not match /" + u.validTermsPattern.source + "/.", type: r.REDUNDANT_METHOD, methodName: d }); return n } t.validateRedundantMethods = f }, 2: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(58), a = n(6382), i = n(6382), u = n(7611), d = n(3221), o = n(6460), s = n(6371); t.defaultParserErrorProvider = { buildMismatchTokenMessage: function (e) { var t = e.expected, n = e.actual; return e.previous, e.ruleName, "Expecting " + (r.hasTokenLabel(t) ? "--\x3e " + r.tokenLabel(t) + " <--" : "token of type --\x3e " + r.tokenName(t) + " <--") + " but found --\x3e '" + n.image + "' <--" }, buildNotAllInputParsedMessage: function (e) { var t = e.firstRedundant; return e.ruleName, "Redundant input, expecting EOF but found: " + t.image }, buildNoViableAltMessage: function (e) { var t = e.expectedPathsPerAlt, n = e.actual, a = (e.previous, e.customUserDescription), u = (e.ruleName, "Expecting: "), d = "\nbut found: '" + i.first(n).image + "'"; if (a) return u + a + d; var o = i.reduce(t, (function (e, t) { return e.concat(t) }), []), s = i.map(o, (function (e) { return "[" + i.map(e, (function (e) { return r.tokenLabel(e) })).join(", ") + "]" })); return u + "one of these possible Token sequences:\n" + i.map(s, (function (e, t) { return "  " + (t + 1) + ". " + e })).join("\n") + d }, buildEarlyExitMessage: function (e) { var t = e.expectedIterationPaths, n = e.actual, a = e.customUserDescription, u = (e.ruleName, "Expecting: "), d = "\nbut found: '" + i.first(n).image + "'"; return a ? u + a + d : u + "expecting at least one iteration which starts with one of these possible Token sequences::\n  <" + i.map(t, (function (e) { return "[" + i.map(e, (function (e) { return r.tokenLabel(e) })).join(",") + "]" })).join(" ,") + ">" + d } }, Object.freeze(t.defaultParserErrorProvider), t.defaultGrammarResolverErrorProvider = { buildRuleNotFoundError: function (e, t) { return "Invalid grammar, reference to a rule which is not defined: ->" + t.nonTerminalName + "<-\ninside top level rule: ->" + e.name + "<-" } }, t.defaultGrammarValidatorErrorProvider = { buildDuplicateFoundError: function (e, t) { var n, a = e.name, o = i.first(t), s = o.idx, c = d.getProductionDslName(o), f = (n = o) instanceof u.Terminal ? r.tokenName(n.terminalType) : n instanceof u.NonTerminal ? n.nonTerminalName : "", l = "->" + c + "<- with numerical suffix: ->" + s + "<-\n                  " + (f ? "and argument: ->" + f + "<-" : "") + "\n                  appears more than once (" + t.length + " times) in the top level rule: ->" + a + "<-.\n                  " + (0 === s ? "Also note that numerical suffix 0 means " + c + " without any suffix." : "") + "\n                  To fix this make sure each usage of " + c + " " + (f ? "with the argument: ->" + f + "<-" : "") + "\n                  in the rule ->" + a + "<- has a different occurrence index (0-5), as that combination acts as a unique\n                  position key in the grammar, which is needed by the parsing engine.\n                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  "; return (l = l.replace(/[ \t]+/g, " ")).replace(/\s\s+/g, "\n") }, buildInvalidNestedRuleNameError: function (e, t) { return "Invalid nested rule name: ->" + t.name + "<- inside rule: ->" + e.name + "<-\nit must match the pattern: ->" + o.validNestedRuleName.toString() + "<-.\nNote that this means a nested rule name must start with the '$'(dollar) sign." }, buildDuplicateNestedRuleNameError: function (e, t) { return "Duplicate nested rule name: ->" + i.first(t).name + "<- inside rule: ->" + e.name + "<-\nA nested name must be unique in the scope of a top level grammar rule." }, buildNamespaceConflictError: function (e) { return "Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + e.name + ">.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter." }, buildAlternationPrefixAmbiguityError: function (e) { var t = i.map(e.prefixPath, (function (e) { return r.tokenLabel(e) })).join(", "), n = 0 === e.alternation.idx ? "" : e.alternation.idx; return "Ambiguous alternatives: <" + e.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\nin <OR" + n + "> inside <" + e.topLevelRule.name + "> Rule,\n<" + t + "> may appears as a prefix path in all these alternatives.\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details." }, buildAlternationAmbiguityError: function (e) { var t = i.map(e.prefixPath, (function (e) { return r.tokenLabel(e) })).join(", "), n = 0 === e.alternation.idx ? "" : e.alternation.idx, a = "Ambiguous alternatives: <" + e.ambiguityIndices.join(" ,") + "> in <OR" + n + "> inside <" + e.topLevelRule.name + "> Rule,\n<" + t + "> may appears as a prefix path in all these alternatives.\n"; return a + "To Resolve this, try one of of the following: \n1. Refactor your grammar to be LL(K) for the current value of k (by default k=5)\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/" + s.VERSION.replace(/\./g, "_") + "/interfaces/iparserconfig.html#ignoredissues for more details\n" }, buildEmptyRepetitionError: function (e) { var t = d.getProductionDslName(e.repetition); return 0 !== e.repetition.idx && (t += e.repetition.idx), "The repetition <" + t + "> within Rule <" + e.topLevelRule.name + "> can never consume any tokens.\nThis could lead to an infinite loop." }, buildTokenNameError: function (e) { return "Invalid Grammar Token name: ->" + r.tokenName(e.tokenType) + "<- it must match the pattern: ->" + e.expectedPattern.toString() + "<-" }, buildEmptyAlternationError: function (e) { return "Ambiguous empty alternative: <" + (e.emptyChoiceIdx + 1) + "> in <OR" + e.alternation.idx + "> inside <" + e.topLevelRule.name + "> Rule.\nOnly the last alternative may be an empty alternative." }, buildTooManyAlternativesError: function (e) { return "An Alternation cannot have more than 256 alternatives:\n<OR" + e.alternation.idx + "> inside <" + e.topLevelRule.name + "> Rule.\n has " + (e.alternation.definition.length + 1) + " alternatives." }, buildLeftRecursionError: function (e) { var t = e.topLevelRule.name; return "Left Recursion found in grammar.\nrule: <" + t + "> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n " + t + " --\x3e " + a.map(e.leftRecursionPath, (function (e) { return e.name })).concat([t]).join(" --\x3e ") + "\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring." }, buildInvalidRuleNameError: function (e) { return "Invalid grammar rule name: ->" + e.topLevelRule.name + "<- it must match the pattern: ->" + e.expectedPattern.toString() + "<-" }, buildDuplicateRuleNameError: function (e) { return "Duplicate definition, rule: ->" + (e.topLevelRule instanceof u.Rule ? e.topLevelRule.name : e.topLevelRule) + "<- is already defined in the grammar: ->" + e.grammarName + "<-" } } }, 7477: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = "MismatchedTokenException", i = "NoViableAltException", u = "EarlyExitException", d = "NotAllInputParsedException", o = [a, i, u, d]; function s(e, t, n) { this.name = a, this.message = e, this.token = t, this.previousToken = n, this.resyncedTokens = [] } function c(e, t, n) { this.name = i, this.message = e, this.token = t, this.previousToken = n, this.resyncedTokens = [] } function f(e, t) { this.name = d, this.message = e, this.token = t, this.resyncedTokens = [] } function l(e, t, n) { this.name = u, this.message = e, this.token = t, this.previousToken = n, this.resyncedTokens = [] } Object.freeze(o), t.isRecognitionException = function (e) { return r.contains(o, e.name) }, t.MismatchedTokenException = s, s.prototype = Error.prototype, t.NoViableAltException = c, c.prototype = Error.prototype, t.NotAllInputParsedException = f, f.prototype = Error.prototype, t.EarlyExitException = l, l.prototype = Error.prototype }, 8900: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r, a = n(802), i = n(6382), u = n(7611); !function (e) { e[e.OPTION = 0] = "OPTION", e[e.OR = 1] = "OR", e[e.MANY = 2] = "MANY", e[e.MANY_SEP = 3] = "MANY_SEP", e[e.AT_LEAST_ONE = 4] = "AT_LEAST_ONE", e[e.AT_LEAST_ONE_SEP = 5] = "AT_LEAST_ONE_SEP", e[e.REF = 6] = "REF", e[e.TERMINAL = 7] = "TERMINAL", e[e.FLAT = 8] = "FLAT" }(r = t.ProdType || (t.ProdType = {})); var d = /(?:\s*{\s*NAME\s*:\s*["'`]([\w$]*)["'`])?/, o = new RegExp(d.source.replace("{", "").replace(")?", "\\s*,)?")), s = /\.\s*CONSUME(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, c = new RegExp(s.source, "g"), f = /\.\s*SUBRULE(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, l = new RegExp(f.source, "g"), p = /\.\s*OPTION(\d+)?\s*\(/, h = new RegExp(p.source + d.source), m = new RegExp(p.source, "g"), E = /\.\s*MANY(\d+)?\s*\(/, y = new RegExp(E.source + d.source), T = new RegExp(E.source, "g"), S = /\s*SEP\s*:\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/, v = new RegExp(/\.\s*MANY_SEP(\d+)?\s*\(\s*{/.source + o.source + S.source), R = new RegExp(v.source, "g"), L = new RegExp(/\.\s*AT_LEAST_ONE_SEP(\d+)?\s*\(\s*{/.source + o.source + S.source), A = new RegExp(L.source, "g"), O = /\.\s*AT_LEAST_ONE(\d+)?\s*\(/, b = new RegExp(O.source + d.source), I = new RegExp(O.source, "g"), N = /\.\s*OR(\d+)?\s*\(/, g = new RegExp(N.source + d.source), _ = new RegExp(N.source, "g"), U = new RegExp(o.source + /\s*(ALT)\s*:/.source), C = new RegExp(U.source, "g"); function x(e, n) { switch (e.type) { case r.AT_LEAST_ONE: return function (e, t) { return M(b, new u.RepetitionMandatory({ definition: [] }), e, t) }(e, n); case r.AT_LEAST_ONE_SEP: return function (e, t) { return P(e, t, u.RepetitionMandatoryWithSeparator, L) }(e, n); case r.MANY_SEP: return function (e, t) { return P(e, t, u.RepetitionWithSeparator, v) }(e, n); case r.MANY: return function (e, t) { return M(y, new u.Repetition({ definition: [] }), e, t) }(e, n); case r.OPTION: return function (e, t) { return M(h, new u.Option({ definition: [] }), e, t) }(e, n); case r.OR: return function (e, t) { return M(g, new u.Alternation({ definition: [] }), e, t) }(e, n); case r.FLAT: return function (e, t) { var n = new u.Flat({ definition: [] }), r = U.exec(e.text)[1]; return i.isUndefined(r) || (n.name = r), k(n, e.range, t) }(e, n); case r.REF: return function (e) { var t = f.exec(e.text), n = void 0 === t[1] ? 0 : parseInt(t[1], 10), r = t[2]; return new u.NonTerminal({ nonTerminalName: r, idx: n }) }(e); case r.TERMINAL: return function (e) { var n = s.exec(e.text), r = void 0 === n[1] ? 0 : parseInt(n[1], 10), a = n[2], i = t.terminalNameToConstructor[a]; if (!i) throw Error("Terminal Token name: " + a + " not found\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\n\tFor Further details."); return new u.Terminal({ terminalType: i, idx: r }) }(e); default: throw Error("non exhaustive match") } } function M(e, t, n, r) { var a = e.exec(n.text), u = void 0 === a[1]; t.idx = u ? 0 : parseInt(a[1], 10); var d = a[2]; return i.isUndefined(d) || (t.name = d), k(t, n.range, r) } function P(e, n, r, a) { var u = a.exec(e.text), d = void 0 === u[1] ? 0 : parseInt(u[1], 10), o = u[3], s = t.terminalNameToConstructor[o]; if (!s) throw Error("Separator Terminal Token name: " + o + " not found"); var c = new r({ definition: [], separator: s, idx: d }), f = u[2]; return i.isUndefined(f) || (c.name = f), k(c, e.range, n) } function k(e, t, n) { var r = D(t, n), a = i.sortBy(r, (function (e) { return e.range.start })), u = []; return i.forEach(a, (function (e) { u.push(x(e, n)) })), e.definition = u, e } function D(e, t) { return i.filter(t, (function (n) { var r = e.strictlyContainsRange(n.range), a = i.every(t, (function (t) { var r = t.range.strictlyContainsRange(n.range), a = t.range.isStrictlyContainedInRange(e); return !(r && a) })); return r && a })) } t.terminalNameToConstructor = {}, t.buildTopProduction = function (e, n, r) { t.terminalNameToConstructor = r; var i = q(W(Y("  " + e))); return function (e, t, n, r) { return k(new u.Rule({ name: e, definition: [], orgText: r }), t, n) }(n, new a.Range(0, e.length + 2), i, e) }, t.buildProdGast = x, t.getDirectlyContainedRanges = D; var B = /\/\/.*/g, w = /\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g, F = /(NAME\s*:\s*)?"([^\\"]|\\([bfnrtv"\\/]|u[0-9a-fA-F]{4}))*"/g, G = /(NAME\s*:\s*)?'([^\\']|\\([bfnrtv'\\/]|u[0-9a-fA-F]{4}))*'/g; function Y(e) { return e.replace(B, "").replace(w, "") } function V(e, t) { return void 0 !== t ? e : "" } function W(e) { return e.replace(F, V).replace(G, V) } function q(e) { var t = j(e), n = K(e), r = H(e), a = z(e), i = X(e), u = $(e), d = J(e), o = Z(e); return [].concat(t, n, r, a, i, u, d, o) } function j(e) { return ne(e, r.TERMINAL, c) } function K(e) { return ne(e, r.REF, l) } function H(e) { return re(e, r.AT_LEAST_ONE, I) } function z(e) { return re(e, r.AT_LEAST_ONE_SEP, A) } function X(e) { return re(e, r.MANY, T) } function $(e) { return re(e, r.MANY_SEP, R) } function J(e) { return re(e, r.OPTION, m) } function Z(e) { var t = re(e, r.OR, _), n = te(t); return t.concat(n) } t.removeComments = Y, t.removeStringLiterals = W, t.createRanges = q, t.createTerminalRanges = j, t.createRefsRanges = K, t.createAtLeastOneRanges = H, t.createAtLeastOneSepRanges = z, t.createManyRanges = X, t.createManySepRanges = $, t.createOptionRanges = J, t.createOrRanges = Z; var Q = i.partial(ie, "{", "}"), ee = i.partial(ie, "(", ")"); function te(e) { var t = []; return i.forEach(e, (function (e) { var n = ae(e.text, r.FLAT, C, Q), a = e.range.start; i.forEach(n, (function (e) { e.range.start += a, e.range.end += a })), t = t.concat(n) })), i.uniq(t, (function (e) { return e.type + "~" + e.range.start + "~" + e.range.end + "~" + e.text })) } function ne(e, t, n) { for (var r, i = []; r = n.exec(e);) { var u = r.index, d = n.lastIndex, o = new a.Range(u, d), s = r[0]; i.push({ range: o, text: s, type: t }) } return i } function re(e, t, n) { return ae(e, t, n, ee) } function ae(e, t, n, r) { for (var i, u = []; i = n.exec(e);) { var d = i.index, o = r(d + i[0].length, e), s = new a.Range(d, o), c = e.substr(d, o - d + 1); u.push({ range: s, text: c, type: t }) } return u } function ie(e, t, n, r) { for (var a = [1], u = -1; !i.isEmpty(a) && u + n < r.length;) { u++; var d = r.charAt(n + u); d === e ? a.push(1) : d === t && a.pop() } if (i.isEmpty(a)) return u + n; throw new Error("INVALID INPUT TEXT, UNTERMINATED PARENTHESIS") } function ue(e, t) { return i.map(e, (function (e) { return de(e, t) })) } function de(e, t) { switch (e.type) { case "NonTerminal": return new u.NonTerminal({ nonTerminalName: e.name, idx: e.idx }); case "Flat": return new u.Flat({ name: e.name, definition: ue(e.definition, t) }); case "Option": return new u.Option({ name: e.name, idx: e.idx, definition: ue(e.definition, t) }); case "RepetitionMandatory": return new u.RepetitionMandatory({ name: e.name, idx: e.idx, definition: ue(e.definition, t) }); case "RepetitionMandatoryWithSeparator": return new u.RepetitionMandatoryWithSeparator({ name: e.name, idx: e.idx, separator: t[e.separator.name], definition: ue(e.definition, t) }); case "RepetitionWithSeparator": return new u.RepetitionWithSeparator({ name: e.name, idx: e.idx, separator: t[e.separator.name], definition: ue(e.definition, t) }); case "Repetition": return new u.Repetition({ name: e.name, idx: e.idx, definition: ue(e.definition, t) }); case "Alternation": return new u.Alternation({ name: e.name, idx: e.idx, definition: ue(e.definition, t) }); case "Terminal": return new u.Terminal({ terminalType: t[e.name], idx: e.idx }); case "Rule": return new u.Rule({ name: e.name, orgText: e.orgText, definition: ue(e.definition, t) }) } } t.createOrPartRanges = te, t.findClosingOffset = ie, t.deserializeGrammar = ue, t.deserializeProduction = de }, 6460: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(6382), u = n(6382), d = n(5391), o = n(3221), s = n(58), c = n(5123), f = n(3348), l = n(4784), p = n(7611), h = n(3375); function m(e) { return o.getProductionDslName(e) + "_#_" + e.idx + "_#_" + E(e) } function E(e) { return e instanceof p.Terminal ? s.tokenName(e.terminalType) : e instanceof p.NonTerminal ? e.nonTerminalName : "" } t.validateGrammar = function (e, t, n, r, a, c) { var l = i.map(e, (function (e) { return function (e, t) { var n = new y; e.accept(n); var r = n.allProductions, a = i.groupBy(r, m), u = i.pick(a, (function (e) { return e.length > 1 })); return i.map(i.values(u), (function (n) { var r = i.first(n), a = t.buildDuplicateFoundError(e, n), u = o.getProductionDslName(r), s = { message: a, type: d.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS, ruleName: e.name, dslName: u, occurrence: r.idx }, c = E(r); return c && (s.parameter = c), s })) }(e, a) })), p = i.map(e, (function (e) { return L(e, e, a) })), h = [], A = []; u.every(p, u.isEmpty) && (h = u.map(e, (function (e) { return b(e, a) })), A = u.map(e, (function (e) { return I(e, t, r, a) }))); var O = function (e, t, n) { var r = [], a = u.map(t, (function (e) { return s.tokenName(e) })); return u.forEach(e, (function (e) { var t = e.name; if (u.contains(a, t)) { var i = n.buildNamespaceConflictError(e); r.push({ message: i, type: d.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE, ruleName: t }) } })), r }(e, n, a), N = i.map(n, (function (e) { return v(e, a) })), U = function (e, t) { var n = []; return u.forEach(e, (function (e) { var r = new f.NamedDSLMethodsCollectorVisitor(""); e.accept(r); var a = u.map(r.result, (function (e) { return e.orgProd })); n.push(u.map(a, (function (n) { return S(e, n, t) }))) })), u.flatten(n) }(e, a), C = function (e, t) { var n = []; return u.forEach(e, (function (e) { var r = new f.NamedDSLMethodsCollectorVisitor(""); e.accept(r); var a = u.groupBy(r.result, (function (e) { return e.name })), i = u.pick(a, (function (e) { return e.length > 1 })); u.forEach(u.values(i), (function (r) { var a = u.map(r, (function (e) { return e.orgProd })), i = t.buildDuplicateNestedRuleNameError(e, a); n.push({ message: i, type: d.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME, ruleName: e.name }) })) })), n }(e, a), x = _(e, t, a), M = u.map(e, (function (e) { return g(e, a) })), P = u.map(e, (function (e) { return T(e, a) })), k = u.map(e, (function (t) { return R(t, e, c, a) })); return i.flatten(l.concat(N, U, C, x, p, h, A, O, M, P, k)) }, t.identifyProductionForDuplicates = m; var y = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.allProductions = [], t } return a(t, e), t.prototype.visitNonTerminal = function (e) { this.allProductions.push(e) }, t.prototype.visitOption = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetitionWithSeparator = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetitionMandatory = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetitionMandatoryWithSeparator = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetition = function (e) { this.allProductions.push(e) }, t.prototype.visitAlternation = function (e) { this.allProductions.push(e) }, t.prototype.visitTerminal = function (e) { this.allProductions.push(e) }, t }(h.GAstVisitor); function T(e, n) { var r = [], a = e.name; return a.match(t.validTermsPattern) || r.push({ message: n.buildInvalidRuleNameError({ topLevelRule: e, expectedPattern: t.validTermsPattern }), type: d.ParserDefinitionErrorType.INVALID_RULE_NAME, ruleName: a }), r } function S(e, n, r) { var a, i = []; return n.name.match(t.validNestedRuleName) || (a = r.buildInvalidNestedRuleNameError(e, n), i.push({ message: a, type: d.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME, ruleName: e.name })), i } function v(e, n) { var r = []; return s.tokenName(e).match(t.validTermsPattern) || r.push({ message: n.buildTokenNameError({ tokenType: e, expectedPattern: t.validTermsPattern }), type: d.ParserDefinitionErrorType.INVALID_TOKEN_NAME }), r } function R(e, t, n, r) { var a = []; if (u.reduce(t, (function (t, n) { return n.name === e.name ? t + 1 : t }), 0) > 1) { var i = r.buildDuplicateRuleNameError({ topLevelRule: e, grammarName: n }); a.push({ message: i, type: d.ParserDefinitionErrorType.DUPLICATE_RULE_NAME, ruleName: e.name }) } return a } function L(e, t, n, r) { void 0 === r && (r = []); var a = [], u = A(t.definition); if (i.isEmpty(u)) return []; var o = e.name; i.contains(u, e) && a.push({ message: n.buildLeftRecursionError({ topLevelRule: e, leftRecursionPath: r }), type: d.ParserDefinitionErrorType.LEFT_RECURSION, ruleName: o }); var s = i.difference(u, r.concat([e])), c = i.map(s, (function (t) { var a = i.cloneArr(r); return a.push(t), L(e, t, n, a) })); return a.concat(i.flatten(c)) } function A(e) { var t = []; if (i.isEmpty(e)) return t; var n = i.first(e); if (n instanceof p.NonTerminal) t.push(n.referencedRule); else if (n instanceof p.Flat || n instanceof p.Option || n instanceof p.RepetitionMandatory || n instanceof p.RepetitionMandatoryWithSeparator || n instanceof p.RepetitionWithSeparator || n instanceof p.Repetition) t = t.concat(A(n.definition)); else if (n instanceof p.Alternation) t = i.flatten(i.map(n.definition, (function (e) { return A(e.definition) }))); else if (!(n instanceof p.Terminal)) throw Error("non exhaustive match"); var r = o.isOptionalProd(n), a = e.length > 1; if (r && a) { var u = i.drop(e); return t.concat(A(u)) } return t } t.OccurrenceValidationCollector = y, t.validTermsPattern = /^[a-zA-Z_]\w*$/, t.validNestedRuleName = new RegExp(t.validTermsPattern.source.replace("^", "^\\$")), t.validateRuleName = T, t.validateNestedRuleName = S, t.validateTokenName = v, t.validateRuleDoesNotAlreadyExist = R, t.validateRuleIsOverridden = function (e, t, n) { var r, a = []; return i.contains(t, e) || (r = "Invalid rule override, rule: ->" + e + "<- cannot be overridden in the grammar: ->" + n + "<-as it is not defined in any of the super grammars ", a.push({ message: r, type: d.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE, ruleName: e })), a }, t.validateNoLeftRecursion = L, t.getFirstNoneTerminal = A; var O = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.alternations = [], t } return a(t, e), t.prototype.visitAlternation = function (e) { this.alternations.push(e) }, t }(h.GAstVisitor); function b(e, t) { var n = new O; e.accept(n); var r = n.alternations; return i.reduce(r, (function (n, r) { var a = i.dropRight(r.definition), u = i.map(a, (function (n, a) { var u = l.nextPossibleTokensAfter([n], [], null, 1); return i.isEmpty(u) ? { message: t.buildEmptyAlternationError({ topLevelRule: e, alternation: r, emptyChoiceIdx: a }), type: d.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT, ruleName: e.name, occurrence: r.idx, alternative: a + 1 } : null })); return n.concat(i.compact(u)) }), []) } function I(e, t, n, r) { var a = new O; e.accept(a); var s = a.alternations, f = n[e.name]; return f && (s = u.reject(s, (function (e) { return f[o.getProductionDslName(e) + (0 === e.idx ? "" : e.idx)] }))), i.reduce(s, (function (n, a) { var o = a.idx, s = c.getLookaheadPathsForOr(o, e, t), f = function (e, t, n, r) { var a = [], o = u.reduce(e, (function (t, n, r) { return u.forEach(n, (function (n) { var i = [r]; u.forEach(e, (function (e, t) { r !== t && c.containsPath(e, n) && i.push(t) })), i.length > 1 && !c.containsPath(a, n) && (a.push(n), t.push({ alts: i, path: n })) })), t }), []); return i.map(o, (function (e) { var a = u.map(e.alts, (function (e) { return e + 1 })); return { message: r.buildAlternationAmbiguityError({ topLevelRule: n, alternation: t, ambiguityIndices: a, prefixPath: e.path }), type: d.ParserDefinitionErrorType.AMBIGUOUS_ALTS, ruleName: n.name, occurrence: t.idx, alternatives: [e.alts] } })) }(s, a, e, r), l = function (e, t, n, r) { var a = [], i = u.reduce(e, (function (e, t, n) { var r = u.map(t, (function (e) { return { idx: n, path: e } })); return e.concat(r) }), []); return u.forEach(i, (function (e) { var o = e.idx, s = e.path, f = u.findAll(i, (function (e) { return e.idx < o && c.isStrictPrefixOfPath(e.path, s) })), l = u.map(f, (function (e) { var a = [e.idx + 1, o + 1], i = 0 === t.idx ? "" : t.idx; return { message: r.buildAlternationPrefixAmbiguityError({ topLevelRule: n, alternation: t, ambiguityIndices: a, prefixPath: e.path }), type: d.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS, ruleName: n.name, occurrence: i, alternatives: a } })); a = a.concat(l) })), a }(s, a, e, r); return n.concat(f, l) }), []) } t.validateEmptyOrAlternative = b, t.validateAmbiguousAlternationAlternatives = I; var N = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.allProductions = [], t } return a(t, e), t.prototype.visitRepetitionWithSeparator = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetitionMandatory = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetitionMandatoryWithSeparator = function (e) { this.allProductions.push(e) }, t.prototype.visitRepetition = function (e) { this.allProductions.push(e) }, t }(h.GAstVisitor); function g(e, t) { var n = new O; e.accept(n); var r = n.alternations; return i.reduce(r, (function (n, r) { return r.definition.length > 255 && n.push({ message: t.buildTooManyAlternativesError({ topLevelRule: e, alternation: r }), type: d.ParserDefinitionErrorType.TOO_MANY_ALTS, ruleName: e.name, occurrence: r.idx }), n }), []) } function _(e, t, n) { var r = []; return u.forEach(e, (function (e) { var a = new N; e.accept(a); var i = a.allProductions; u.forEach(i, (function (a) { var i = c.getProdType(a), o = a.idx, s = c.getLookaheadPathsForOptionalProd(o, e, i, t)[0]; if (u.isEmpty(u.flatten(s))) { var f = n.buildEmptyRepetitionError({ topLevelRule: e, repetition: a }); r.push({ message: f, type: d.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD, ruleName: e.name }) } })) })), r } t.RepetionCollector = N, t.validateTooManyAlts = g, t.validateSomeNonEmptyLookaheadPath = _ }, 2094: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = n(7611), i = n(3221); function u(e) { if (e instanceof a.NonTerminal) return u(e.referencedRule); if (e instanceof a.Terminal) return s(e); if (i.isSequenceProd(e)) return d(e); if (i.isBranchingProd(e)) return o(e); throw Error("non exhaustive match") } function d(e) { for (var t, n = [], a = e.definition, d = 0, o = a.length > d, s = !0; o && s;)t = a[d], s = i.isOptionalProd(t), n = n.concat(u(t)), d += 1, o = a.length > d; return r.uniq(n) } function o(e) { var t = r.map(e.definition, (function (e) { return u(e) })); return r.uniq(r.flatten(t)) } function s(e) { return [e.terminalType] } t.first = u, t.firstForSequence = d, t.firstForBranching = o, t.firstForTerminal = s }, 5247: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(8146), u = n(8965), d = n(2094), o = n(6382), s = n(7850), c = n(58), f = n(7611), l = function (e) { function t(t) { var n = e.call(this) || this; return n.topProd = t, n.follows = new u.HashTable, n } return a(t, e), t.prototype.startWalking = function () { return this.walk(this.topProd), this.follows }, t.prototype.walkTerminal = function (e, t, n) { }, t.prototype.walkProdRef = function (e, t, n) { var r = p(e.referencedRule, e.idx) + this.topProd.name, a = t.concat(n), i = new f.Flat({ definition: a }), u = d.first(i); this.follows.put(r, u) }, t }(i.RestWalker); function p(e, t) { return e.name + t + s.IN } t.ResyncFollowsWalker = l, t.computeAllProdsFollows = function (e) { var t = new u.HashTable; return o.forEach(e, (function (e) { var n = new l(e).startWalking(); t.putAll(n) })), t }, t.buildBetweenProdsFollowPrefix = p, t.buildInProdFollowPrefix = function (e) { return c.tokenName(e.terminalType) + e.idx + s.IN } }, 3221: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(6382), u = n(7611), d = n(3375), o = n(58); t.isSequenceProd = function (e) { return e instanceof u.Flat || e instanceof u.Option || e instanceof u.Repetition || e instanceof u.RepetitionMandatory || e instanceof u.RepetitionMandatoryWithSeparator || e instanceof u.RepetitionWithSeparator || e instanceof u.Terminal || e instanceof u.Rule }, t.isOptionalProd = function e(t, n) { return void 0 === n && (n = []), !!(t instanceof u.Option || t instanceof u.Repetition || t instanceof u.RepetitionWithSeparator) || (t instanceof u.Alternation ? i.some(t.definition, (function (t) { return e(t, n) })) : !(t instanceof u.NonTerminal && i.contains(n, t)) && t instanceof u.AbstractProduction && (t instanceof u.NonTerminal && n.push(t), i.every(t.definition, (function (t) { return e(t, n) })))) }, t.isBranchingProd = function (e) { return e instanceof u.Alternation }, t.getProductionDslName = function (e) { if (e instanceof u.NonTerminal) return "SUBRULE"; if (e instanceof u.Option) return "OPTION"; if (e instanceof u.Alternation) return "OR"; if (e instanceof u.RepetitionMandatory) return "AT_LEAST_ONE"; if (e instanceof u.RepetitionMandatoryWithSeparator) return "AT_LEAST_ONE_SEP"; if (e instanceof u.RepetitionWithSeparator) return "MANY_SEP"; if (e instanceof u.Repetition) return "MANY"; if (e instanceof u.Terminal) return "CONSUME"; throw Error("non exhaustive match") }; var s = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.separator = "-", t.dslMethods = { option: [], alternation: [], repetition: [], repetitionWithSeparator: [], repetitionMandatory: [], repetitionMandatoryWithSeparator: [] }, t } return a(t, e), t.prototype.visitTerminal = function (e) { var t = o.tokenName(e.terminalType) + this.separator + "Terminal"; i.has(this.dslMethods, t) || (this.dslMethods[t] = []), this.dslMethods[t].push(e) }, t.prototype.visitNonTerminal = function (e) { var t = e.nonTerminalName + this.separator + "Terminal"; i.has(this.dslMethods, t) || (this.dslMethods[t] = []), this.dslMethods[t].push(e) }, t.prototype.visitOption = function (e) { this.dslMethods.option.push(e) }, t.prototype.visitRepetitionWithSeparator = function (e) { this.dslMethods.repetitionWithSeparator.push(e) }, t.prototype.visitRepetitionMandatory = function (e) { this.dslMethods.repetitionMandatory.push(e) }, t.prototype.visitRepetitionMandatoryWithSeparator = function (e) { this.dslMethods.repetitionMandatoryWithSeparator.push(e) }, t.prototype.visitRepetition = function (e) { this.dslMethods.repetition.push(e) }, t.prototype.visitAlternation = function (e) { this.dslMethods.alternation.push(e) }, t }(d.GAstVisitor); t.DslMethodsCollectorVisitor = s }, 7611: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(6382), u = n(58), d = function () { function e(e) { this.definition = e } return e.prototype.accept = function (e) { e.visit(this), i.forEach(this.definition, (function (t) { t.accept(e) })) }, e }(); t.AbstractProduction = d; var o = function (e) { function t(t) { var n = e.call(this, []) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), Object.defineProperty(t.prototype, "definition", { get: function () { return void 0 !== this.referencedRule ? this.referencedRule.definition : [] }, set: function (e) { }, enumerable: !0, configurable: !0 }), t.prototype.accept = function (e) { e.visit(this) }, t }(d); t.NonTerminal = o; var s = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.orgText = "", i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.Rule = s; var c = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.Flat = c; var f = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.Option = f; var l = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.RepetitionMandatory = l; var p = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.RepetitionMandatoryWithSeparator = p; var h = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.Repetition = h; var m = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.RepetitionWithSeparator = m; var E = function (e) { function t(t) { var n = e.call(this, t.definition) || this; return n.idx = 1, i.assign(n, i.pick(t, (function (e) { return void 0 !== e }))), n } return a(t, e), t }(d); t.Alternation = E; var y = function () { function e(e) { this.idx = 1, i.assign(this, i.pick(e, (function (e) { return void 0 !== e }))) } return e.prototype.accept = function (e) { e.visit(this) }, e }(); function T(e) { function t(e) { return i.map(e, T) } if (e instanceof o) return { type: "NonTerminal", name: e.nonTerminalName, idx: e.idx }; if (e instanceof c) return { type: "Flat", definition: t(e.definition) }; if (e instanceof f) return { type: "Option", idx: e.idx, definition: t(e.definition) }; if (e instanceof l) return { type: "RepetitionMandatory", name: e.name, idx: e.idx, definition: t(e.definition) }; if (e instanceof p) return { type: "RepetitionMandatoryWithSeparator", name: e.name, idx: e.idx, separator: T(new y({ terminalType: e.separator })), definition: t(e.definition) }; if (e instanceof m) return { type: "RepetitionWithSeparator", name: e.name, idx: e.idx, separator: T(new y({ terminalType: e.separator })), definition: t(e.definition) }; if (e instanceof h) return { type: "Repetition", name: e.name, idx: e.idx, definition: t(e.definition) }; if (e instanceof E) return { type: "Alternation", name: e.name, idx: e.idx, definition: t(e.definition) }; if (e instanceof y) { var n = { type: "Terminal", name: u.tokenName(e.terminalType), label: u.tokenLabel(e.terminalType), idx: e.idx }, r = e.terminalType.PATTERN; return e.terminalType.PATTERN && (n.pattern = i.isRegExp(r) ? r.source : r), n } if (e instanceof s) return { type: "Rule", name: e.name, orgText: e.orgText, definition: t(e.definition) }; throw Error("non exhaustive match") } t.Terminal = y, t.serializeGrammar = function (e) { return i.map(e, T) }, t.serializeProduction = T }, 8516: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = n(8965), i = n(9774), u = n(6460), d = n(2), o = n(3221); t.resolveGrammar = function (e) { e = r.defaults(e, { errMsgProvider: d.defaultGrammarResolverErrorProvider }); var t = new a.HashTable; return r.forEach(e.rules, (function (e) { t.put(e.name, e) })), i.resolveGrammar(t, e.errMsgProvider) }, t.validateGrammar = function (e) { return e = r.defaults(e, { errMsgProvider: d.defaultGrammarValidatorErrorProvider, ignoredIssues: {} }), u.validateGrammar(e.rules, e.maxLookahead, e.tokenTypes, e.ignoredIssues, e.errMsgProvider, e.grammarName) }, t.assignOccurrenceIndices = function (e) { r.forEach(e.rules, (function (e) { var t = new o.DslMethodsCollectorVisitor; e.accept(t), r.forEach(t.dslMethods, (function (e) { r.forEach(e, (function (e, t) { e.idx = t + 1 })) })) })) } }, 3375: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(7611), a = function () { function e() { } return e.prototype.visit = function (e) { if (e instanceof r.NonTerminal) return this.visitNonTerminal(e); if (e instanceof r.Flat) return this.visitFlat(e); if (e instanceof r.Option) return this.visitOption(e); if (e instanceof r.RepetitionMandatory) return this.visitRepetitionMandatory(e); if (e instanceof r.RepetitionMandatoryWithSeparator) return this.visitRepetitionMandatoryWithSeparator(e); if (e instanceof r.RepetitionWithSeparator) return this.visitRepetitionWithSeparator(e); if (e instanceof r.Repetition) return this.visitRepetition(e); if (e instanceof r.Alternation) return this.visitAlternation(e); if (e instanceof r.Terminal) return this.visitTerminal(e); if (e instanceof r.Rule) return this.visitRule(e); throw Error("non exhaustive match") }, e.prototype.visitNonTerminal = function (e) { }, e.prototype.visitFlat = function (e) { }, e.prototype.visitOption = function (e) { }, e.prototype.visitRepetition = function (e) { }, e.prototype.visitRepetitionMandatory = function (e) { }, e.prototype.visitRepetitionMandatoryWithSeparator = function (e) { }, e.prototype.visitRepetitionWithSeparator = function (e) { }, e.prototype.visitAlternation = function (e) { }, e.prototype.visitTerminal = function (e) { }, e.prototype.visitRule = function (e) { }, e }(); t.GAstVisitor = a }, 4784: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(8146), u = n(6382), d = n(58), o = n(2094), s = n(7611), c = function (e) { function t(t, n) { var r = e.call(this) || this; return r.topProd = t, r.path = n, r.possibleTokTypes = [], r.nextProductionName = "", r.nextProductionOccurrence = 0, r.found = !1, r.isAtEndOfPath = !1, r } return a(t, e), t.prototype.startWalking = function () { if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name) throw Error("The path does not start with the walker's top Rule!"); return this.ruleStack = u.cloneArr(this.path.ruleStack).reverse(), this.occurrenceStack = u.cloneArr(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes }, t.prototype.walk = function (t, n) { void 0 === n && (n = []), this.found || e.prototype.walk.call(this, t, n) }, t.prototype.walkProdRef = function (e, t, n) { if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) { var r = t.concat(n); this.updateExpectedNext(), this.walk(e.referencedRule, r) } }, t.prototype.updateExpectedNext = function () { u.isEmpty(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop()) }, t }(i.RestWalker); t.AbstractNextPossibleTokensWalker = c; var f = function (e) { function t(t, n) { var r = e.call(this, t, n) || this; return r.path = n, r.nextTerminalName = "", r.nextTerminalOccurrence = 0, r.nextTerminalName = d.tokenName(r.path.lastTok), r.nextTerminalOccurrence = r.path.lastTokOccurrence, r } return a(t, e), t.prototype.walkTerminal = function (e, t, n) { if (this.isAtEndOfPath && d.tokenName(e.terminalType) === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found) { var r = t.concat(n), a = new s.Flat({ definition: r }); this.possibleTokTypes = o.first(a), this.found = !0 } }, t }(c); t.NextAfterTokenWalker = f; var l = function (e) { function t(t, n) { var r = e.call(this) || this; return r.topRule = t, r.occurrence = n, r.result = { token: void 0, occurrence: void 0, isEndOfRule: void 0 }, r } return a(t, e), t.prototype.startWalking = function () { return this.walk(this.topRule), this.result }, t }(i.RestWalker); t.AbstractNextTerminalAfterProductionWalker = l; var p = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return a(t, e), t.prototype.walkMany = function (t, n, r) { if (t.idx === this.occurrence) { var a = u.first(n.concat(r)); this.result.isEndOfRule = void 0 === a, a instanceof s.Terminal && (this.result.token = a.terminalType, this.result.occurrence = a.idx) } else e.prototype.walkMany.call(this, t, n, r) }, t }(l); t.NextTerminalAfterManyWalker = p; var h = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return a(t, e), t.prototype.walkManySep = function (t, n, r) { if (t.idx === this.occurrence) { var a = u.first(n.concat(r)); this.result.isEndOfRule = void 0 === a, a instanceof s.Terminal && (this.result.token = a.terminalType, this.result.occurrence = a.idx) } else e.prototype.walkManySep.call(this, t, n, r) }, t }(l); t.NextTerminalAfterManySepWalker = h; var m = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return a(t, e), t.prototype.walkAtLeastOne = function (t, n, r) { if (t.idx === this.occurrence) { var a = u.first(n.concat(r)); this.result.isEndOfRule = void 0 === a, a instanceof s.Terminal && (this.result.token = a.terminalType, this.result.occurrence = a.idx) } else e.prototype.walkAtLeastOne.call(this, t, n, r) }, t }(l); t.NextTerminalAfterAtLeastOneWalker = m; var E = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return a(t, e), t.prototype.walkAtLeastOneSep = function (t, n, r) { if (t.idx === this.occurrence) { var a = u.first(n.concat(r)); this.result.isEndOfRule = void 0 === a, a instanceof s.Terminal && (this.result.token = a.terminalType, this.result.occurrence = a.idx) } else e.prototype.walkAtLeastOneSep.call(this, t, n, r) }, t }(l); function y(e, t, n, r) { var a = u.cloneArr(n); a.push(e.name); var i = u.cloneArr(r); return i.push(1), { idx: t, def: e.definition, ruleStack: a, occurrenceStack: i } } t.NextTerminalAfterAtLeastOneSepWalker = E, t.possiblePathsFrom = function e(t, n, r) { void 0 === r && (r = []), r = u.cloneArr(r); var a = [], i = 0; function d(d) { var o = e(d.concat(u.drop(t, i + 1)), n, r); return a.concat(o) } for (; r.length < n && i < t.length;) { var o = t[i]; if (o instanceof s.Flat) return d(o.definition); if (o instanceof s.NonTerminal) return d(o.definition); if (o instanceof s.Option) a = d(o.definition); else { if (o instanceof s.RepetitionMandatory) return d(o.definition); if (o instanceof s.RepetitionMandatoryWithSeparator) return d(c = [new s.Flat({ definition: o.definition }), new s.Repetition({ definition: [new s.Terminal({ terminalType: o.separator })].concat(o.definition) })]); if (o instanceof s.RepetitionWithSeparator) { var c = o.definition.concat([new s.Repetition({ definition: [new s.Terminal({ terminalType: o.separator })].concat(o.definition) })]); a = d(c) } else if (o instanceof s.Repetition) a = d(o.definition); else { if (o instanceof s.Alternation) return u.forEach(o.definition, (function (e) { a = d(e.definition) })), a; if (!(o instanceof s.Terminal)) throw Error("non exhaustive match"); r.push(o.terminalType) } } i++ } return a.push({ partialPath: r, suffixDef: u.drop(t, i) }), a }, t.nextPossibleTokensAfter = function (e, t, n, r) { var a = "EXIT_NONE_TERMINAL", i = [a], d = "EXIT_ALTERNATIVE", o = !1, c = t.length, f = c - r - 1, l = [], p = []; for (p.push({ idx: -1, def: e, ruleStack: [], occurrenceStack: [] }); !u.isEmpty(p);) { var h = p.pop(); if (h !== d) { var m = h.def, E = h.idx, T = h.ruleStack, S = h.occurrenceStack; if (!u.isEmpty(m)) { var v = m[0]; if (v === a) { var R = { idx: E, def: u.drop(m), ruleStack: u.dropRight(T), occurrenceStack: u.dropRight(S) }; p.push(R) } else if (v instanceof s.Terminal) if (E < c - 1) { var L = E + 1; n(t[L], v.terminalType) && (R = { idx: L, def: u.drop(m), ruleStack: T, occurrenceStack: S }, p.push(R)) } else { if (E !== c - 1) throw Error("non exhaustive match"); l.push({ nextTokenType: v.terminalType, nextTokenOccurrence: v.idx, ruleStack: T, occurrenceStack: S }), o = !0 } else if (v instanceof s.NonTerminal) { var A = u.cloneArr(T); A.push(v.nonTerminalName); var O = u.cloneArr(S); O.push(v.idx), R = { idx: E, def: v.definition.concat(i, u.drop(m)), ruleStack: A, occurrenceStack: O }, p.push(R) } else if (v instanceof s.Option) { var b = { idx: E, def: u.drop(m), ruleStack: T, occurrenceStack: S }; p.push(b), p.push(d); var I = { idx: E, def: v.definition.concat(u.drop(m)), ruleStack: T, occurrenceStack: S }; p.push(I) } else if (v instanceof s.RepetitionMandatory) { var N = new s.Repetition({ definition: v.definition, idx: v.idx }); R = { idx: E, def: v.definition.concat([N], u.drop(m)), ruleStack: T, occurrenceStack: S }, p.push(R) } else if (v instanceof s.RepetitionMandatoryWithSeparator) { var g = new s.Terminal({ terminalType: v.separator }); N = new s.Repetition({ definition: [g].concat(v.definition), idx: v.idx }), R = { idx: E, def: v.definition.concat([N], u.drop(m)), ruleStack: T, occurrenceStack: S }, p.push(R) } else if (v instanceof s.RepetitionWithSeparator) { b = { idx: E, def: u.drop(m), ruleStack: T, occurrenceStack: S }, p.push(b), p.push(d), g = new s.Terminal({ terminalType: v.separator }); var _ = new s.Repetition({ definition: [g].concat(v.definition), idx: v.idx }); I = { idx: E, def: v.definition.concat([_], u.drop(m)), ruleStack: T, occurrenceStack: S }, p.push(I) } else if (v instanceof s.Repetition) b = { idx: E, def: u.drop(m), ruleStack: T, occurrenceStack: S }, p.push(b), p.push(d), _ = new s.Repetition({ definition: v.definition, idx: v.idx }), I = { idx: E, def: v.definition.concat([_], u.drop(m)), ruleStack: T, occurrenceStack: S }, p.push(I); else if (v instanceof s.Alternation) for (var U = v.definition.length - 1; U >= 0; U--) { var C = { idx: E, def: v.definition[U].definition.concat(u.drop(m)), ruleStack: T, occurrenceStack: S }; p.push(C), p.push(d) } else if (v instanceof s.Flat) p.push({ idx: E, def: v.definition.concat(u.drop(m)), ruleStack: T, occurrenceStack: S }); else { if (!(v instanceof s.Rule)) throw Error("non exhaustive match"); p.push(y(v, E, T, S)) } } } else o && u.last(p).idx <= f && p.pop() } return l } }, 4445: (e, t) => { function n(e, t, n) { return n | t | e } Object.defineProperty(t, "__esModule", { value: !0 }), t.BITS_FOR_METHOD_IDX = 4, t.BITS_FOR_OCCURRENCE_IDX = 4, t.BITS_FOR_RULE_IDX = 24, t.BITS_FOR_ALT_IDX = 8, t.OR_IDX = 1 << t.BITS_FOR_METHOD_IDX, t.OPTION_IDX = 2 << t.BITS_FOR_METHOD_IDX, t.MANY_IDX = 3 << t.BITS_FOR_METHOD_IDX, t.AT_LEAST_ONE_IDX = 4 << t.BITS_FOR_METHOD_IDX, t.MANY_SEP_IDX = 5 << t.BITS_FOR_METHOD_IDX, t.AT_LEAST_ONE_SEP_IDX = 6 << t.BITS_FOR_METHOD_IDX, t.getKeyForAutomaticLookahead = n; var r = 32 - t.BITS_FOR_ALT_IDX; t.getKeyForAltIndex = function (e, t, a, i) { var u = i + 1 << r; return n(e, t, a) | u } }, 5123: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i, u = n(6382), d = n(4784), o = n(8146), s = n(4291), c = n(7611), f = n(3375); !function (e) { e[e.OPTION = 0] = "OPTION", e[e.REPETITION = 1] = "REPETITION", e[e.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", e[e.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", e[e.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", e[e.ALTERNATION = 5] = "ALTERNATION" }(i = t.PROD_TYPE || (t.PROD_TYPE = {})), t.getProdType = function (e) { if (e instanceof c.Option) return i.OPTION; if (e instanceof c.Repetition) return i.REPETITION; if (e instanceof c.RepetitionMandatory) return i.REPETITION_MANDATORY; if (e instanceof c.RepetitionMandatoryWithSeparator) return i.REPETITION_MANDATORY_WITH_SEPARATOR; if (e instanceof c.RepetitionWithSeparator) return i.REPETITION_WITH_SEPARATOR; if (e instanceof c.Alternation) return i.ALTERNATION; throw Error("non exhaustive match") }, t.buildLookaheadFuncForOr = function (e, t, n, r, a, i) { var u = m(e, t, n); return i(u, r, T(u) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher, a) }, t.buildLookaheadFuncForOptionalProd = function (e, t, n, r, a, i) { var u = E(e, t, a, n), d = T(u) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher; return i(u[0], d, r) }, t.buildAlternativesLookAheadFunc = function (e, t, n, r) { var a = e.length, i = u.every(e, (function (e) { return u.every(e, (function (e) { return 1 === e.length })) })); if (t) return function (t) { for (var r = u.map(t, (function (e) { return e.GATE })), i = 0; i < a; i++) { var d = e[i], o = d.length, s = r[i]; if (void 0 === s || !1 !== s.call(this)) e: for (var c = 0; c < o; c++) { for (var f = d[c], l = f.length, p = 0; p < l; p++) { var h = this.LA(p + 1); if (!1 === n(h, f[p])) continue e } return i } } }; if (i && !r) { var d = u.map(e, (function (e) { return u.flatten(e) })), o = u.reduce(d, (function (e, t, n) { return u.forEach(t, (function (t) { u.has(e, t.tokenTypeIdx) || (e[t.tokenTypeIdx] = n), u.forEach(t.categoryMatches, (function (t) { u.has(e, t) || (e[t] = n) })) })), e }), []); return function () { var e = this.LA(1); return o[e.tokenTypeIdx] } } return function () { for (var t = 0; t < a; t++) { var r = e[t], i = r.length; e: for (var u = 0; u < i; u++) { for (var d = r[u], o = d.length, s = 0; s < o; s++) { var c = this.LA(s + 1); if (!1 === n(c, d[s])) continue e } return t } } } }, t.buildSingleAlternativeLookaheadFunction = function (e, t, n) { var r = u.every(e, (function (e) { return 1 === e.length })), a = e.length; if (r && !n) { var i = u.flatten(e); if (1 === i.length && u.isEmpty(i[0].categoryMatches)) { var d = i[0].tokenTypeIdx; return function () { return this.LA(1).tokenTypeIdx === d } } var o = u.reduce(i, (function (e, t, n) { return e[t.tokenTypeIdx] = !0, u.forEach(t.categoryMatches, (function (t) { e[t] = !0 })), e }), []); return function () { var e = this.LA(1); return !0 === o[e.tokenTypeIdx] } } return function () { e: for (var n = 0; n < a; n++) { for (var r = e[n], i = r.length, u = 0; u < i; u++) { var d = this.LA(u + 1); if (!1 === t(d, r[u])) continue e } return !0 } return !1 } }; var l = function (e) { function t(t, n, r) { var a = e.call(this) || this; return a.topProd = t, a.targetOccurrence = n, a.targetProdType = r, a } return a(t, e), t.prototype.startWalking = function () { return this.walk(this.topProd), this.restDef }, t.prototype.checkIsTarget = function (e, t, n, r) { return e.idx === this.targetOccurrence && this.targetProdType === t && (this.restDef = n.concat(r), !0) }, t.prototype.walkOption = function (t, n, r) { this.checkIsTarget(t, i.OPTION, n, r) || e.prototype.walkOption.call(this, t, n, r) }, t.prototype.walkAtLeastOne = function (t, n, r) { this.checkIsTarget(t, i.REPETITION_MANDATORY, n, r) || e.prototype.walkOption.call(this, t, n, r) }, t.prototype.walkAtLeastOneSep = function (t, n, r) { this.checkIsTarget(t, i.REPETITION_MANDATORY_WITH_SEPARATOR, n, r) || e.prototype.walkOption.call(this, t, n, r) }, t.prototype.walkMany = function (t, n, r) { this.checkIsTarget(t, i.REPETITION, n, r) || e.prototype.walkOption.call(this, t, n, r) }, t.prototype.walkManySep = function (t, n, r) { this.checkIsTarget(t, i.REPETITION_WITH_SEPARATOR, n, r) || e.prototype.walkOption.call(this, t, n, r) }, t }(o.RestWalker), p = function (e) { function t(t, n) { var r = e.call(this) || this; return r.targetOccurrence = t, r.targetProdType = n, r.result = [], r } return a(t, e), t.prototype.checkIsTarget = function (e, t) { e.idx === this.targetOccurrence && this.targetProdType === t && (this.result = e.definition) }, t.prototype.visitOption = function (e) { this.checkIsTarget(e, i.OPTION) }, t.prototype.visitRepetition = function (e) { this.checkIsTarget(e, i.REPETITION) }, t.prototype.visitRepetitionMandatory = function (e) { this.checkIsTarget(e, i.REPETITION_MANDATORY) }, t.prototype.visitRepetitionMandatoryWithSeparator = function (e) { this.checkIsTarget(e, i.REPETITION_MANDATORY_WITH_SEPARATOR) }, t.prototype.visitRepetitionWithSeparator = function (e) { this.checkIsTarget(e, i.REPETITION_WITH_SEPARATOR) }, t.prototype.visitAlternation = function (e) { this.checkIsTarget(e, i.ALTERNATION) }, t }(f.GAstVisitor); function h(e, t) { function n(e, t) { return u.reduce(e, (function (e, n, r) { if (r !== t) { var a = u.map(n, (function (e) { return e.partialPath })); return e.concat(a) } return e }), []) } function r(e, t) { return void 0 === u.find(e, (function (e) { return u.every(t, (function (t, n) { return t === e[n] })) })) } function a(e) { for (var t = [], n = 0; n < e; n++)t.push([]); return t } for (var i = u.map(e, (function (e) { return d.possiblePathsFrom([e], 1) })), o = a(i.length), s = i, c = 1; c <= t; c++) { var f = s; s = a(f.length); for (var l = 0; l < f.length; l++)for (var p = f[l], h = n(f, l), m = 0; m < p.length; m++) { var E = p[m].partialPath, T = p[m].suffixDef; if (r(h, E) || u.isEmpty(T) || E.length === t) { var S = o[l]; y(S, E) || S.push(E) } else { var v = d.possiblePathsFrom(T, c + 1, E); s[l] = s[l].concat(v) } } } return o } function m(e, t, n) { var r = new p(e, i.ALTERNATION); return t.accept(r), h(r.result, n) } function E(e, t, n, r) { var a = new p(e, n); t.accept(a); var i = a.result, u = new l(t, e, n).startWalking(); return h([new c.Flat({ definition: i }), new c.Flat({ definition: u })], r) } function y(e, t) { return void 0 !== u.find(e, (function (e) { return t.length === e.length && u.every(t, (function (t, n) { return t === e[n] })) })) } function T(e) { return u.every(e, (function (e) { return u.every(e, (function (e) { return u.every(e, (function (e) { return u.isEmpty(e.categoryMatches) })) })) })) } t.lookAheadSequenceFromAlternatives = h, t.getLookaheadPathsForOr = m, t.getLookaheadPathsForOptionalProd = E, t.containsPath = y, t.isStrictPrefixOfPath = function (e, t) { return e.length < t.length && u.every(e, (function (e, n) { return e === t[n] })) }, t.areTokenCategoriesNotUsed = T }, 9774: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(5391), u = n(6382), d = n(3375); t.resolveGrammar = function (e, t) { var n = new o(e, t); return n.resolveRefs(), n.errors }; var o = function (e) { function t(t, n) { var r = e.call(this) || this; return r.nameToTopRule = t, r.errMsgProvider = n, r.errors = [], r } return a(t, e), t.prototype.resolveRefs = function () { var e = this; u.forEach(this.nameToTopRule.values(), (function (t) { e.currTopLevel = t, t.accept(e) })) }, t.prototype.visitNonTerminal = function (e) { var t = this.nameToTopRule.get(e.nonTerminalName); if (t) e.referencedRule = t; else { var n = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e); this.errors.push({ message: n, type: i.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF, ruleName: this.currTopLevel.name, unresolvedRefName: e.nonTerminalName }) } }, t }(d.GAstVisitor); t.GastRefResolverVisitor = o }, 8146: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = n(7611), i = function () { function e() { } return e.prototype.walk = function (e, t) { var n = this; void 0 === t && (t = []), r.forEach(e.definition, (function (i, u) { var d = r.drop(e.definition, u + 1); if (i instanceof a.NonTerminal) n.walkProdRef(i, d, t); else if (i instanceof a.Terminal) n.walkTerminal(i, d, t); else if (i instanceof a.Flat) n.walkFlat(i, d, t); else if (i instanceof a.Option) n.walkOption(i, d, t); else if (i instanceof a.RepetitionMandatory) n.walkAtLeastOne(i, d, t); else if (i instanceof a.RepetitionMandatoryWithSeparator) n.walkAtLeastOneSep(i, d, t); else if (i instanceof a.RepetitionWithSeparator) n.walkManySep(i, d, t); else if (i instanceof a.Repetition) n.walkMany(i, d, t); else { if (!(i instanceof a.Alternation)) throw Error("non exhaustive match"); n.walkOr(i, d, t) } })) }, e.prototype.walkTerminal = function (e, t, n) { }, e.prototype.walkProdRef = function (e, t, n) { }, e.prototype.walkFlat = function (e, t, n) { var r = t.concat(n); this.walk(e, r) }, e.prototype.walkOption = function (e, t, n) { var r = t.concat(n); this.walk(e, r) }, e.prototype.walkAtLeastOne = function (e, t, n) { var r = [new a.Option({ definition: e.definition })].concat(t, n); this.walk(e, r) }, e.prototype.walkAtLeastOneSep = function (e, t, n) { var r = u(e, t, n); this.walk(e, r) }, e.prototype.walkMany = function (e, t, n) { var r = [new a.Option({ definition: e.definition })].concat(t, n); this.walk(e, r) }, e.prototype.walkManySep = function (e, t, n) { var r = u(e, t, n); this.walk(e, r) }, e.prototype.walkOr = function (e, t, n) { var i = this, u = t.concat(n); r.forEach(e.definition, (function (e) { var t = new a.Flat({ definition: [e] }); i.walk(t, u) })) }, e }(); function u(e, t, n) { return [new a.Option({ definition: [new a.Terminal({ terminalType: e.separator })].concat(e.definition) })].concat(t, n) } t.RestWalker = i }, 5391: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(7477), a = n(8965), i = n(6460), u = n(6382), d = n(5247), o = n(58), s = n(5123), c = n(8900), f = n(4784), l = n(7850), p = n(4291), h = n(3348), m = n(4445), E = n(3650), y = n(2), T = n(7611), S = n(8516), v = "InRuleRecoveryException"; t.END_OF_FILE = o.createTokenInstance(o.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN), Object.freeze(t.END_OF_FILE); var R, L = Object.freeze({ recoveryEnabled: !1, maxLookahead: 4, ignoredIssues: {}, dynamicTokensEnabled: !1, outputCst: !1, errorMessageProvider: y.defaultParserErrorProvider, serializedGrammar: null }), A = Object.freeze({ recoveryValueFunc: function () { }, resyncEnabled: !0 }); !function (e) { e[e.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", e[e.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", e[e.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", e[e.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", e[e.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", e[e.LEFT_RECURSION = 5] = "LEFT_RECURSION", e[e.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", e[e.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", e[e.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", e[e.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", e[e.INVALID_NESTED_RULE_NAME = 10] = "INVALID_NESTED_RULE_NAME", e[e.DUPLICATE_NESTED_NAME = 11] = "DUPLICATE_NESTED_NAME", e[e.NO_NON_EMPTY_LOOKAHEAD = 12] = "NO_NON_EMPTY_LOOKAHEAD", e[e.AMBIGUOUS_PREFIX_ALTS = 13] = "AMBIGUOUS_PREFIX_ALTS", e[e.TOO_MANY_ALTS = 14] = "TOO_MANY_ALTS" }(R = t.ParserDefinitionErrorType || (t.ParserDefinitionErrorType = {})), t.EMPTY_ALT = function (e) { return void 0 === e && (e = void 0), function () { return e } }; var O = {}, b = function () { function e(e, t, n) { if (void 0 === n && (n = L), this.resyncFollows = new a.HashTable, this.allRuleNames = [], this.lookAheadFuncsCache = [], this.gastProductionsCache = new a.HashTable, this._errors = [], this.recoveryEnabled = L.recoveryEnabled, this.dynamicTokensEnabled = L.dynamicTokensEnabled, this.maxLookahead = L.maxLookahead, this.ignoredIssues = L.ignoredIssues, this.outputCst = L.outputCst, this.serializedGrammar = L.serializedGrammar, this.errorMessageProvider = L.errorMessageProvider, this.isBackTrackingStack = [], this.className = "Parser", this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.CST_STACK = [], this.tokensMap = {}, this.firstAfterRepMap = new a.HashTable, this.definitionErrors = [], this.definedRulesNames = [], this.shortRuleNameToFull = new a.HashTable, this.fullRuleNameToShort = new a.HashTable, this.ruleShortNameIdx = 256, this.tokenMatcher = p.tokenStructuredMatcherNoCategories, this.LAST_EXPLICIT_RULE_STACK = [], this.selfAnalysisDone = !1, this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1, this.input = e, this.recoveryEnabled = u.has(n, "recoveryEnabled") ? n.recoveryEnabled : L.recoveryEnabled, this.recoveryEnabled || (this.attemptInRepetitionRecovery = u.NOOP), this.dynamicTokensEnabled = u.has(n, "dynamicTokensEnabled") ? n.dynamicTokensEnabled : L.dynamicTokensEnabled, this.maxLookahead = u.has(n, "maxLookahead") ? n.maxLookahead : L.maxLookahead, this.ignoredIssues = u.has(n, "ignoredIssues") ? n.ignoredIssues : L.ignoredIssues, this.outputCst = u.has(n, "outputCst") ? n.outputCst : L.outputCst, this.errorMessageProvider = u.defaults(n.errorMessageProvider, L.errorMessageProvider), this.serializedGrammar = u.has(n, "serializedGrammar") ? n.serializedGrammar : L.serializedGrammar, this.outputCst || (this.cstInvocationStateUpdate = u.NOOP, this.cstFinallyStateUpdate = u.NOOP, this.cstPostTerminal = u.NOOP, this.cstPostNonTerminal = u.NOOP, this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst, this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst, this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst, this.manyInternal = this.manyInternalNoCst, this.orInternal = this.orInternalNoCst, this.optionInternal = this.optionInternalNoCst, this.atLeastOneInternal = this.atLeastOneInternalNoCst, this.manySepFirstInternal = this.manySepFirstInternalNoCst, this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst), this.className = a.classNameFromInstance(this), u.isArray(t)) this.tokensMap = u.reduce(t, (function (e, t) { return e[o.tokenName(t)] = t, e }), {}); else if (u.has(t, "modes") && u.every(u.flatten(u.values(t.modes)), p.isTokenType)) { var r = u.flatten(u.values(t.modes)), i = u.uniq(r); this.tokensMap = u.reduce(i, (function (e, t) { return e[o.tokenName(t)] = t, e }), {}) } else { if (!u.isObject(t)) throw new Error("<tokensDictionary> argument must be An Array of Token constructors A dictionary of Token constructors or an IMultiModeLexerDefinition"); this.tokensMap = u.cloneObj(t) } var d = u.every(u.values(t), (function (e) { return u.isEmpty(e.categoryMatches) })); this.tokenMatcher = d ? p.tokenStructuredMatcherNoCategories : p.tokenStructuredMatcher, this.tokensMap.EOF = o.EOF, p.augmentTokenTypes(u.values(this.tokensMap)) } return e.performSelfAnalysis = function (e) { e.performSelfAnalysis() }, e.prototype.performSelfAnalysis = function () { var t, n = this; this.selfAnalysisDone = !0; var r = a.classNameFromInstance(this), i = this.gastProductionsCache; if (this.serializedGrammar) { var o = c.deserializeGrammar(this.serializedGrammar, this.tokensMap); u.forEach(o, (function (e) { n.gastProductionsCache.put(e.name, e) })) } var s = S.resolveGrammar({ rules: i.values() }); if (this.definitionErrors.push.apply(this.definitionErrors, s), u.isEmpty(s)) { var f = S.validateGrammar({ rules: i.values(), maxLookahead: this.maxLookahead, tokenTypes: u.values(this.tokensMap), ignoredIssues: this.ignoredIssues, errMsgProvider: y.defaultGrammarValidatorErrorProvider, grammarName: r }); this.definitionErrors.push.apply(this.definitionErrors, f) } if (u.isEmpty(this.definitionErrors)) { var l = d.computeAllProdsFollows(i.values()); this.resyncFollows = l } var p = h.analyzeCst(i.values(), this.fullRuleNameToShort); if (this.allRuleNames = p.allRuleNames, !e.DEFER_DEFINITION_ERRORS_HANDLING && !u.isEmpty(this.definitionErrors)) throw t = u.map(this.definitionErrors, (function (e) { return e.message })), new Error("Parser Definition Errors detected:\n " + t.join("\n-------------------------------\n")) }, Object.defineProperty(e.prototype, "errors", { get: function () { return u.cloneArr(this._errors) }, set: function (e) { this._errors = e }, enumerable: !0, configurable: !0 }), e.prototype.reset = function () { this.resetLexerState(), this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.LAST_EXPLICIT_RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [] }, e.prototype.isAtEndOfInput = function () { return this.tokenMatcher(this.LA(1), o.EOF) }, e.prototype.getBaseCstVisitorConstructor = function () { if (u.isUndefined(this.baseCstVisitorConstructor)) { var e = E.createBaseSemanticVisitorConstructor(this.className, this.allRuleNames); return this.baseCstVisitorConstructor = e, e } return this.baseCstVisitorConstructor }, e.prototype.getBaseCstVisitorConstructorWithDefaults = function () { if (u.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) { var e = E.createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor()); return this.baseCstVisitorWithDefaultsConstructor = e, e } return this.baseCstVisitorWithDefaultsConstructor }, e.prototype.getGAstProductions = function () { return this.gastProductionsCache }, e.prototype.getSerializedGastProductions = function () { return T.serializeGrammar(this.gastProductionsCache.values()) }, e.prototype.computeContentAssist = function (e, t) { var n = this.gastProductionsCache.get(e); if (u.isUndefined(n)) throw Error("Rule ->" + e + "<- does not exist in this grammar."); return f.nextPossibleTokensAfter([n], t, this.tokenMatcher, this.maxLookahead) }, e.prototype.BACKTRACK = function (e, t) { return function () { this.isBackTrackingStack.push(1); var n = this.saveRecogState(); try { return e.apply(this, t), !0 } catch (e) { if (r.isRecognitionException(e)) return !1; throw e } finally { this.reloadRecogState(n), this.isBackTrackingStack.pop() } } }, e.prototype.SAVE_ERROR = function (e) { if (r.isRecognitionException(e)) return e.context = { ruleStack: this.getHumanReadableRuleStack(), ruleOccurrenceStack: u.cloneArr(this.RULE_OCCURRENCE_STACK) }, this._errors.push(e), e; throw Error("Trying to save an Error which is not a RecognitionException") }, e.prototype.isBackTracking = function () { return !u.isEmpty(this.isBackTrackingStack) }, e.prototype.getCurrRuleFullName = function () { var e = this.getLastExplicitRuleShortName(); return this.shortRuleNameToFull.get(e) }, e.prototype.shortRuleNameToFullName = function (e) { return this.shortRuleNameToFull.get(e) }, e.prototype.getHumanReadableRuleStack = function () { var e = this; return u.isEmpty(this.LAST_EXPLICIT_RULE_STACK) ? u.map(this.RULE_STACK, (function (t) { return e.shortRuleNameToFullName(t) })) : u.map(this.LAST_EXPLICIT_RULE_STACK, (function (t) { return e.shortRuleNameToFullName(e.RULE_STACK[t]) })) }, e.prototype.CONSUME = function (e, t) { return this.consumeInternal(e, 0, t) }, e.prototype.CONSUME1 = function (e, t) { return this.consumeInternal(e, 1, t) }, e.prototype.CONSUME2 = function (e, t) { return this.consumeInternal(e, 2, t) }, e.prototype.CONSUME3 = function (e, t) { return this.consumeInternal(e, 3, t) }, e.prototype.CONSUME4 = function (e, t) { return this.consumeInternal(e, 4, t) }, e.prototype.CONSUME5 = function (e, t) { return this.consumeInternal(e, 5, t) }, e.prototype.CONSUME6 = function (e, t) { return this.consumeInternal(e, 6, t) }, e.prototype.CONSUME7 = function (e, t) { return this.consumeInternal(e, 7, t) }, e.prototype.CONSUME8 = function (e, t) { return this.consumeInternal(e, 8, t) }, e.prototype.CONSUME9 = function (e, t) { return this.consumeInternal(e, 9, t) }, e.prototype.SUBRULE = function (e, t) { return this.subruleInternal(e, 0, t) }, e.prototype.SUBRULE1 = function (e, t) { return this.subruleInternal(e, 1, t) }, e.prototype.SUBRULE2 = function (e, t) { return this.subruleInternal(e, 2, t) }, e.prototype.SUBRULE3 = function (e, t) { return this.subruleInternal(e, 3, t) }, e.prototype.SUBRULE4 = function (e, t) { return this.subruleInternal(e, 4, t) }, e.prototype.SUBRULE5 = function (e, t) { return this.subruleInternal(e, 5, t) }, e.prototype.SUBRULE6 = function (e, t) { return this.subruleInternal(e, 6, t) }, e.prototype.SUBRULE7 = function (e, t) { return this.subruleInternal(e, 7, t) }, e.prototype.SUBRULE8 = function (e, t) { return this.subruleInternal(e, 8, t) }, e.prototype.SUBRULE9 = function (e, t) { return this.subruleInternal(e, 9, t) }, e.prototype.OPTION = function (e) { return this.optionInternal(e, 0) }, e.prototype.OPTION1 = function (e) { return this.optionInternal(e, 1) }, e.prototype.OPTION2 = function (e) { return this.optionInternal(e, 2) }, e.prototype.OPTION3 = function (e) { return this.optionInternal(e, 3) }, e.prototype.OPTION4 = function (e) { return this.optionInternal(e, 4) }, e.prototype.OPTION5 = function (e) { return this.optionInternal(e, 5) }, e.prototype.OPTION6 = function (e) { return this.optionInternal(e, 6) }, e.prototype.OPTION7 = function (e) { return this.optionInternal(e, 7) }, e.prototype.OPTION8 = function (e) { return this.optionInternal(e, 8) }, e.prototype.OPTION9 = function (e) { return this.optionInternal(e, 9) }, e.prototype.OR = function (e) { return this.orInternal(e, 0) }, e.prototype.OR1 = function (e) { return this.orInternal(e, 1) }, e.prototype.OR2 = function (e) { return this.orInternal(e, 2) }, e.prototype.OR3 = function (e) { return this.orInternal(e, 3) }, e.prototype.OR4 = function (e) { return this.orInternal(e, 4) }, e.prototype.OR5 = function (e) { return this.orInternal(e, 5) }, e.prototype.OR6 = function (e) { return this.orInternal(e, 6) }, e.prototype.OR7 = function (e) { return this.orInternal(e, 7) }, e.prototype.OR8 = function (e) { return this.orInternal(e, 8) }, e.prototype.OR9 = function (e) { return this.orInternal(e, 9) }, e.prototype.MANY = function (e) { return this.manyInternal(0, e, []) }, e.prototype.MANY1 = function (e) { return this.manyInternal(1, e, []) }, e.prototype.MANY2 = function (e) { return this.manyInternal(2, e, []) }, e.prototype.MANY3 = function (e) { return this.manyInternal(3, e, []) }, e.prototype.MANY4 = function (e) { return this.manyInternal(4, e, []) }, e.prototype.MANY5 = function (e) { return this.manyInternal(5, e, []) }, e.prototype.MANY6 = function (e) { return this.manyInternal(6, e, []) }, e.prototype.MANY7 = function (e) { return this.manyInternal(7, e, []) }, e.prototype.MANY8 = function (e) { return this.manyInternal(8, e, []) }, e.prototype.MANY9 = function (e) { return this.manyInternal(9, e, []) }, e.prototype.MANY_SEP = function (e) { return this.manySepFirstInternal(0, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP1 = function (e) { return this.manySepFirstInternal(1, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP2 = function (e) { return this.manySepFirstInternal(2, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP3 = function (e) { return this.manySepFirstInternal(3, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP4 = function (e) { return this.manySepFirstInternal(4, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP5 = function (e) { return this.manySepFirstInternal(5, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP6 = function (e) { return this.manySepFirstInternal(6, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP7 = function (e) { return this.manySepFirstInternal(7, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP8 = function (e) { return this.manySepFirstInternal(8, e, { values: [], separators: [] }) }, e.prototype.MANY_SEP9 = function (e) { return this.manySepFirstInternal(9, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE = function (e) { return this.atLeastOneInternal(0, e, []) }, e.prototype.AT_LEAST_ONE1 = function (e) { return this.atLeastOneInternal(1, e, []) }, e.prototype.AT_LEAST_ONE2 = function (e) { return this.atLeastOneInternal(2, e, []) }, e.prototype.AT_LEAST_ONE3 = function (e) { return this.atLeastOneInternal(3, e, []) }, e.prototype.AT_LEAST_ONE4 = function (e) { return this.atLeastOneInternal(4, e, []) }, e.prototype.AT_LEAST_ONE5 = function (e) { return this.atLeastOneInternal(5, e, []) }, e.prototype.AT_LEAST_ONE6 = function (e) { return this.atLeastOneInternal(6, e, []) }, e.prototype.AT_LEAST_ONE7 = function (e) { return this.atLeastOneInternal(7, e, []) }, e.prototype.AT_LEAST_ONE8 = function (e) { return this.atLeastOneInternal(8, e, []) }, e.prototype.AT_LEAST_ONE9 = function (e) { return this.atLeastOneInternal(9, e, []) }, e.prototype.AT_LEAST_ONE_SEP = function (e) { return this.atLeastOneSepFirstInternal(0, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP1 = function (e) { return this.atLeastOneSepFirstInternal(1, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP2 = function (e) { return this.atLeastOneSepFirstInternal(2, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP3 = function (e) { return this.atLeastOneSepFirstInternal(3, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP4 = function (e) { return this.atLeastOneSepFirstInternal(4, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP5 = function (e) { return this.atLeastOneSepFirstInternal(5, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP6 = function (e) { return this.atLeastOneSepFirstInternal(6, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP7 = function (e) { return this.atLeastOneSepFirstInternal(7, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP8 = function (e) { return this.atLeastOneSepFirstInternal(8, e, { values: [], separators: [] }) }, e.prototype.AT_LEAST_ONE_SEP9 = function (e) { return this.atLeastOneSepFirstInternal(9, e, { values: [], separators: [] }) }, e.prototype.RULE = function (e, t, n) { if (void 0 === n && (n = A), u.contains(this.definedRulesNames, e)) { var r = { message: y.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({ topLevelRule: e, grammarName: this.className }), type: R.DUPLICATE_RULE_NAME, ruleName: e }; this.definitionErrors.push(r) } if (this.definedRulesNames.push(e), !this.gastProductionsCache.containsKey(e) && !this.serializedGrammar) { var a = c.buildTopProduction(t.toString(), e, this.tokensMap); this.gastProductionsCache.put(e, a) } var i = this.defineRule(e, t, n); return this[e] = i, i }, e.prototype.OVERRIDE_RULE = function (e, t, n) { void 0 === n && (n = A); var r = []; if (r = r.concat(i.validateRuleIsOverridden(e, this.definedRulesNames, this.className)), this.definitionErrors.push.apply(this.definitionErrors, r), !this.serializedGrammar) { var a = c.buildTopProduction(t.toString(), e, this.tokensMap); this.gastProductionsCache.put(e, a) } var u = this.defineRule(e, t, n); return this[e] = u, u }, e.prototype.getTokenToInsert = function (e) { var t = o.createTokenInstance(e, "", NaN, NaN, NaN, NaN, NaN, NaN); return t.isInsertedInRecovery = !0, t }, e.prototype.canTokenTypeBeInsertedInRecovery = function (e) { return !0 }, e.prototype.ruleInvocationStateUpdate = function (e, t, n) { this.RULE_OCCURRENCE_STACK.push(n), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(t, e) }, e.prototype.ruleFinallyStateUpdate = function () { if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), 0 === this.RULE_STACK.length && !this.isAtEndOfInput()) { var e = this.LA(1), t = this.errorMessageProvider.buildNotAllInputParsedMessage({ firstRedundant: e, ruleName: this.getCurrRuleFullName() }); this.SAVE_ERROR(new r.NotAllInputParsedException(t, e)) } }, e.prototype.nestedRuleInvocationStateUpdate = function (e, t) { this.RULE_OCCURRENCE_STACK.push(1), this.RULE_STACK.push(t), this.cstNestedInvocationStateUpdate(e, t) }, e.prototype.nestedRuleFinallyStateUpdate = function () { this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstNestedFinallyStateUpdate() }, e.prototype.getCurrentGrammarPath = function (e, t) { return { ruleStack: this.getHumanReadableRuleStack(), occurrenceStack: u.cloneArr(this.RULE_OCCURRENCE_STACK), lastTok: e, lastTokOccurrence: t } }, e.prototype.getNextPossibleTokenTypes = function (e) { var t = u.first(e.ruleStack), n = this.getGAstProductions().get(t); return new f.NextAfterTokenWalker(n, e).startWalking() }, e.prototype.subruleInternal = function (e, t, n) { var a; try { var i = void 0 !== n ? n.ARGS : void 0; return a = e.call(this, t, i), this.cstPostNonTerminal(a, void 0 !== n && void 0 !== n.LABEL ? n.LABEL : e.ruleName), a } catch (t) { throw r.isRecognitionException(t) && void 0 !== t.partialCstResult && (this.cstPostNonTerminal(t.partialCstResult, void 0 !== n && void 0 !== n.LABEL ? n.LABEL : e.ruleName), delete t.partialCstResult), t } }, e.prototype.consumeInternal = function (e, t, n) { var a; try { var i = this.LA(1); if (!0 !== this.tokenMatcher(i, e)) { var u, d = this.LA(0); throw u = void 0 !== n && n.ERR_MSG ? n.ERR_MSG : this.errorMessageProvider.buildMismatchTokenMessage({ expected: e, actual: i, previous: d, ruleName: this.getCurrRuleFullName() }), this.SAVE_ERROR(new r.MismatchedTokenException(u, i, d)) } this.consumeToken(), a = i } catch (n) { if (!this.recoveryEnabled || "MismatchedTokenException" !== n.name || this.isBackTracking()) throw n; var o = this.getFollowsForInRuleRecovery(e, t); try { a = this.tryInRuleRecovery(e, o) } catch (e) { throw e.name === v ? n : e } } return this.cstPostTerminal(void 0 !== n && void 0 !== n.LABEL ? n.LABEL : e.tokenName, a), a }, e.prototype.saveRecogState = function () { var e = this.errors, t = u.cloneArr(this.RULE_STACK); return { errors: e, lexerState: this.exportLexerState(), RULE_STACK: t, CST_STACK: this.CST_STACK, LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK } }, e.prototype.reloadRecogState = function (e) { this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK }, e.prototype.defineRule = function (e, t, n) { if (this.selfAnalysisDone) throw Error("Grammar rule <" + e + "> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called."); var a, i = u.has(n, "resyncEnabled") ? n.resyncEnabled : A.resyncEnabled, d = u.has(n, "recoveryValueFunc") ? n.recoveryValueFunc : A.recoveryValueFunc, o = this.ruleShortNameIdx << m.BITS_FOR_METHOD_IDX + m.BITS_FOR_OCCURRENCE_IDX; function s(e) { try { return !0 === this.outputCst ? (t.apply(this, e), this.CST_STACK[this.CST_STACK.length - 1]) : t.apply(this, e) } catch (e) { var n = 1 === this.RULE_STACK.length, a = i && !this.isBackTracking() && this.recoveryEnabled; if (r.isRecognitionException(e)) { if (a) { var u, o = this.findReSyncTokenType(); if (this.isInCurrentRuleReSyncSet(o)) return e.resyncedTokens = this.reSyncTo(o), this.outputCst ? ((u = this.CST_STACK[this.CST_STACK.length - 1]).recoveredNode = !0, u) : d(); throw this.outputCst && ((u = this.CST_STACK[this.CST_STACK.length - 1]).recoveredNode = !0, e.partialCstResult = u), e } if (n) return this.moveToTerminatedState(), d(); throw e } throw e } finally { this.ruleFinallyStateUpdate() } } return this.ruleShortNameIdx++, this.shortRuleNameToFull.put(o, e), this.fullRuleNameToShort.put(e, o), (a = function (t, n) { return void 0 === t && (t = 0), this.ruleInvocationStateUpdate(o, e, t), s.call(this, n) }).ruleName = e, a }, e.prototype.tryInRepetitionRecovery = function (e, t, n, a) { for (var i = this, d = this.findReSyncTokenType(), o = this.exportLexerState(), s = [], c = !1, f = this.LA(1), l = this.LA(1), p = function () { var e = i.LA(0), t = i.errorMessageProvider.buildMismatchTokenMessage({ expected: a, actual: f, previous: e, ruleName: i.getCurrRuleFullName() }), n = new r.MismatchedTokenException(t, f, i.LA(0)); n.resyncedTokens = u.dropRight(s), i.SAVE_ERROR(n) }; !c;) { if (this.tokenMatcher(l, a)) return void p(); if (n.call(this)) return p(), void e.apply(this, t); this.tokenMatcher(l, d) ? c = !0 : (l = this.SKIP_TOKEN(), this.addToResyncTokens(l, s)) } this.importLexerState(o) }, e.prototype.shouldInRepetitionRecoveryBeTried = function (e, t) { return void 0 !== e && void 0 !== t && !this.tokenMatcher(this.LA(1), e) && !this.isBackTracking() && !this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, t)) }, e.prototype.getFollowsForInRuleRecovery = function (e, t) { var n = this.getCurrentGrammarPath(e, t); return this.getNextPossibleTokenTypes(n) }, e.prototype.tryInRuleRecovery = function (e, t) { if (this.canRecoverWithSingleTokenInsertion(e, t)) return this.getTokenToInsert(e); if (this.canRecoverWithSingleTokenDeletion(e)) { var n = this.SKIP_TOKEN(); return this.consumeToken(), n } throw new I("sad sad panda") }, e.prototype.canPerformInRuleRecovery = function (e, t) { return this.canRecoverWithSingleTokenInsertion(e, t) || this.canRecoverWithSingleTokenDeletion(e) }, e.prototype.canRecoverWithSingleTokenInsertion = function (e, t) { var n = this; if (!this.canTokenTypeBeInsertedInRecovery(e)) return !1; if (u.isEmpty(t)) return !1; var r = this.LA(1); return void 0 !== u.find(t, (function (e) { return n.tokenMatcher(r, e) })) }, e.prototype.canRecoverWithSingleTokenDeletion = function (e) { return this.tokenMatcher(this.LA(2), e) }, e.prototype.isInCurrentRuleReSyncSet = function (e) { var t = this.getCurrFollowKey(), n = this.getFollowSetFromFollowKey(t); return u.contains(n, e) }, e.prototype.findReSyncTokenType = function () { for (var e = this.flattenFollowSet(), t = this.LA(1), n = 2; ;) { var r = t.tokenType; if (u.contains(e, r)) return r; t = this.LA(n), n++ } }, e.prototype.getCurrFollowKey = function () { if (1 === this.RULE_STACK.length) return O; var e = this.getLastExplicitRuleShortName(), t = this.getLastExplicitRuleOccurrenceIndex(), n = this.getPreviousExplicitRuleShortName(); return { ruleName: this.shortRuleNameToFullName(e), idxInCallingRule: t, inRule: this.shortRuleNameToFullName(n) } }, e.prototype.buildFullFollowKeyStack = function () { var e = this, t = this.RULE_STACK, n = this.RULE_OCCURRENCE_STACK; return u.isEmpty(this.LAST_EXPLICIT_RULE_STACK) || (t = u.map(this.LAST_EXPLICIT_RULE_STACK, (function (t) { return e.RULE_STACK[t] })), n = u.map(this.LAST_EXPLICIT_RULE_STACK, (function (t) { return e.RULE_OCCURRENCE_STACK[t] }))), u.map(t, (function (r, a) { return 0 === a ? O : { ruleName: e.shortRuleNameToFullName(r), idxInCallingRule: n[a], inRule: e.shortRuleNameToFullName(t[a - 1]) } })) }, e.prototype.flattenFollowSet = function () { var e = this, t = u.map(this.buildFullFollowKeyStack(), (function (t) { return e.getFollowSetFromFollowKey(t) })); return u.flatten(t) }, e.prototype.getFollowSetFromFollowKey = function (e) { if (e === O) return [o.EOF]; var t = e.ruleName + e.idxInCallingRule + l.IN + e.inRule; return this.resyncFollows.get(t) }, e.prototype.addToResyncTokens = function (e, t) { return this.tokenMatcher(e, o.EOF) || t.push(e), t }, e.prototype.reSyncTo = function (e) { for (var t = [], n = this.LA(1); !1 === this.tokenMatcher(n, e);)n = this.SKIP_TOKEN(), this.addToResyncTokens(n, t); return u.dropRight(t) }, e.prototype.attemptInRepetitionRecovery = function (e, t, n, r, a, i) { var u = this.getKeyForAutomaticLookahead(r, a), d = this.firstAfterRepMap.get(u); if (void 0 === d) { var s = this.getCurrRuleFullName(); d = new i(this.getGAstProductions().get(s), a).startWalking(), this.firstAfterRepMap.put(u, d) } var c = d.token, f = d.occurrence, l = d.isEndOfRule; 1 === this.RULE_STACK.length && l && void 0 === c && (c = o.EOF, f = 1), this.shouldInRepetitionRecoveryBeTried(c, f) && this.tryInRepetitionRecovery(e, t, n, c) }, e.prototype.cstNestedInvocationStateUpdate = function (e, t) { this.CST_STACK.push({ name: e, fullName: this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName()) + e, children: {} }) }, e.prototype.cstInvocationStateUpdate = function (e, t) { this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1), this.CST_STACK.push({ name: e, children: {} }) }, e.prototype.cstFinallyStateUpdate = function () { this.LAST_EXPLICIT_RULE_STACK.pop(), this.CST_STACK.pop() }, e.prototype.cstNestedFinallyStateUpdate = function () { this.CST_STACK.pop() }, e.prototype.optionInternal = function (e, t) { var n = this.getKeyForAutomaticLookahead(m.OPTION_IDX, t), r = this.nestedRuleBeforeClause(e, n); try { return this.optionInternalLogic(e, t, n) } finally { void 0 !== r && this.nestedRuleFinallyClause(n, r) } }, e.prototype.optionInternalNoCst = function (e, t) { var n = this.getKeyForAutomaticLookahead(m.OPTION_IDX, t); return this.optionInternalLogic(e, t, n) }, e.prototype.optionInternalLogic = function (e, t, n) { var r, a, i = this, u = this.getLookaheadFuncForOption(n, t); if (void 0 !== e.DEF) { if (r = e.DEF, void 0 !== (a = e.GATE)) { var d = u; u = function () { return a.call(i) && d.call(i) } } } else r = e; if (!0 === u.call(this)) return r.call(this) }, e.prototype.atLeastOneInternal = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.AT_LEAST_ONE_IDX, e), a = this.nestedRuleBeforeClause(t, r); try { return this.atLeastOneInternalLogic(e, t, n, r) } finally { void 0 !== a && this.nestedRuleFinallyClause(r, a) } }, e.prototype.atLeastOneInternalNoCst = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.AT_LEAST_ONE_IDX, e); return this.atLeastOneInternalLogic(e, t, n, r) }, e.prototype.atLeastOneInternalLogic = function (e, t, n, r) { var a, i, u = this, d = this.getLookaheadFuncForAtLeastOne(r, e); if (void 0 !== t.DEF) { if (a = t.DEF, void 0 !== (i = t.GATE)) { var o = d; d = function () { return i.call(u) && o.call(u) } } } else a = t; if (!0 !== d.call(this)) throw this.raiseEarlyExitException(e, s.PROD_TYPE.REPETITION_MANDATORY, t.ERR_MSG); for (n.push(a.call(this)); !0 === d.call(this);)n.push(a.call(this)); return this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, t, n], d, m.AT_LEAST_ONE_IDX, e, f.NextTerminalAfterAtLeastOneWalker), n }, e.prototype.atLeastOneSepFirstInternal = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.AT_LEAST_ONE_SEP_IDX, e), a = this.nestedRuleBeforeClause(t, r); try { return this.atLeastOneSepFirstInternalLogic(e, t, n, r) } finally { void 0 !== a && this.nestedRuleFinallyClause(r, a) } }, e.prototype.atLeastOneSepFirstInternalNoCst = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.AT_LEAST_ONE_SEP_IDX, e); return this.atLeastOneSepFirstInternalLogic(e, t, n, r) }, e.prototype.atLeastOneSepFirstInternalLogic = function (e, t, n, r) { var a = this, i = t.DEF, u = t.SEP, d = this.getLookaheadFuncForAtLeastOneSep(r, e), o = n.values, c = n.separators; if (!0 !== d.call(this)) throw this.raiseEarlyExitException(e, s.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, t.ERR_MSG); o.push(i.call(this)); for (var l = function () { return a.tokenMatcher(a.LA(1), u) }; !0 === this.tokenMatcher(this.LA(1), u);)c.push(this.CONSUME(u)), o.push(i.call(this)); return this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, u, l, i, f.NextTerminalAfterAtLeastOneSepWalker, n], l, m.AT_LEAST_ONE_SEP_IDX, e, f.NextTerminalAfterAtLeastOneSepWalker), n }, e.prototype.manyInternal = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.MANY_IDX, e), a = this.nestedRuleBeforeClause(t, r); try { return this.manyInternalLogic(e, t, n, r) } finally { void 0 !== a && this.nestedRuleFinallyClause(r, a) } }, e.prototype.manyInternalNoCst = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.MANY_IDX, e); return this.manyInternalLogic(e, t, n, r) }, e.prototype.manyInternalLogic = function (e, t, n, r) { var a, i, u = this, d = this.getLookaheadFuncForMany(r, e); if (void 0 !== t.DEF) { if (a = t.DEF, void 0 !== (i = t.GATE)) { var o = d; d = function () { return i.call(u) && o.call(u) } } } else a = t; for (; d.call(this);)n.push(a.call(this)); return this.attemptInRepetitionRecovery(this.manyInternal, [e, t, n], d, m.MANY_IDX, e, f.NextTerminalAfterManyWalker), n }, e.prototype.manySepFirstInternal = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.MANY_SEP_IDX, e), a = this.nestedRuleBeforeClause(t, r); try { return this.manySepFirstInternalLogic(e, t, n, r) } finally { void 0 !== a && this.nestedRuleFinallyClause(r, a) } }, e.prototype.manySepFirstInternalNoCst = function (e, t, n) { var r = this.getKeyForAutomaticLookahead(m.MANY_SEP_IDX, e); return this.manySepFirstInternalLogic(e, t, n, r) }, e.prototype.manySepFirstInternalLogic = function (e, t, n, r) { var a = this, i = t.DEF, u = t.SEP, d = this.getLookaheadFuncForManySep(r, e), o = n.values, s = n.separators; if (!0 === d.call(this)) { o.push(i.call(this)); for (var c = function () { return a.tokenMatcher(a.LA(1), u) }; !0 === this.tokenMatcher(this.LA(1), u);)s.push(this.CONSUME(u)), o.push(i.call(this)); this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, u, c, i, f.NextTerminalAfterManySepWalker, n], c, m.MANY_SEP_IDX, e, f.NextTerminalAfterManySepWalker) } return n }, e.prototype.repetitionSepSecondInternal = function (e, t, n, r, a, i) { for (; n();)i.separators.push(this.CONSUME(t)), i.values.push(r.call(this)); this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, t, n, r, a, i], n, m.AT_LEAST_ONE_SEP_IDX, e, a) }, e.prototype.orInternalNoCst = function (e, t) { var n = u.isArray(e) ? e : e.DEF, r = this.getLookaheadFuncForOr(t, n).call(this, n); if (void 0 !== r) return n[r].ALT.call(this); this.raiseNoAltException(t, e.ERR_MSG) }, e.prototype.orInternal = function (e, t) { var n = this.getKeyForAutomaticLookahead(m.OR_IDX, t), r = this.nestedRuleBeforeClause(e, n); try { var a = u.isArray(e) ? e : e.DEF, i = this.getLookaheadFuncForOr(t, a).call(this, a); if (void 0 !== i) { var d = a[i], o = this.nestedAltBeforeClause(d, t, m.OR_IDX, i); try { return d.ALT.call(this) } finally { void 0 !== o && this.nestedRuleFinallyClause(o.shortName, o.nestedName) } } this.raiseNoAltException(t, e.ERR_MSG) } finally { void 0 !== r && this.nestedRuleFinallyClause(n, r) } }, e.prototype.getKeyForAutomaticLookahead = function (e, t) { var n = this.getLastExplicitRuleShortName(); return m.getKeyForAutomaticLookahead(n, e, t) }, e.prototype.getLookaheadFuncForOr = function (e, t) { var n = this.getKeyForAutomaticLookahead(m.OR_IDX, e), r = this.lookAheadFuncsCache[n]; if (void 0 === r) { var a = this.getCurrRuleFullName(), i = this.getGAstProductions().get(a), d = u.some(t, (function (e) { return u.isFunction(e.GATE) })); return r = s.buildLookaheadFuncForOr(e, i, this.maxLookahead, d, this.dynamicTokensEnabled, this.lookAheadBuilderForAlternatives), this.lookAheadFuncsCache[n] = r, r } return r }, e.prototype.getLookaheadFuncForOption = function (e, t) { return this.getLookaheadFuncFor(e, t, this.maxLookahead, s.PROD_TYPE.OPTION) }, e.prototype.getLookaheadFuncForMany = function (e, t) { return this.getLookaheadFuncFor(e, t, this.maxLookahead, s.PROD_TYPE.REPETITION) }, e.prototype.getLookaheadFuncForManySep = function (e, t) { return this.getLookaheadFuncFor(e, t, this.maxLookahead, s.PROD_TYPE.REPETITION_WITH_SEPARATOR) }, e.prototype.getLookaheadFuncForAtLeastOne = function (e, t) { return this.getLookaheadFuncFor(e, t, this.maxLookahead, s.PROD_TYPE.REPETITION_MANDATORY) }, e.prototype.getLookaheadFuncForAtLeastOneSep = function (e, t) { return this.getLookaheadFuncFor(e, t, this.maxLookahead, s.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR) }, e.prototype.raiseNoAltException = function (e, t) { for (var n = this.getCurrRuleFullName(), a = this.getGAstProductions().get(n), i = s.getLookaheadPathsForOr(e, a, this.maxLookahead), u = [], d = 1; d < this.maxLookahead; d++)u.push(this.LA(d)); var o = this.LA(0), c = this.errorMessageProvider.buildNoViableAltMessage({ expectedPathsPerAlt: i, actual: u, previous: o, customUserDescription: t, ruleName: this.getCurrRuleFullName() }); throw this.SAVE_ERROR(new r.NoViableAltException(c, this.LA(1), o)) }, e.prototype.getLookaheadFuncFor = function (e, t, n, r) { var a = this.lookAheadFuncsCache[e]; if (void 0 === a) { var i = this.getCurrRuleFullName(), u = this.getGAstProductions().get(i); return a = s.buildLookaheadFuncForOptionalProd(t, u, n, this.dynamicTokensEnabled, r, this.lookAheadBuilderForOptional), this.lookAheadFuncsCache[e] = a, a } return a }, e.prototype.raiseEarlyExitException = function (e, t, n) { for (var a = this.getCurrRuleFullName(), i = this.getGAstProductions().get(a), u = s.getLookaheadPathsForOptionalProd(e, i, t, this.maxLookahead)[0], d = [], o = 1; o < this.maxLookahead; o++)d.push(this.LA(o)); var c = this.errorMessageProvider.buildEarlyExitMessage({ expectedIterationPaths: u, actual: d, previous: this.LA(0), customUserDescription: n, ruleName: a }); throw this.SAVE_ERROR(new r.EarlyExitException(c, this.LA(1), this.LA(0))) }, e.prototype.getLastExplicitRuleShortName = function () { var e = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1]; return this.RULE_STACK[e] }, e.prototype.getLastExplicitRuleShortNameNoCst = function () { var e = this.RULE_STACK; return e[e.length - 1] }, e.prototype.getPreviousExplicitRuleShortName = function () { var e = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2]; return this.RULE_STACK[e] }, e.prototype.getPreviousExplicitRuleShortNameNoCst = function () { var e = this.RULE_STACK; return e[e.length - 2] }, e.prototype.getLastExplicitRuleOccurrenceIndex = function () { var e = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1]; return this.RULE_OCCURRENCE_STACK[e] }, e.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () { var e = this.RULE_OCCURRENCE_STACK; return e[e.length - 1] }, e.prototype.nestedRuleBeforeClause = function (e, t) { var n; return void 0 !== e.NAME ? (n = e.NAME, this.nestedRuleInvocationStateUpdate(n, t), n) : void 0 }, e.prototype.nestedAltBeforeClause = function (e, t, n, r) { var a, i = this.getLastExplicitRuleShortName(), u = m.getKeyForAltIndex(i, n, t, r); return void 0 !== e.NAME ? (a = e.NAME, this.nestedRuleInvocationStateUpdate(a, u), { shortName: u, nestedName: a }) : void 0 }, e.prototype.nestedRuleFinallyClause = function (e, t) { var n = this.CST_STACK, r = n[n.length - 1]; this.nestedRuleFinallyStateUpdate(); var a = n[n.length - 1]; h.addNoneTerminalToCst(a, t, r) }, e.prototype.cstPostTerminal = function (e, t) { var n = this.CST_STACK[this.CST_STACK.length - 1]; h.addTerminalToCst(n, t, e) }, e.prototype.cstPostNonTerminal = function (e, t) { h.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length - 1], t, e) }, Object.defineProperty(e.prototype, "input", { get: function () { return this.tokVector }, set: function (e) { this.reset(), this.tokVector = e, this.tokVectorLength = e.length }, enumerable: !0, configurable: !0 }), e.prototype.SKIP_TOKEN = function () { return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : t.END_OF_FILE }, e.prototype.LA = function (e) { return this.currIdx + e < 0 || this.tokVectorLength <= this.currIdx + e ? t.END_OF_FILE : this.tokVector[this.currIdx + e] }, e.prototype.consumeToken = function () { this.currIdx++ }, e.prototype.exportLexerState = function () { return this.currIdx }, e.prototype.importLexerState = function (e) { this.currIdx = e }, e.prototype.resetLexerState = function () { this.currIdx = -1 }, e.prototype.moveToTerminatedState = function () { this.currIdx = this.tokVector.length - 1 }, e.prototype.lookAheadBuilderForOptional = function (e, t, n) { return s.buildSingleAlternativeLookaheadFunction(e, t, n) }, e.prototype.lookAheadBuilderForAlternatives = function (e, t, n, r) { return s.buildAlternativesLookAheadFunc(e, t, n, r) }, e.NO_RESYNC = !1, e.DEFER_DEFINITION_ERRORS_HANDLING = !1, e }(); function I(e) { this.name = v, this.message = e } t.Parser = b, I.prototype = Error.prototype }, 5386: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(3084), u = n(58), d = n(9337), o = n(6382), s = n(346), c = new i.RegExpParser; function f(e) { var t = o.filter(e, (function (e) { return !o.has(e, "PATTERN") })); return { errors: o.map(t, (function (e) { return { message: "Token Type: ->" + u.tokenName(e) + "<- missing static 'PATTERN' property", type: d.LexerDefinitionErrorType.MISSING_PATTERN, tokenTypes: [e] } })), valid: o.difference(e, t) } } function l(e) { var t = o.filter(e, (function (e) { var t = e.PATTERN; return !(o.isRegExp(t) || o.isFunction(t) || o.has(t, "exec") || o.isString(t)) })); return { errors: o.map(t, (function (e) { return { message: "Token Type: ->" + u.tokenName(e) + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.", type: d.LexerDefinitionErrorType.INVALID_PATTERN, tokenTypes: [e] } })), valid: o.difference(e, t) } } t.DEFAULT_MODE = "defaultMode", t.MODES = "modes", t.SUPPORT_STICKY = "boolean" == typeof new RegExp("(?:)").sticky, t.disableSticky = function () { t.SUPPORT_STICKY = !1 }, t.enableSticky = function () { t.SUPPORT_STICKY = !0 }, t.analyzeTokenTypes = function (e, n) { n = o.defaults(n, { useSticky: t.SUPPORT_STICKY, debug: !1, safeMode: !1, positionTracking: "full", lineTerminatorCharacters: ["\r", "\n"] }); var r = o.reject(e, (function (e) { return e.PATTERN === d.Lexer.NA })), a = !1, i = o.map(r, (function (e) { var t = e.PATTERN; if (o.isRegExp(t)) { var r = t.source; return 1 === r.length && "^" !== r && "$" !== r && "." !== r ? r : 2 !== r.length || "\\" !== r[0] || o.contains(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], r[1]) ? n.useSticky ? O(t) : A(t) : r[1] } if (o.isFunction(t)) return a = !0, { exec: t }; if (o.has(t, "exec")) return a = !0, t; if ("string" == typeof t) { if (1 === t.length) return t; var i = t.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), u = new RegExp(i); return n.useSticky ? O(u) : A(u) } throw Error("non exhaustive match") })), c = o.map(r, (function (e) { return e.tokenTypeIdx })), f = o.map(r, (function (e) { var t = e.GROUP; if (t !== d.Lexer.SKIPPED) { if (o.isString(t)) return t; if (o.isUndefined(t)) return !1; throw Error("non exhaustive match") } })), l = o.map(r, (function (e) { var t = e.LONGER_ALT; if (t) return o.indexOf(r, t) })), p = o.map(r, (function (e) { return e.PUSH_MODE })), h = o.map(r, (function (e) { return o.has(e, "POP_MODE") })), m = _(n.lineTerminatorCharacters), E = o.map(r, (function (e) { return !1 })); "onlyOffset" !== n.positionTracking && (E = o.map(r, (function (e) { return o.has(e, "LINE_BREAKS") ? e.LINE_BREAKS : !1 === N(e, m) ? s.canMatchCharCode(m, e.PATTERN) : void 0 }))); var y = o.map(r, b), T = o.map(i, I), S = o.reduce(r, (function (e, t) { var n = t.GROUP; return o.isString(n) && n !== d.Lexer.SKIPPED && (e[n] = []), e }), {}), v = o.map(i, (function (e, t) { return { pattern: i[t], longerAlt: l[t], canLineTerminator: E[t], isCustom: y[t], short: T[t], group: f[t], push: p[t], pop: h[t], tokenTypeIdx: c[t], tokenType: r[t] } })); function R(e, t, n) { void 0 === e[t] && (e[t] = []), e[t].push(n) } var L = !0, g = []; return n.safeMode || (g = o.reduce(r, (function (e, t, r) { if ("string" == typeof t.PATTERN) { var a = t.PATTERN.charCodeAt(0); R(e, a, v[r]) } else if (o.isArray(t.START_CHARS_HINT)) o.forEach(t.START_CHARS_HINT, (function (t) { var n = "string" == typeof t ? t.charCodeAt(0) : t; R(e, n, v[r]) })); else if (o.isRegExp(t.PATTERN)) if (t.PATTERN.unicode) L = !1, n.ensureOptimizations && o.PRINT_ERROR(s.failedOptimizationPrefixMsg + "\tUnable to analyze < " + t.PATTERN.toString() + " > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE"); else { var i = s.getStartCodes(t.PATTERN, n.ensureOptimizations); o.isEmpty(i) && (L = !1), o.forEach(i, (function (t) { R(e, t, v[r]) })) } else n.ensureOptimizations && o.PRINT_ERROR(s.failedOptimizationPrefixMsg + "\tTokenType: <" + u.tokenName(t) + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE"), L = !1; return e }), [])), L && g.length < 65536 && (g = o.packArray(g)), { emptyGroups: S, patternIdxToConfig: v, charCodeToPatternIdxToConfig: g, hasCustom: a, canBeOptimized: L } }, t.validatePatterns = function (e, t) { var n = [], r = f(e); n = n.concat(r.errors); var a = l(r.valid), i = a.valid; return (n = (n = (n = (n = n.concat(a.errors)).concat(function (e) { var t = [], n = o.filter(e, (function (e) { return o.isRegExp(e.PATTERN) })); return (t = (t = (t = (t = t.concat(h(n))).concat(y(n))).concat(T(n))).concat(S(n))).concat(m(n)) }(i))).concat(v(i))).concat(R(i, t))).concat(L(i)) }, t.findMissingPatterns = f, t.findInvalidPatterns = l; var p = /[^\\][\$]/; function h(e) { var t = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.found = !1, t } return a(t, e), t.prototype.visitEndAnchor = function (e) { this.found = !0 }, t }(i.BaseRegExpVisitor), n = o.filter(e, (function (e) { var n = e.PATTERN; try { var r = c.pattern(n.toString()), a = new t; return a.visit(r), a.found } catch (e) { return p.test(n.source) } })); return o.map(n, (function (e) { return { message: "Unexpected RegExp Anchor Error:\n\tToken Type: ->" + u.tokenName(e) + "<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.", type: d.LexerDefinitionErrorType.EOI_ANCHOR_FOUND, tokenTypes: [e] } })) } function m(e) { var t = o.filter(e, (function (e) { return e.PATTERN.test("") })); return o.map(t, (function (e) { return { message: "Token Type: ->" + u.tokenName(e) + "<- static 'PATTERN' must not match an empty string", type: d.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN, tokenTypes: [e] } })) } t.findEndOfInputAnchor = h, t.findEmptyMatchRegExps = m; var E = /[^\\[][\^]|^\^/; function y(e) { var t = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.found = !1, t } return a(t, e), t.prototype.visitStartAnchor = function (e) { this.found = !0 }, t }(i.BaseRegExpVisitor), n = o.filter(e, (function (e) { var n = e.PATTERN; try { var r = c.pattern(n.toString()), a = new t; return a.visit(r), a.found } catch (e) { return E.test(n.source) } })); return o.map(n, (function (e) { return { message: "Unexpected RegExp Anchor Error:\n\tToken Type: ->" + u.tokenName(e) + "<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://github.com/SAP/chevrotain/blob/master/docs/resolving_lexer_errors.md#ANCHORS\n\tfor details.", type: d.LexerDefinitionErrorType.SOI_ANCHOR_FOUND, tokenTypes: [e] } })) } function T(e) { var t = o.filter(e, (function (e) { var t = e.PATTERN; return t instanceof RegExp && (t.multiline || t.global) })); return o.map(t, (function (e) { return { message: "Token Type: ->" + u.tokenName(e) + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')", type: d.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND, tokenTypes: [e] } })) } function S(e) { var t = [], n = o.map(e, (function (n) { return o.reduce(e, (function (e, r) { return n.PATTERN.source !== r.PATTERN.source || o.contains(t, r) || r.PATTERN === d.Lexer.NA || (t.push(r), e.push(r)), e }), []) })); n = o.compact(n); var r = o.filter(n, (function (e) { return e.length > 1 })); return o.map(r, (function (e) { var t = o.map(e, (function (e) { return u.tokenName(e) })); return { message: "The same RegExp pattern ->" + o.first(e).PATTERN + "<-has been used in all of the following Token Types: " + t.join(", ") + " <-", type: d.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND, tokenTypes: e } })) } function v(e) { var t = o.filter(e, (function (e) { if (!o.has(e, "GROUP")) return !1; var t = e.GROUP; return t !== d.Lexer.SKIPPED && t !== d.Lexer.NA && !o.isString(t) })); return o.map(t, (function (e) { return { message: "Token Type: ->" + u.tokenName(e) + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String", type: d.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND, tokenTypes: [e] } })) } function R(e, t) { var n = o.filter(e, (function (e) { return void 0 !== e.PUSH_MODE && !o.contains(t, e.PUSH_MODE) })); return o.map(n, (function (e) { return { message: "Token Type: ->" + u.tokenName(e) + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + e.PUSH_MODE + "<-which does not exist", type: d.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST, tokenTypes: [e] } })) } function L(e) { var t = [], n = o.reduce(e, (function (e, t, n) { var r, a, i = t.PATTERN; return i === d.Lexer.NA || (o.isString(i) ? e.push({ str: i, idx: n, tokenType: t }) : o.isRegExp(i) && (r = i, a = [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"], void 0 === o.find(a, (function (e) { return -1 !== r.source.indexOf(e) }))) && e.push({ str: i.source, idx: n, tokenType: t })), e }), []); return o.forEach(e, (function (e, r) { o.forEach(n, (function (n) { var a = n.str, i = n.idx, s = n.tokenType; if (r < i && function (e, t) { if (o.isRegExp(t)) { var n = t.exec(e); return null !== n && 0 === n.index } if (o.isFunction(t)) return t(e, 0, [], {}); if (o.has(t, "exec")) return t.exec(e, 0, [], {}); if ("string" == typeof t) return t === e; throw Error("non exhaustive match") }(a, e.PATTERN)) { var c = "Token: ->" + u.tokenName(s) + "<- can never be matched.\nBecause it appears AFTER the Token Type ->" + u.tokenName(e) + "<-in the lexer's definition.\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE"; t.push({ message: c, type: d.LexerDefinitionErrorType.UNREACHABLE_PATTERN, tokenTypes: [e, s] }) } })) })), t } function A(e) { var t = e.ignoreCase ? "i" : ""; return new RegExp("^(?:" + e.source + ")", t) } function O(e) { var t = e.ignoreCase ? "iy" : "y"; return new RegExp("" + e.source, t) } function b(e) { var t = e.PATTERN; if (o.isRegExp(t)) return !1; if (o.isFunction(t)) return !0; if (o.has(t, "exec")) return !0; if (o.isString(t)) return !1; throw Error("non exhaustive match") } function I(e) { return !(!o.isString(e) || 1 !== e.length) && e.charCodeAt(0) } function N(e, t) { if (o.has(e, "LINE_BREAKS")) return !1; if (o.isRegExp(e.PATTERN)) { try { s.canMatchCharCode(t, e.PATTERN) } catch (e) { return { issue: d.LexerDefinitionErrorType.IDENTIFY_TERMINATOR, errMsg: e.message } } return !1 } if (o.isString(e.PATTERN)) return !1; if (b(e)) return { issue: d.LexerDefinitionErrorType.CUSTOM_LINE_BREAK }; throw Error("non exhaustive match") } function g(e, t) { if (t.issue === d.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) return "Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <" + e.name + "> Token Type\n\t Root cause: " + t.errMsg + ".\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR"; if (t.issue === d.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <" + e.name + "> Token Type\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK"; throw Error("non exhaustive match") } function _(e) { return o.map(e, (function (e) { return o.isString(e) && e.length > 0 ? e.charCodeAt(0) : e })) } t.findStartOfInputAnchor = y, t.findUnsupportedFlags = T, t.findDuplicatePatterns = S, t.findInvalidGroupType = v, t.findModesThatDoNotExist = R, t.findUnreachablePatterns = L, t.addStartOfInput = A, t.addStickyFlag = O, t.performRuntimeChecks = function (e, n, r) { var a = []; return o.has(e, t.DEFAULT_MODE) || a.push({ message: "A MultiMode Lexer cannot be initialized without a <" + t.DEFAULT_MODE + "> property in its definition\n", type: d.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE }), o.has(e, t.MODES) || a.push({ message: "A MultiMode Lexer cannot be initialized without a <" + t.MODES + "> property in its definition\n", type: d.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY }), o.has(e, t.MODES) && o.has(e, t.DEFAULT_MODE) && !o.has(e.modes, e.defaultMode) && a.push({ message: "A MultiMode Lexer cannot be initialized with a " + t.DEFAULT_MODE + ": <" + e.defaultMode + ">which does not exist\n", type: d.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST }), o.has(e, t.MODES) && o.forEach(e.modes, (function (e, t) { o.forEach(e, (function (e, n) { o.isUndefined(e) && a.push({ message: "A Lexer cannot be initialized using an undefined Token Type. Mode:<" + t + "> at index: <" + n + ">\n", type: d.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED }) })) })), a }, t.performWarningRuntimeChecks = function (e, t, n) { var r = [], a = !1, i = o.compact(o.flatten(o.mapValues(e.modes, (function (e) { return e })))), u = o.reject(i, (function (e) { return e.PATTERN === d.Lexer.NA })), c = _(n); return t && o.forEach(u, (function (e) { var t = N(e, c); if (!1 !== t) { var n = { message: g(e, t), type: t.issue, tokenType: e }; r.push(n) } else o.has(e, "LINE_BREAKS") ? !0 === e.LINE_BREAKS && (a = !0) : s.canMatchCharCode(c, e.PATTERN) && (a = !0) })), t && !a && r.push({ message: "Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n\tfor details.", type: d.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS }), r }, t.cloneEmptyGroups = function (e) { var t = {}, n = o.keys(e); return o.forEach(n, (function (n) { var r = e[n]; if (!o.isArray(r)) throw Error("non exhaustive match"); t[n] = [] })), t }, t.isCustomPattern = b, t.isShortPattern = I, t.LineTerminatorOptimizedTester = { test: function (e) { for (var t = e.length, n = this.lastIndex; n < t; n++) { var r = e.charCodeAt(n); if (10 === r) return this.lastIndex = n + 1, !0; if (13 === r) return 10 === e.charCodeAt(n + 1) ? this.lastIndex = n + 2 : this.lastIndex = n + 1, !0 } return !1 }, lastIndex: 0 }, t.buildLineBreakIssueMessage = g }, 9337: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r, a = n(5386), i = n(6382), u = n(4291); (r = t.LexerDefinitionErrorType || (t.LexerDefinitionErrorType = {}))[r.MISSING_PATTERN = 0] = "MISSING_PATTERN", r[r.INVALID_PATTERN = 1] = "INVALID_PATTERN", r[r.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", r[r.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", r[r.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", r[r.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", r[r.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", r[r.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", r[r.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", r[r.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", r[r.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", r[r.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", r[r.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", r[r.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", r[r.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", r[r.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", r[r.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK"; var d = { deferDefinitionErrorsHandling: !1, positionTracking: "full", lineTerminatorsPattern: /\n|\r\n?/g, lineTerminatorCharacters: ["\n", "\r"], ensureOptimizations: !1, safeMode: !1 }; Object.freeze(d); var o = function () { function e(e, t) { void 0 === t && (t = d); var n = this; if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.config = void 0, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, "boolean" == typeof t) throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported"); if (this.config = i.merge(d, t), this.config.lineTerminatorsPattern === d.lineTerminatorsPattern) this.config.lineTerminatorsPattern = a.LineTerminatorOptimizedTester; else if (this.config.lineTerminatorCharacters === d.lineTerminatorCharacters) throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS"); if (t.safeMode && t.ensureOptimizations) throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.'); this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking); var r, o = !0; i.isArray(e) ? ((r = { modes: {} }).modes[a.DEFAULT_MODE] = i.cloneArr(e), r[a.DEFAULT_MODE] = a.DEFAULT_MODE) : (o = !1, r = i.cloneObj(e)), this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(a.performRuntimeChecks(r, this.trackStartLines, this.config.lineTerminatorCharacters)), this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(a.performWarningRuntimeChecks(r, this.trackStartLines, this.config.lineTerminatorCharacters)), r.modes = r.modes ? r.modes : {}, i.forEach(r.modes, (function (e, t) { r.modes[t] = i.reject(e, (function (e) { return i.isUndefined(e) })) })); var s = i.keys(r.modes); if (i.forEach(r.modes, (function (e, r) { if (n.modes.push(r), n.lexerDefinitionErrors = n.lexerDefinitionErrors.concat(a.validatePatterns(e, s)), i.isEmpty(n.lexerDefinitionErrors)) { u.augmentTokenTypes(e); var d = a.analyzeTokenTypes(e, { lineTerminatorCharacters: n.config.lineTerminatorCharacters, positionTracking: t.positionTracking, ensureOptimizations: t.ensureOptimizations, safeMode: t.safeMode }); n.patternIdxToConfig[r] = d.patternIdxToConfig, n.charCodeToPatternIdxToConfig[r] = d.charCodeToPatternIdxToConfig, n.emptyGroups = i.merge(n.emptyGroups, d.emptyGroups), n.hasCustom = d.hasCustom || n.hasCustom, n.canModeBeOptimized[r] = d.canBeOptimized } })), this.defaultMode = r.defaultMode, !i.isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) { var c = i.map(this.lexerDefinitionErrors, (function (e) { return e.message })).join("-----------------------\n"); throw new Error("Errors detected in definition of Lexer:\n" + c) } if (i.forEach(this.lexerDefinitionWarning, (function (e) { i.PRINT_WARNING(e.message) })), a.SUPPORT_STICKY ? (this.chopInput = i.IDENTITY, this.match = this.matchWithTest) : (this.updateLastIndex = i.NOOP, this.match = this.matchWithExec), o && (this.handleModes = i.NOOP), !1 === this.trackStartLines && (this.computeNewColumn = i.IDENTITY), !1 === this.trackEndLines && (this.updateTokenEndLineColumnLocation = i.NOOP), /full/i.test(this.config.positionTracking)) this.createTokenInstance = this.createFullToken; else if (/onlyStart/i.test(this.config.positionTracking)) this.createTokenInstance = this.createStartOnlyToken; else { if (!/onlyOffset/i.test(this.config.positionTracking)) throw Error('Invalid <positionTracking> config option: "' + this.config.positionTracking + '"'); this.createTokenInstance = this.createOffsetOnlyToken } this.hasCustom ? this.addToken = this.addTokenUsingPush : this.addToken = this.addTokenUsingMemberAccess; var f = i.reduce(this.canModeBeOptimized, (function (e, t, n) { return !1 === t && e.push(n), e }), []); if (t.ensureOptimizations && !i.isEmpty(f)) throw Error("Lexer Modes: < " + f.join(", ") + ' > cannot be optimized.\n\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.') } return e.prototype.tokenize = function (e, t) { if (void 0 === t && (t = this.defaultMode), !i.isEmpty(this.lexerDefinitionErrors)) { var n = i.map(this.lexerDefinitionErrors, (function (e) { return e.message })).join("-----------------------\n"); throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + n) } return this.tokenizeInternal(e, t) }, e.prototype.tokenizeInternal = function (e, t) { var n, r, u, d, o, s, c, f, l, p, h, m, E = this, y = e, T = y.length, S = 0, v = 0, R = this.hasCustom ? 0 : Math.floor(e.length / 10), L = new Array(R), A = [], O = this.trackStartLines ? 1 : void 0, b = this.trackStartLines ? 1 : void 0, I = a.cloneEmptyGroups(this.emptyGroups), N = this.trackStartLines, g = this.config.lineTerminatorsPattern, _ = 0, U = [], C = [], x = [], M = []; Object.freeze(M); var P, k = void 0, D = function (e) { if (1 === x.length && void 0 === e.tokenType.PUSH_MODE) { var t = "Unable to pop Lexer Mode after encountering Token ->" + e.image + "<- The Mode Stack is empty"; A.push({ offset: e.startOffset, line: void 0 !== e.startLine ? e.startLine : void 0, column: void 0 !== e.startColumn ? e.startColumn : void 0, length: e.image.length, message: t }) } else { x.pop(); var n = i.last(x); U = E.patternIdxToConfig[n], C = E.charCodeToPatternIdxToConfig[n], _ = U.length; var r = E.canModeBeOptimized[n] && !1 === E.config.safeMode; k = C && r ? function (e) { var t = C[e]; return void 0 === t ? M : t } : function () { return U } } }; function B(e) { x.push(e), C = this.charCodeToPatternIdxToConfig[e], U = this.patternIdxToConfig[e], _ = U.length, _ = U.length; var t = this.canModeBeOptimized[e] && !1 === this.config.safeMode; k = C && t ? function (e) { var t = C[e]; return void 0 === t ? M : t } : function () { return U } } for (B.call(this, t); S < T;) { o = null; var w = y.charCodeAt(S), F = k(w), G = F.length; for (n = 0; n < G; n++) { var Y = (P = F[n]).pattern; if (!1 !== (J = P.short) ? w === J && (o = Y) : !0 === P.isCustom ? o = null !== (m = Y.exec(y, S, L, I)) ? m[0] : m : (this.updateLastIndex(Y, S), o = this.match(Y, e, S)), null !== o) { if (void 0 !== (d = P.longerAlt)) { var V = U[d], W = V.pattern; !0 === V.isCustom ? u = null !== (m = W.exec(y, S, L, I)) ? m[0] : m : (this.updateLastIndex(W, S), u = this.match(W, e, S)), u && u.length > o.length && (o = u, P = V) } break } } if (null !== o) { if (s = o.length, void 0 !== (c = P.group) && (f = P.tokenTypeIdx, l = this.createTokenInstance(o, S, f, P.tokenType, O, b, s), !1 === c ? v = this.addToken(L, v, l) : I[c].push(l)), e = this.chopInput(e, s), S += s, b = this.computeNewColumn(b, s), !0 === N && !0 === P.canLineTerminator) { var q = 0, j = void 0, K = void 0; g.lastIndex = 0; do { !0 === (j = g.test(o)) && (K = g.lastIndex - 1, q++) } while (j); 0 !== q && (O += q, b = s - K, this.updateTokenEndLineColumnLocation(l, c, K, q, O, b, s)) } this.handleModes(P, D, B, l) } else { for (var H = S, z = O, X = b, $ = !1; !$ && S < T;)for (y.charCodeAt(S), e = this.chopInput(e, 1), S++, r = 0; r < _; r++) { var J, Z = U[r]; if (Y = Z.pattern, !1 !== (J = Z.short) ? y.charCodeAt(S) === J && ($ = !0) : !0 === Z.isCustom ? $ = null !== Y.exec(y, S, L, I) : (this.updateLastIndex(Y, S), $ = null !== Y.exec(e)), !0 === $) break } p = S - H, h = "unexpected character: ->" + y.charAt(H) + "<- at offset: " + H + ", skipped " + (S - H) + " characters.", A.push({ offset: H, line: z, column: X, length: p, message: h }) } } return this.hasCustom || (L.length = v), { tokens: L, groups: I, errors: A } }, e.prototype.handleModes = function (e, t, n, r) { if (!0 === e.pop) { var a = e.push; t(r), void 0 !== a && n.call(this, a) } else void 0 !== e.push && n.call(this, e.push) }, e.prototype.chopInput = function (e, t) { return e.substring(t) }, e.prototype.updateLastIndex = function (e, t) { e.lastIndex = t }, e.prototype.updateTokenEndLineColumnLocation = function (e, t, n, r, a, i, u) { var d, o; void 0 !== t && (o = (d = n === u - 1) ? -1 : 0, 1 === r && !0 === d || (e.endLine = a + o, e.endColumn = i - 1 - o)) }, e.prototype.computeNewColumn = function (e, t) { return e + t }, e.prototype.createTokenInstance = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return null }, e.prototype.createOffsetOnlyToken = function (e, t, n, r) { return { image: e, startOffset: t, tokenTypeIdx: n, tokenType: r } }, e.prototype.createStartOnlyToken = function (e, t, n, r, a, i) { return { image: e, startOffset: t, startLine: a, startColumn: i, tokenTypeIdx: n, tokenType: r } }, e.prototype.createFullToken = function (e, t, n, r, a, i, u) { return { image: e, startOffset: t, endOffset: t + u - 1, startLine: a, endLine: a, startColumn: i, endColumn: i + u - 1, tokenTypeIdx: n, tokenType: r } }, e.prototype.addToken = function (e, t, n) { return 666 }, e.prototype.addTokenUsingPush = function (e, t, n) { return e.push(n), t }, e.prototype.addTokenUsingMemberAccess = function (e, t, n) { return e[t] = n, ++t }, e.prototype.match = function (e, t, n) { return null }, e.prototype.matchWithTest = function (e, t, n) { return !0 === e.test(t) ? t.substring(n, e.lastIndex) : null }, e.prototype.matchWithExec = function (e, t) { var n = e.exec(t); return null !== n ? n[0] : n }, e.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", e.NA = /NOT_APPLICABLE/, e }(); t.Lexer = o }, 346: function (e, t, n) { var r, a = this && this.__extends || (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, function (e, t) { function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(3084), u = n(6382), d = new i.RegExpParser, o = "Complement Sets are not supported for first char optimization"; function s(e) { switch (e.type) { case "Disjunction": return u.flatten(u.map(e.value, s)); case "Alternative": for (var t = [], n = e.value, r = 0; r < n.length; r++) { var a = n[r]; if (!u.contains(["GroupBackReference", "Lookahead", "NegativeLookahead", "StartAnchor", "EndAnchor", "WordBoundary", "NonWordBoundary"], a.type)) { var i = a; switch (i.type) { case "Character": t.push(i.value); break; case "Set": if (!0 === i.complement) throw Error(o); u.forEach(i.value, (function (e) { if ("number" == typeof e) t.push(e); else for (var n = e, r = n.from; r <= n.to; r++)t.push(r) })); break; case "Group": var d = s(i.value); u.forEach(d, (function (e) { return t.push(e) })); break; default: throw Error("Non Exhaustive Match") }if (void 0 === i.quantifier || void 0 !== i.quantifier && i.quantifier.atLeast > 0) break } } return t; default: throw Error("non exhaustive match!") } } function c(e) { var t = []; return u.forEach(e, (function (e) { t.push(e); var n = String.fromCharCode(e); n.toUpperCase() !== n ? t.push(n.toUpperCase().charCodeAt(0)) : n.toLowerCase() !== n && t.push(n.toLowerCase().charCodeAt(0)) })), t } function f(e, t) { return u.find(e.value, (function (e) { if ("number" == typeof e) return u.contains(t, e); var n = e; return void 0 !== u.find(t, (function (e) { return n.from <= e && e <= n.to })) })) } t.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n', t.getStartCodes = function (e, n) { void 0 === n && (n = !1); try { var r = d.pattern(e.toString()), a = s(r.value); return r.flags.ignoreCase && (a = c(a)), a } catch (r) { if (r.message === o) n && u.PRINT_WARNING(t.failedOptimizationPrefixMsg + "\tUnable to optimize: < " + e.toString() + " >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details."); else { var f = ""; n && (f = "\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."), u.PRINT_ERROR(t.failedOptimizationPrefixMsg + "\n\tFailed parsing: < " + e.toString() + " >\n\tUsing the regexp-to-ast library version: " + i.VERSION + "\n\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" + f) } } return [] }, t.firstChar = s, t.applyIgnoreCase = c; var l = function (e) { function t(t) { var n = e.call(this) || this; return n.targetCharCodes = t, n.found = !1, n } return a(t, e), t.prototype.visitChildren = function (t) { switch (t.type) { case "Lookahead": return void this.visitLookahead(t); case "NegativeLookahead": return void this.visitNegativeLookahead(t) }e.prototype.visitChildren.call(this, t) }, t.prototype.visitCharacter = function (e) { u.contains(this.targetCharCodes, e.value) && (this.found = !0) }, t.prototype.visitSet = function (e) { e.complement ? void 0 === f(e, this.targetCharCodes) && (this.found = !0) : void 0 !== f(e, this.targetCharCodes) && (this.found = !0) }, t }(i.BaseRegExpVisitor); t.canMatchCharCode = function (e, t) { if (t instanceof RegExp) { var n = d.pattern(t.toString()), r = new l(e); return r.visit(n), r.found } return void 0 !== u.find(t, (function (t) { return u.contains(e, t.charCodeAt(0)) })) } }, 4291: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = n(8965), i = n(58); function u(e) { for (var t = r.cloneArr(e), n = e, a = !0; a;) { n = r.compact(r.flatten(r.map(n, (function (e) { return e.CATEGORIES })))); var i = r.difference(n, t); t = t.concat(i), r.isEmpty(i) ? a = !1 : n = i } return t } function d(e) { r.forEach(e, (function (e) { f(e) || (t.tokenIdxToClass.put(t.tokenShortNameIdx, e), e.tokenTypeIdx = t.tokenShortNameIdx++), l(e) && !r.isArray(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), l(e) || (e.CATEGORIES = []), p(e) || (e.categoryMatches = []), h(e) || (e.categoryMatchesMap = {}), m(e) || (e.tokenName = i.tokenName(e)) })) } function o(e) { r.forEach(e, (function (e) { e.categoryMatches = [], r.forEach(e.categoryMatchesMap, (function (n, r) { e.categoryMatches.push(t.tokenIdxToClass.get(r).tokenTypeIdx) })) })) } function s(e) { r.forEach(e, (function (e) { c([], e) })) } function c(e, t) { r.forEach(e, (function (e) { t.categoryMatchesMap[e.tokenTypeIdx] = !0 })), r.forEach(t.CATEGORIES, (function (n) { var a = e.concat(t); r.contains(a, n) || c(a, n) })) } function f(e) { return r.has(e, "tokenTypeIdx") } function l(e) { return r.has(e, "CATEGORIES") } function p(e) { return r.has(e, "categoryMatches") } function h(e) { return r.has(e, "categoryMatchesMap") } function m(e) { return r.has(e, "tokenName") } t.tokenStructuredMatcher = function (e, t) { var n = e.tokenTypeIdx; return n === t.tokenTypeIdx || !0 === t.isParent && !0 === t.categoryMatchesMap[n] }, t.tokenStructuredMatcherNoCategories = function (e, t) { return e.tokenTypeIdx === t.tokenTypeIdx }, t.tokenShortNameIdx = 1, t.tokenIdxToClass = new a.HashTable, t.augmentTokenTypes = function (e) { var t = u(e); d(t), s(t), o(t), r.forEach(t, (function (e) { e.isParent = e.categoryMatches.length > 0 })) }, t.expandCategories = u, t.assignTokenDefaultProps = d, t.assignCategoriesTokensProp = o, t.assignCategoriesMapProp = s, t.singleAssignCategoriesToksMap = c, t.hasShortKeyProperty = f, t.hasCategoriesProperty = l, t.hasExtendingTokensTypesProperty = p, t.hasExtendingTokensTypesMapProperty = h, t.hasTokenNameProperty = m, t.isTokenType = function (e) { return r.has(e, "tokenTypeIdx") } }, 58: (e, t, n) => { Object.defineProperty(t, "__esModule", { value: !0 }); var r = n(6382), a = n(8965), i = n(9337), u = n(4291); function d(e) { return r.isString(e.LABEL) && "" !== e.LABEL } function o(e) { return r.isObject(e) && e.hasOwnProperty("tokenName") && r.isString(e.tokenName) ? e.tokenName : a.functionName(e) } t.tokenLabel = function (e) { return d(e) ? e.LABEL : o(e) }, t.hasTokenLabel = d, t.tokenName = o; function s(e) { return function (e) { var t = e.name, n = e.pattern, i = {}; if (a.defineNameProp(i, t) || (i.tokenName = t), r.isUndefined(n) || (i.PATTERN = n), r.has(e, "parent")) throw "The parent property is no longer supported.\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details."; return r.has(e, "categories") && (i.CATEGORIES = e.categories), u.augmentTokenTypes([i]), r.has(e, "label") && (i.LABEL = e.label), r.has(e, "group") && (i.GROUP = e.group), r.has(e, "pop_mode") && (i.POP_MODE = e.pop_mode), r.has(e, "push_mode") && (i.PUSH_MODE = e.push_mode), r.has(e, "longer_alt") && (i.LONGER_ALT = e.longer_alt), r.has(e, "line_breaks") && (i.LINE_BREAKS = e.line_breaks), r.has(e, "start_chars_hint") && (i.START_CHARS_HINT = e.start_chars_hint), i }(e) } t.createToken = s, t.EOF = s({ name: "EOF", pattern: i.Lexer.NA }), u.augmentTokenTypes([t.EOF]), t.createTokenInstance = function (e, t, n, r, a, i, u, d) { return { image: t, startOffset: n, endOffset: r, startLine: a, endLine: i, startColumn: u, endColumn: d, tokenTypeIdx: e.tokenTypeIdx, tokenType: e } }, t.tokenMatcher = function (e, t) { return u.tokenStructuredMatcher(e, t) } }, 802: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }); var n = function () { function e(e, t) { if (this.start = e, this.end = t, !r(e, t)) throw new Error("INVALID RANGE") } return e.prototype.contains = function (e) { return this.start <= e && this.end >= e }, e.prototype.containsRange = function (e) { return this.start <= e.start && this.end >= e.end }, e.prototype.isContainedInRange = function (e) { return e.containsRange(this) }, e.prototype.strictlyContainsRange = function (e) { return this.start < e.start && this.end > e.end }, e.prototype.isStrictlyContainedInRange = function (e) { return e.strictlyContainsRange(this) }, e }(); function r(e, t) { return !(e < 0 || t < e) } t.Range = n, t.isValidRange = r }, 6382: (e, t) => { function n(e) { return e && 0 === e.length } function r(e) { return null == e ? [] : Object.keys(e) } function a(e) { for (var t = [], n = Object.keys(e), r = 0; r < n.length; r++)t.push(e[n[r]]); return t } function i(e, t) { if (Array.isArray(e)) for (var n = 0; n < e.length; n++)t.call(null, e[n], n); else { if (!m(e)) throw Error("non exhaustive match"); var a = r(e); for (n = 0; n < a.length; n++) { var i = a[n], u = e[i]; t.call(null, u, i) } } } function u(e) { return void 0 === e } function d(e, t) { var n = []; if (Array.isArray(e)) for (var r = 0; r < e.length; r++) { var a = e[r]; t.call(null, a) && n.push(a) } return n } function o(e, t) { return d(e, (function (e) { return !t(e) })) } function s(e, t) { return !!m(e) && e.hasOwnProperty(t) } function c(e, t) { return void 0 !== p(e, (function (e) { return e === t })) } function f(e) { for (var t = [], n = 0; n < e.length; n++)t.push(e[n]); return t } function l(e) { var t = {}; for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t } function p(e, t) { for (var n = 0; n < e.length; n++) { var r = e[n]; if (t.call(null, r)) return r } } function h(e, t, n) { for (var i = Array.isArray(e), u = i ? e : a(e), d = i ? [] : r(e), o = n, s = 0; s < u.length; s++)o = t.call(null, o, u[s], i ? s : d[s]); return o } function m(e) { return e instanceof Object } function E(e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; for (var a = 0; a < t.length; a++) { var i = t[a]; if (!u(i)) for (var d = r(i), o = 0; o < d.length; o++) { var c = d[o]; s(e, c) || (e[c] = i[c]) } } return e } Object.defineProperty(t, "__esModule", { value: !0 }), t.isEmpty = n, t.keys = r, t.values = a, t.mapValues = function (e, t) { for (var n = [], a = r(e), i = 0; i < a.length; i++) { var u = a[i]; n.push(t.call(null, e[u], u)) } return n }, t.map = function (e, t) { for (var n = [], r = 0; r < e.length; r++)n.push(t.call(null, e[r], r)); return n }, t.flatten = function e(t) { for (var n = [], r = 0; r < t.length; r++) { var a = t[r]; Array.isArray(a) ? n = n.concat(e(a)) : n.push(a) } return n }, t.first = function (e) { return n(e) ? void 0 : e[0] }, t.last = function (e) { var t = e && e.length; return t ? e[t - 1] : void 0 }, t.forEach = i, t.isString = function (e) { return "string" == typeof e }, t.isUndefined = u, t.isFunction = function (e) { return e instanceof Function }, t.drop = function (e, t) { return void 0 === t && (t = 1), e.slice(t, e.length) }, t.dropRight = function (e, t) { return void 0 === t && (t = 1), e.slice(0, e.length - t) }, t.filter = d, t.reject = o, t.pick = function (e, t) { for (var n = Object.keys(e), r = {}, a = 0; a < n.length; a++) { var i = n[a], u = e[i]; t(u) && (r[i] = u) } return r }, t.has = s, t.contains = c, t.cloneArr = f, t.cloneObj = l, t.find = p, t.findAll = function (e, t) { for (var n = [], r = 0; r < e.length; r++) { var a = e[r]; t.call(null, a) && n.push(a) } return n }, t.reduce = h, t.compact = function (e) { return o(e, (function (e) { return null == e })) }, t.uniq = function (e, t) { void 0 === t && (t = function (e) { return e }); var n = []; return h(e, (function (e, r) { var a = t(r); return c(n, a) ? e : (n.push(a), e.concat(r)) }), []) }, t.partial = function (e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; var r = [null], a = r.concat(t); return Function.bind.apply(e, a) }, t.isArray = function (e) { return Array.isArray(e) }, t.isRegExp = function (e) { return e instanceof RegExp }, t.isObject = m, t.every = function (e, t) { for (var n = 0; n < e.length; n++)if (!t(e[n], n)) return !1; return !0 }, t.difference = function (e, t) { return o(e, (function (e) { return c(t, e) })) }, t.some = function (e, t) { for (var n = 0; n < e.length; n++)if (t(e[n])) return !0; return !1 }, t.indexOf = function (e, t) { for (var n = 0; n < e.length; n++)if (e[n] === t) return n; return -1 }, t.sortBy = function (e, t) { var n = f(e); return n.sort((function (e, n) { return t(e) - t(n) })), n }, t.zipObject = function (e, t) { if (e.length !== t.length) throw Error("can't zipObject with different number of keys and values!"); for (var n = {}, r = 0; r < e.length; r++)n[e[r]] = t[r]; return n }, t.assign = function (e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; for (var a = 0; a < t.length; a++)for (var i = t[a], u = r(i), d = 0; d < u.length; d++) { var o = u[d]; e[o] = i[o] } return e }, t.assignNoOverwrite = E, t.defaults = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return E.apply(null, [{}].concat(e)) }, t.groupBy = function (e, t) { var n = {}; return i(e, (function (e) { var r = t(e), a = n[r]; a ? a.push(e) : n[r] = [e] })), n }, t.merge = function (e, t) { for (var n = l(e), a = r(t), i = 0; i < a.length; i++) { var u = a[i], d = t[u]; n[u] = d } return n }, t.NOOP = function () { }, t.IDENTITY = function (e) { return e }, t.packArray = function (e) { for (var t = [], n = 0; n < e.length; n++) { var r = e[n]; t.push(void 0 !== r ? r : void 0) } return t }, t.PRINT_ERROR = function (e) { console && console.error && console.error("Error: " + e) }, t.PRINT_WARNING = function (e) { console && console.warn && console.warn("Warning: " + e) } }, 6371: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.VERSION = "3.7.4" }, 6343: (e, t, n) => { n(4035), n(6383); var r = n(8718); e.exports = r.Array.from }, 222: (e, t, n) => { n(846); var r = n(8718); e.exports = r.Array.isArray }, 3789: (e, t, n) => { n(9201); var r = n(1675); e.exports = r("Array").concat }, 7422: (e, t, n) => { n(3884); var r = n(1675); e.exports = r("Array").forEach }, 6730: (e, t, n) => { n(3554); var r = n(1675); e.exports = r("Array").includes }, 4162: (e, t, n) => { n(380); var r = n(1675); e.exports = r("Array").indexOf }, 5695: (e, t, n) => { n(863); var r = n(1675); e.exports = r("Array").map }, 3060: (e, t, n) => { n(7830); var r = n(1675); e.exports = r("Array").reduce }, 3401: (e, t, n) => { n(607); var r = n(1675); e.exports = r("Array").slice }, 8475: (e, t, n) => { n(2567); var r = n(1675); e.exports = r("Array").sort }, 2205: (e, t, n) => { var r = n(3789), a = Array.prototype; e.exports = function (e) { var t = e.concat; return e === a || e instanceof Array && t === a.concat ? r : t } }, 9158: (e, t, n) => { var r = n(4740), a = RegExp.prototype; e.exports = function (e) { return (e === a || e instanceof RegExp) && !("flags" in e) ? r(e) : e.flags } }, 8502: (e, t, n) => { var r = n(6730), a = n(9074), i = Array.prototype, u = String.prototype; e.exports = function (e) { var t = e.includes; return e === i || e instanceof Array && t === i.includes ? r : "string" == typeof e || e === u || e instanceof String && t === u.includes ? a : t } }, 6535: (e, t, n) => { var r = n(4162), a = Array.prototype; e.exports = function (e) { var t = e.indexOf; return e === a || e instanceof Array && t === a.indexOf ? r : t } }, 7500: (e, t, n) => { var r = n(5695), a = Array.prototype; e.exports = function (e) { var t = e.map; return e === a || e instanceof Array && t === a.map ? r : t } }, 5096: (e, t, n) => { var r = n(3060), a = Array.prototype; e.exports = function (e) { var t = e.reduce; return e === a || e instanceof Array && t === a.reduce ? r : t } }, 3945: (e, t, n) => { var r = n(3401), a = Array.prototype; e.exports = function (e) { var t = e.slice; return e === a || e instanceof Array && t === a.slice ? r : t } }, 6812: (e, t, n) => { var r = n(8475), a = Array.prototype; e.exports = function (e) { var t = e.sort; return e === a || e instanceof Array && t === a.sort ? r : t } }, 3518: (e, t, n) => { n(112); var r = n(8718).Object; e.exports = function (e, t) { return r.create(e, t) } }, 2239: (e, t, n) => { n(14); var r = n(8718).Object, a = e.exports = function (e, t, n) { return r.defineProperty(e, t, n) }; r.defineProperty.sham && (a.sham = !0) }, 3408: (e, t, n) => { n(2546); var r = n(8718); e.exports = r.parseInt }, 4740: (e, t, n) => { n(2758); var r = n(8428); e.exports = function (e) { return r.call(e) } }, 9074: (e, t, n) => { n(8587); var r = n(1675); e.exports = r("String").includes }, 1787: (e, t, n) => { n(9201), n(4701), n(4126), n(378), n(662), n(4928), n(1300), n(5993), n(972), n(3798), n(2951), n(2284), n(4620), n(4211), n(8197), n(4319), n(1733), n(8401), n(9181), n(5642); var r = n(8718); e.exports = r.Symbol }, 1927: (e, t, n) => { var r = n(6343); e.exports = r }, 678: (e, t, n) => { var r = n(222); e.exports = r }, 8867: (e, t, n) => { n(1306), n(4035); var r = n(5329); e.exports = r }, 411: (e, t, n) => { n(1306), n(4035); var r = n(1926); e.exports = r }, 8860: (e, t, n) => { var r = n(3945); e.exports = r }, 7324: (e, t, n) => { n(1306), n(4035); var r = n(8822); e.exports = r }, 2565: (e, t, n) => { var r = n(1787); n(5466), n(2989), n(8259), n(9557), n(4423), e.exports = r }, 4168: e => { e.exports = function (e) { if ("function" != typeof e) throw TypeError(String(e) + " is not a function"); return e } }, 8020: (e, t, n) => { var r = n(2343); e.exports = function (e) { if (!r(e) && null !== e) throw TypeError("Can't set " + String(e) + " as a prototype"); return e } }, 7156: e => { e.exports = function () { } }, 9470: (e, t, n) => { var r = n(2343); e.exports = function (e) { if (!r(e)) throw TypeError(String(e) + " is not an object"); return e } }, 9422: (e, t, n) => { var r = n(9205).forEach, a = n(5419), i = n(8016), u = a("forEach"), d = i("forEach"); e.exports = u && d ? [].forEach : function (e) { return r(this, e, arguments.length > 1 ? arguments[1] : void 0) } }, 7899: (e, t, n) => { var r = n(3612), a = n(3026), i = n(3626), u = n(6214), d = n(6666), o = n(4438), s = n(5329); e.exports = function (e) { var t, n, c, f, l, p, h = a(e), m = "function" == typeof this ? this : Array, E = arguments.length, y = E > 1 ? arguments[1] : void 0, T = void 0 !== y, S = s(h), v = 0; if (T && (y = r(y, E > 2 ? arguments[2] : void 0, 2)), null == S || m == Array && u(S)) for (n = new m(t = d(h.length)); t > v; v++)p = T ? y(h[v], v) : h[v], o(n, v, p); else for (l = (f = S.call(h)).next, n = new m; !(c = l.call(f)).done; v++)p = T ? i(f, y, [c.value, v], !0) : c.value, o(n, v, p); return n.length = v, n } }, 7788: (e, t, n) => { var r = n(7099), a = n(6666), i = n(669), u = function (e) { return function (t, n, u) { var d, o = r(t), s = a(o.length), c = i(u, s); if (e && n != n) { for (; s > c;)if ((d = o[c++]) != d) return !0 } else for (; s > c; c++)if ((e || c in o) && o[c] === n) return e || c || 0; return !e && -1 } }; e.exports = { includes: u(!0), indexOf: u(!1) } }, 9205: (e, t, n) => { var r = n(3612), a = n(5093), i = n(3026), u = n(6666), d = n(891), o = [].push, s = function (e) { var t = 1 == e, n = 2 == e, s = 3 == e, c = 4 == e, f = 6 == e, l = 7 == e, p = 5 == e || f; return function (h, m, E, y) { for (var T, S, v = i(h), R = a(v), L = r(m, E, 3), A = u(R.length), O = 0, b = y || d, I = t ? b(h, A) : n || l ? b(h, 0) : void 0; A > O; O++)if ((p || O in R) && (S = L(T = R[O], O, v), e)) if (t) I[O] = S; else if (S) switch (e) { case 3: return !0; case 5: return T; case 6: return O; case 2: o.call(I, T) } else switch (e) { case 4: return !1; case 7: o.call(I, T) }return f ? -1 : s || c ? c : I } }; e.exports = { forEach: s(0), map: s(1), filter: s(2), some: s(3), every: s(4), find: s(5), findIndex: s(6), filterOut: s(7) } }, 4148: (e, t, n) => { var r = n(9249), a = n(9525), i = n(4958), u = a("species"); e.exports = function (e) { return i >= 51 || !r((function () { var t = []; return (t.constructor = {})[u] = function () { return { foo: 1 } }, 1 !== t[e](Boolean).foo })) } }, 5419: (e, t, n) => { var r = n(9249); e.exports = function (e, t) { var n = [][e]; return !!n && r((function () { n.call(null, t || function () { throw 1 }, 1) })) } }, 8016: (e, t, n) => { var r = n(8745), a = n(9249), i = n(3063), u = Object.defineProperty, d = {}, o = function (e) { throw e }; e.exports = function (e, t) { if (i(d, e)) return d[e]; t || (t = {}); var n = [][e], s = !!i(t, "ACCESSORS") && t.ACCESSORS, c = i(t, 0) ? t[0] : o, f = i(t, 1) ? t[1] : void 0; return d[e] = !!n && !a((function () { if (s && !r) return !0; var e = { length: -1 }; s ? u(e, 1, { enumerable: !0, get: o }) : e[1] = 1, n.call(e, c, f) })) } }, 8079: (e, t, n) => { var r = n(4168), a = n(3026), i = n(5093), u = n(6666), d = function (e) { return function (t, n, d, o) { r(n); var s = a(t), c = i(s), f = u(s.length), l = e ? f - 1 : 0, p = e ? -1 : 1; if (d < 2) for (; ;) { if (l in c) { o = c[l], l += p; break } if (l += p, e ? l < 0 : f <= l) throw TypeError("Reduce of empty array with no initial value") } for (; e ? l >= 0 : f > l; l += p)l in c && (o = n(o, c[l], l, s)); return o } }; e.exports = { left: d(!1), right: d(!0) } }, 891: (e, t, n) => { var r = n(2343), a = n(410), i = n(9525)("species"); e.exports = function (e, t) { var n; return a(e) && ("function" != typeof (n = e.constructor) || n !== Array && !a(n.prototype) ? r(n) && null === (n = n[i]) && (n = void 0) : n = void 0), new (void 0 === n ? Array : n)(0 === t ? 0 : t) } }, 3626: (e, t, n) => { var r = n(9470), a = n(8419); e.exports = function (e, t, n, i) { try { return i ? t(r(n)[0], n[1]) : t(n) } catch (t) { throw a(e), t } } }, 1463: (e, t, n) => { var r = n(9525)("iterator"), a = !1; try { var i = 0, u = { next: function () { return { done: !!i++ } }, return: function () { a = !0 } }; u[r] = function () { return this }, Array.from(u, (function () { throw 2 })) } catch (e) { } e.exports = function (e, t) { if (!t && !a) return !1; var n = !1; try { var i = {}; i[r] = function () { return { next: function () { return { done: n = !0 } } } }, e(i) } catch (e) { } return n } }, 775: e => { var t = {}.toString; e.exports = function (e) { return t.call(e).slice(8, -1) } }, 1366: (e, t, n) => { var r = n(753), a = n(775), i = n(9525)("toStringTag"), u = "Arguments" == a(function () { return arguments }()); e.exports = r ? a : function (e) { var t, n, r; return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function (e, t) { try { return e[t] } catch (e) { } }(t = Object(e), i)) ? n : u ? a(t) : "Object" == (r = a(t)) && "function" == typeof t.callee ? "Arguments" : r } }, 5423: (e, t, n) => { var r = n(9525)("match"); e.exports = function (e) { var t = /./; try { "/./"[e](t) } catch (n) { try { return t[r] = !1, "/./"[e](t) } catch (e) { } } return !1 } }, 4975: (e, t, n) => { var r = n(9249); e.exports = !r((function () { function e() { } return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype })) }, 7736: (e, t, n) => { var r = n(672).IteratorPrototype, a = n(9721), i = n(8258), u = n(9375), d = n(3693), o = function () { return this }; e.exports = function (e, t, n) { var s = t + " Iterator"; return e.prototype = a(r, { next: i(1, n) }), u(e, s, !1, !0), d[s] = o, e } }, 768: (e, t, n) => { var r = n(8745), a = n(2305), i = n(8258); e.exports = r ? function (e, t, n) { return a.f(e, t, i(1, n)) } : function (e, t, n) { return e[t] = n, e } }, 8258: e => { e.exports = function (e, t) { return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t } } }, 4438: (e, t, n) => { var r = n(965), a = n(2305), i = n(8258); e.exports = function (e, t, n) { var u = r(t); u in e ? a.f(e, u, i(0, n)) : e[u] = n } }, 9020: (e, t, n) => { var r = n(8215), a = n(7736), i = n(8738), u = n(4691), d = n(9375), o = n(768), s = n(886), c = n(9525), f = n(7840), l = n(3693), p = n(672), h = p.IteratorPrototype, m = p.BUGGY_SAFARI_ITERATORS, E = c("iterator"), y = "keys", T = "values", S = "entries", v = function () { return this }; e.exports = function (e, t, n, c, p, R, L) { a(n, t, c); var A, O, b, I = function (e) { if (e === p && C) return C; if (!m && e in _) return _[e]; switch (e) { case y: case T: case S: return function () { return new n(this, e) } }return function () { return new n(this) } }, N = t + " Iterator", g = !1, _ = e.prototype, U = _[E] || _["@@iterator"] || p && _[p], C = !m && U || I(p), x = "Array" == t && _.entries || U; if (x && (A = i(x.call(new e)), h !== Object.prototype && A.next && (f || i(A) === h || (u ? u(A, h) : "function" != typeof A[E] && o(A, E, v)), d(A, N, !0, !0), f && (l[N] = v))), p == T && U && U.name !== T && (g = !0, C = function () { return U.call(this) }), f && !L || _[E] === C || o(_, E, C), l[t] = C, p) if (O = { values: I(T), keys: R ? C : I(y), entries: I(S) }, L) for (b in O) (m || g || !(b in _)) && s(_, b, O[b]); else r({ target: t, proto: !0, forced: m || g }, O); return O } }, 7876: (e, t, n) => { var r = n(8718), a = n(3063), i = n(6246), u = n(2305).f; e.exports = function (e) { var t = r.Symbol || (r.Symbol = {}); a(t, e) || u(t, e, { value: i.f(e) }) } }, 8745: (e, t, n) => { var r = n(9249); e.exports = !r((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) }, 5487: (e, t, n) => { var r = n(4624), a = n(2343), i = r.document, u = a(i) && a(i.createElement); e.exports = function (e) { return u ? i.createElement(e) : {} } }, 7810: e => { e.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 } }, 6213: (e, t, n) => { var r = n(775), a = n(4624); e.exports = "process" == r(a.process) }, 898: (e, t, n) => { var r = n(2458); e.exports = r("navigator", "userAgent") || "" }, 4958: (e, t, n) => { var r, a, i = n(4624), u = n(898), d = i.process, o = d && d.versions, s = o && o.v8; s ? a = (r = s.split("."))[0] + r[1] : u && (!(r = u.match(/Edge\/(\d+)/)) || r[1] >= 74) && (r = u.match(/Chrome\/(\d+)/)) && (a = r[1]), e.exports = a && +a }, 1675: (e, t, n) => { var r = n(8718); e.exports = function (e) { return r[e + "Prototype"] } }, 1784: e => { e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, 8215: (e, t, n) => { var r = n(4624), a = n(6285).f, i = n(8053), u = n(8718), d = n(3612), o = n(768), s = n(3063), c = function (e) { var t = function (t, n, r) { if (this instanceof e) { switch (arguments.length) { case 0: return new e; case 1: return new e(t); case 2: return new e(t, n) }return new e(t, n, r) } return e.apply(this, arguments) }; return t.prototype = e.prototype, t }; e.exports = function (e, t) { var n, f, l, p, h, m, E, y, T = e.target, S = e.global, v = e.stat, R = e.proto, L = S ? r : v ? r[T] : (r[T] || {}).prototype, A = S ? u : u[T] || (u[T] = {}), O = A.prototype; for (l in t) n = !i(S ? l : T + (v ? "." : "#") + l, e.forced) && L && s(L, l), h = A[l], n && (m = e.noTargetGet ? (y = a(L, l)) && y.value : L[l]), p = n && m ? m : t[l], n && typeof h == typeof p || (E = e.bind && n ? d(p, r) : e.wrap && n ? c(p) : R && "function" == typeof p ? d(Function.call, p) : p, (e.sham || p && p.sham || h && h.sham) && o(E, "sham", !0), A[l] = E, R && (s(u, f = T + "Prototype") || o(u, f, {}), u[f][l] = p, e.real && O && !O[l] && o(O, l, p))) } }, 9249: e => { e.exports = function (e) { try { return !!e() } catch (e) { return !0 } } }, 3612: (e, t, n) => { var r = n(4168); e.exports = function (e, t, n) { if (r(e), void 0 === t) return e; switch (n) { case 0: return function () { return e.call(t) }; case 1: return function (n) { return e.call(t, n) }; case 2: return function (n, r) { return e.call(t, n, r) }; case 3: return function (n, r, a) { return e.call(t, n, r, a) } }return function () { return e.apply(t, arguments) } } }, 2458: (e, t, n) => { var r = n(8718), a = n(4624), i = function (e) { return "function" == typeof e ? e : void 0 }; e.exports = function (e, t) { return arguments.length < 2 ? i(r[e]) || i(a[e]) : r[e] && r[e][t] || a[e] && a[e][t] } }, 5329: (e, t, n) => { var r = n(1366), a = n(3693), i = n(9525)("iterator"); e.exports = function (e) { if (null != e) return e[i] || e["@@iterator"] || a[r(e)] } }, 1926: (e, t, n) => { var r = n(9470), a = n(5329); e.exports = function (e) { var t = a(e); if ("function" != typeof t) throw TypeError(String(e) + " is not iterable"); return r(t.call(e)) } }, 4624: (e, t, n) => { var r = function (e) { return e && e.Math == Math && e }; e.exports = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof n.g && n.g) || function () { return this }() || Function("return this")() }, 3063: e => { var t = {}.hasOwnProperty; e.exports = function (e, n) { return t.call(e, n) } }, 8942: e => { e.exports = {} }, 1221: (e, t, n) => { var r = n(2458); e.exports = r("document", "documentElement") }, 4836: (e, t, n) => { var r = n(8745), a = n(9249), i = n(5487); e.exports = !r && !a((function () { return 7 != Object.defineProperty(i("div"), "a", { get: function () { return 7 } }).a })) }, 5093: (e, t, n) => { var r = n(9249), a = n(775), i = "".split; e.exports = r((function () { return !Object("z").propertyIsEnumerable(0) })) ? function (e) { return "String" == a(e) ? i.call(e, "") : Object(e) } : Object }, 348: (e, t, n) => { var r = n(7976), a = Function.toString; "function" != typeof r.inspectSource && (r.inspectSource = function (e) { return a.call(e) }), e.exports = r.inspectSource }, 6223: (e, t, n) => { var r, a, i, u = n(3904), d = n(4624), o = n(2343), s = n(768), c = n(3063), f = n(7976), l = n(6683), p = n(8942), h = d.WeakMap; if (u) { var m = f.state || (f.state = new h), E = m.get, y = m.has, T = m.set; r = function (e, t) { return t.facade = e, T.call(m, e, t), t }, a = function (e) { return E.call(m, e) || {} }, i = function (e) { return y.call(m, e) } } else { var S = l("state"); p[S] = !0, r = function (e, t) { return t.facade = e, s(e, S, t), t }, a = function (e) { return c(e, S) ? e[S] : {} }, i = function (e) { return c(e, S) } } e.exports = { set: r, get: a, has: i, enforce: function (e) { return i(e) ? a(e) : r(e, {}) }, getterFor: function (e) { return function (t) { var n; if (!o(t) || (n = a(t)).type !== e) throw TypeError("Incompatible receiver, " + e + " required"); return n } } } }, 6214: (e, t, n) => { var r = n(9525), a = n(3693), i = r("iterator"), u = Array.prototype; e.exports = function (e) { return void 0 !== e && (a.Array === e || u[i] === e) } }, 410: (e, t, n) => { var r = n(775); e.exports = Array.isArray || function (e) { return "Array" == r(e) } }, 8053: (e, t, n) => { var r = n(9249), a = /#|\.prototype\./, i = function (e, t) { var n = d[u(e)]; return n == s || n != o && ("function" == typeof t ? r(t) : !!t) }, u = i.normalize = function (e) { return String(e).replace(a, ".").toLowerCase() }, d = i.data = {}, o = i.NATIVE = "N", s = i.POLYFILL = "P"; e.exports = i }, 8822: (e, t, n) => { var r = n(1366), a = n(9525), i = n(3693), u = a("iterator"); e.exports = function (e) { var t = Object(e); return void 0 !== t[u] || "@@iterator" in t || i.hasOwnProperty(r(t)) } }, 2343: e => { e.exports = function (e) { return "object" == typeof e ? null !== e : "function" == typeof e } }, 7840: e => { e.exports = !0 }, 9949: (e, t, n) => { var r = n(2343), a = n(775), i = n(9525)("match"); e.exports = function (e) { var t; return r(e) && (void 0 !== (t = e[i]) ? !!t : "RegExp" == a(e)) } }, 8419: (e, t, n) => { var r = n(9470); e.exports = function (e) { var t = e.return; if (void 0 !== t) return r(t.call(e)).value } }, 672: (e, t, n) => { var r, a, i, u = n(9249), d = n(8738), o = n(768), s = n(3063), c = n(9525), f = n(7840), l = c("iterator"), p = !1;[].keys && ("next" in (i = [].keys()) ? (a = d(d(i))) !== Object.prototype && (r = a) : p = !0); var h = null == r || u((function () { var e = {}; return r[l].call(e) !== e })); h && (r = {}), f && !h || s(r, l) || o(r, l, (function () { return this })), e.exports = { IteratorPrototype: r, BUGGY_SAFARI_ITERATORS: p } }, 3693: e => { e.exports = {} }, 6696: (e, t, n) => { var r = n(9249); e.exports = !!Object.getOwnPropertySymbols && !r((function () { return !String(Symbol()) })) }, 3904: (e, t, n) => { var r = n(4624), a = n(348), i = r.WeakMap; e.exports = "function" == typeof i && /native code/.test(a(i)) }, 5846: (e, t, n) => { var r = n(9949); e.exports = function (e) { if (r(e)) throw TypeError("The method doesn't accept regular expressions"); return e } }, 1215: (e, t, n) => { var r = n(4624), a = n(725).trim, i = n(5940), u = r.parseInt, d = /^[+-]?0[Xx]/, o = 8 !== u(i + "08") || 22 !== u(i + "0x16"); e.exports = o ? function (e, t) { var n = a(String(e)); return u(n, t >>> 0 || (d.test(n) ? 16 : 10)) } : u }, 9721: (e, t, n) => { var r, a = n(9470), i = n(3471), u = n(1784), d = n(8942), o = n(1221), s = n(5487), c = n(6683)("IE_PROTO"), f = function () { }, l = function (e) { return "<script>" + e + "<\/script>" }, p = function () { try { r = document.domain && new ActiveXObject("htmlfile") } catch (e) { } var e, t; p = r ? function (e) { e.write(l("")), e.close(); var t = e.parentWindow.Object; return e = null, t }(r) : ((t = s("iframe")).style.display = "none", o.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(l("document.F=Object")), e.close(), e.F); for (var n = u.length; n--;)delete p.prototype[u[n]]; return p() }; d[c] = !0, e.exports = Object.create || function (e, t) { var n; return null !== e ? (f.prototype = a(e), n = new f, f.prototype = null, n[c] = e) : n = p(), void 0 === t ? n : i(n, t) } }, 3471: (e, t, n) => { var r = n(8745), a = n(2305), i = n(9470), u = n(5961); e.exports = r ? Object.defineProperties : function (e, t) { i(e); for (var n, r = u(t), d = r.length, o = 0; d > o;)a.f(e, n = r[o++], t[n]); return e } }, 2305: (e, t, n) => { var r = n(8745), a = n(4836), i = n(9470), u = n(965), d = Object.defineProperty; t.f = r ? d : function (e, t, n) { if (i(e), t = u(t, !0), i(n), a) try { return d(e, t, n) } catch (e) { } if ("get" in n || "set" in n) throw TypeError("Accessors not supported"); return "value" in n && (e[t] = n.value), e } }, 6285: (e, t, n) => { var r = n(8745), a = n(3786), i = n(8258), u = n(7099), d = n(965), o = n(3063), s = n(4836), c = Object.getOwnPropertyDescriptor; t.f = r ? c : function (e, t) { if (e = u(e), t = d(t, !0), s) try { return c(e, t) } catch (e) { } if (o(e, t)) return i(!a.f.call(e, t), e[t]) } }, 9715: (e, t, n) => { var r = n(7099), a = n(4745).f, i = {}.toString, u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; e.exports.f = function (e) { return u && "[object Window]" == i.call(e) ? function (e) { try { return a(e) } catch (e) { return u.slice() } }(e) : a(r(e)) } }, 4745: (e, t, n) => { var r = n(541), a = n(1784).concat("length", "prototype"); t.f = Object.getOwnPropertyNames || function (e) { return r(e, a) } }, 6142: (e, t) => { t.f = Object.getOwnPropertySymbols }, 8738: (e, t, n) => { var r = n(3063), a = n(3026), i = n(6683), u = n(4975), d = i("IE_PROTO"), o = Object.prototype; e.exports = u ? Object.getPrototypeOf : function (e) { return e = a(e), r(e, d) ? e[d] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? o : null } }, 541: (e, t, n) => { var r = n(3063), a = n(7099), i = n(7788).indexOf, u = n(8942); e.exports = function (e, t) { var n, d = a(e), o = 0, s = []; for (n in d) !r(u, n) && r(d, n) && s.push(n); for (; t.length > o;)r(d, n = t[o++]) && (~i(s, n) || s.push(n)); return s } }, 5961: (e, t, n) => { var r = n(541), a = n(1784); e.exports = Object.keys || function (e) { return r(e, a) } }, 3786: (e, t) => { var n = {}.propertyIsEnumerable, r = Object.getOwnPropertyDescriptor, a = r && !n.call({ 1: 2 }, 1); t.f = a ? function (e) { var t = r(this, e); return !!t && t.enumerable } : n }, 4691: (e, t, n) => { var r = n(9470), a = n(8020); e.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var e, t = !1, n = {}; try { (e = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), t = n instanceof Array } catch (e) { } return function (n, i) { return r(n), a(i), t ? e.call(n, i) : n.__proto__ = i, n } }() : void 0) }, 7915: (e, t, n) => { var r = n(753), a = n(1366); e.exports = r ? {}.toString : function () { return "[object " + a(this) + "]" } }, 8718: e => { e.exports = {} }, 886: (e, t, n) => { var r = n(768); e.exports = function (e, t, n, a) { a && a.enumerable ? e[t] = n : r(e, t, n) } }, 8428: (e, t, n) => { var r = n(9470); e.exports = function () { var e = r(this), t = ""; return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.sticky && (t += "y"), t } }, 4289: e => { e.exports = function (e) { if (null == e) throw TypeError("Can't call method on " + e); return e } }, 3438: (e, t, n) => { var r = n(4624), a = n(768); e.exports = function (e, t) { try { a(r, e, t) } catch (n) { r[e] = t } return t } }, 9375: (e, t, n) => { var r = n(753), a = n(2305).f, i = n(768), u = n(3063), d = n(7915), o = n(9525)("toStringTag"); e.exports = function (e, t, n, s) { if (e) { var c = n ? e : e.prototype; u(c, o) || a(c, o, { configurable: !0, value: t }), s && !r && i(c, "toString", d) } } }, 6683: (e, t, n) => { var r = n(717), a = n(4540), i = r("keys"); e.exports = function (e) { return i[e] || (i[e] = a(e)) } }, 7976: (e, t, n) => { var r = n(4624), a = n(3438), i = "__core-js_shared__", u = r[i] || a(i, {}); e.exports = u }, 717: (e, t, n) => { var r = n(7840), a = n(7976); (e.exports = function (e, t) { return a[e] || (a[e] = void 0 !== t ? t : {}) })("versions", []).push({ version: "3.8.3", mode: r ? "pure" : "global", copyright: " 2021 Denis Pushkarev (zloirock.ru)" }) }, 7297: (e, t, n) => { var r = n(4392), a = n(4289), i = function (e) { return function (t, n) { var i, u, d = String(a(t)), o = r(n), s = d.length; return o < 0 || o >= s ? e ? "" : void 0 : (i = d.charCodeAt(o)) < 55296 || i > 56319 || o + 1 === s || (u = d.charCodeAt(o + 1)) < 56320 || u > 57343 ? e ? d.charAt(o) : i : e ? d.slice(o, o + 2) : u - 56320 + (i - 55296 << 10) + 65536 } }; e.exports = { codeAt: i(!1), charAt: i(!0) } }, 725: (e, t, n) => { var r = n(4289), a = "[" + n(5940) + "]", i = RegExp("^" + a + a + "*"), u = RegExp(a + a + "*$"), d = function (e) { return function (t) { var n = String(r(t)); return 1 & e && (n = n.replace(i, "")), 2 & e && (n = n.replace(u, "")), n } }; e.exports = { start: d(1), end: d(2), trim: d(3) } }, 669: (e, t, n) => { var r = n(4392), a = Math.max, i = Math.min; e.exports = function (e, t) { var n = r(e); return n < 0 ? a(n + t, 0) : i(n, t) } }, 7099: (e, t, n) => { var r = n(5093), a = n(4289); e.exports = function (e) { return r(a(e)) } }, 4392: e => { var t = Math.ceil, n = Math.floor; e.exports = function (e) { return isNaN(e = +e) ? 0 : (e > 0 ? n : t)(e) } }, 6666: (e, t, n) => { var r = n(4392), a = Math.min; e.exports = function (e) { return e > 0 ? a(r(e), 9007199254740991) : 0 } }, 3026: (e, t, n) => { var r = n(4289); e.exports = function (e) { return Object(r(e)) } }, 965: (e, t, n) => { var r = n(2343); e.exports = function (e, t) { if (!r(e)) return e; var n, a; if (t && "function" == typeof (n = e.toString) && !r(a = n.call(e))) return a; if ("function" == typeof (n = e.valueOf) && !r(a = n.call(e))) return a; if (!t && "function" == typeof (n = e.toString) && !r(a = n.call(e))) return a; throw TypeError("Can't convert object to primitive value") } }, 753: (e, t, n) => { var r = {}; r[n(9525)("toStringTag")] = "z", e.exports = "[object z]" === String(r) }, 4540: e => { var t = 0, n = Math.random(); e.exports = function (e) { return "Symbol(" + String(void 0 === e ? "" : e) + ")_" + (++t + n).toString(36) } }, 2206: (e, t, n) => { var r = n(6696); e.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator }, 6246: (e, t, n) => { var r = n(9525); t.f = r }, 9525: (e, t, n) => { var r = n(4624), a = n(717), i = n(3063), u = n(4540), d = n(6696), o = n(2206), s = a("wks"), c = r.Symbol, f = o ? c : c && c.withoutSetter || u; e.exports = function (e) { return i(s, e) || (d && i(c, e) ? s[e] = c[e] : s[e] = f("Symbol." + e)), s[e] } }, 5940: e => { e.exports = "\t\n\v\f\r \u2028\u2029\ufeff" }, 9201: (e, t, n) => { var r = n(8215), a = n(9249), i = n(410), u = n(2343), d = n(3026), o = n(6666), s = n(4438), c = n(891), f = n(4148), l = n(9525), p = n(4958), h = l("isConcatSpreadable"), m = 9007199254740991, E = "Maximum allowed index exceeded", y = p >= 51 || !a((function () { var e = []; return e[h] = !1, e.concat()[0] !== e })), T = f("concat"), S = function (e) { if (!u(e)) return !1; var t = e[h]; return void 0 !== t ? !!t : i(e) }; r({ target: "Array", proto: !0, forced: !y || !T }, { concat: function (e) { var t, n, r, a, i, u = d(this), f = c(u, 0), l = 0; for (t = -1, r = arguments.length; t < r; t++)if (S(i = -1 === t ? u : arguments[t])) { if (l + (a = o(i.length)) > m) throw TypeError(E); for (n = 0; n < a; n++, l++)n in i && s(f, l, i[n]) } else { if (l >= m) throw TypeError(E); s(f, l++, i) } return f.length = l, f } }) }, 3884: (e, t, n) => { var r = n(8215), a = n(9422); r({ target: "Array", proto: !0, forced: [].forEach != a }, { forEach: a }) }, 6383: (e, t, n) => { var r = n(8215), a = n(7899); r({ target: "Array", stat: !0, forced: !n(1463)((function (e) { Array.from(e) })) }, { from: a }) }, 3554: (e, t, n) => { var r = n(8215), a = n(7788).includes, i = n(7156); r({ target: "Array", proto: !0, forced: !n(8016)("indexOf", { ACCESSORS: !0, 1: 0 }) }, { includes: function (e) { return a(this, e, arguments.length > 1 ? arguments[1] : void 0) } }), i("includes") }, 380: (e, t, n) => { var r = n(8215), a = n(7788).indexOf, i = n(5419), u = n(8016), d = [].indexOf, o = !!d && 1 / [1].indexOf(1, -0) < 0, s = i("indexOf"), c = u("indexOf", { ACCESSORS: !0, 1: 0 }); r({ target: "Array", proto: !0, forced: o || !s || !c }, { indexOf: function (e) { return o ? d.apply(this, arguments) || 0 : a(this, e, arguments.length > 1 ? arguments[1] : void 0) } }) }, 846: (e, t, n) => { n(8215)({ target: "Array", stat: !0 }, { isArray: n(410) }) }, 5843: (e, t, n) => { var r = n(7099), a = n(7156), i = n(3693), u = n(6223), d = n(9020), o = "Array Iterator", s = u.set, c = u.getterFor(o); e.exports = d(Array, "Array", (function (e, t) { s(this, { type: o, target: r(e), index: 0, kind: t }) }), (function () { var e = c(this), t = e.target, n = e.kind, r = e.index++; return !t || r >= t.length ? (e.target = void 0, { value: void 0, done: !0 }) : "keys" == n ? { value: r, done: !1 } : "values" == n ? { value: t[r], done: !1 } : { value: [r, t[r]], done: !1 } }), "values"), i.Arguments = i.Array, a("keys"), a("values"), a("entries") }, 863: (e, t, n) => { var r = n(8215), a = n(9205).map, i = n(4148), u = n(8016), d = i("map"), o = u("map"); r({ target: "Array", proto: !0, forced: !d || !o }, { map: function (e) { return a(this, e, arguments.length > 1 ? arguments[1] : void 0) } }) }, 7830: (e, t, n) => { var r = n(8215), a = n(8079).left, i = n(5419), u = n(8016), d = n(4958), o = n(6213), s = i("reduce"), c = u("reduce", { 1: 0 }); r({ target: "Array", proto: !0, forced: !s || !c || !o && d > 79 && d < 83 }, { reduce: function (e) { return a(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0) } }) }, 607: (e, t, n) => { var r = n(8215), a = n(2343), i = n(410), u = n(669), d = n(6666), o = n(7099), s = n(4438), c = n(9525), f = n(4148), l = n(8016), p = f("slice"), h = l("slice", { ACCESSORS: !0, 0: 0, 1: 2 }), m = c("species"), E = [].slice, y = Math.max; r({ target: "Array", proto: !0, forced: !p || !h }, { slice: function (e, t) { var n, r, c, f = o(this), l = d(f.length), p = u(e, l), h = u(void 0 === t ? l : t, l); if (i(f) && ("function" != typeof (n = f.constructor) || n !== Array && !i(n.prototype) ? a(n) && null === (n = n[m]) && (n = void 0) : n = void 0, n === Array || void 0 === n)) return E.call(f, p, h); for (r = new (void 0 === n ? Array : n)(y(h - p, 0)), c = 0; p < h; p++, c++)p in f && s(r, c, f[p]); return r.length = c, r } }) }, 2567: (e, t, n) => { var r = n(8215), a = n(4168), i = n(3026), u = n(9249), d = n(5419), o = [], s = o.sort, c = u((function () { o.sort(void 0) })), f = u((function () { o.sort(null) })), l = d("sort"); r({ target: "Array", proto: !0, forced: c || !f || !l }, { sort: function (e) { return void 0 === e ? s.call(i(this)) : s.call(i(this), a(e)) } }) }, 8401: (e, t, n) => { var r = n(4624); n(9375)(r.JSON, "JSON", !0) }, 9181: () => { }, 112: (e, t, n) => { n(8215)({ target: "Object", stat: !0, sham: !n(8745) }, { create: n(9721) }) }, 14: (e, t, n) => { var r = n(8215), a = n(8745); r({ target: "Object", stat: !0, forced: !a, sham: !a }, { defineProperty: n(2305).f }) }, 4701: () => { }, 2546: (e, t, n) => { var r = n(8215), a = n(1215); r({ global: !0, forced: parseInt != a }, { parseInt: a }) }, 5642: () => { }, 2758: () => { }, 8587: (e, t, n) => { var r = n(8215), a = n(5846), i = n(4289); r({ target: "String", proto: !0, forced: !n(5423)("includes") }, { includes: function (e) { return !!~String(i(this)).indexOf(a(e), arguments.length > 1 ? arguments[1] : void 0) } }) }, 4035: (e, t, n) => { var r = n(7297).charAt, a = n(6223), i = n(9020), u = "String Iterator", d = a.set, o = a.getterFor(u); i(String, "String", (function (e) { d(this, { type: u, string: String(e), index: 0 }) }), (function () { var e, t = o(this), n = t.string, a = t.index; return a >= n.length ? { value: void 0, done: !0 } : (e = r(n, a), t.index += e.length, { value: e, done: !1 }) })) }, 378: (e, t, n) => { n(7876)("asyncIterator") }, 662: () => { }, 4928: (e, t, n) => { n(7876)("hasInstance") }, 1300: (e, t, n) => { n(7876)("isConcatSpreadable") }, 5993: (e, t, n) => { n(7876)("iterator") }, 4126: (e, t, n) => { var r = n(8215), a = n(4624), i = n(2458), u = n(7840), d = n(8745), o = n(6696), s = n(2206), c = n(9249), f = n(3063), l = n(410), p = n(2343), h = n(9470), m = n(3026), E = n(7099), y = n(965), T = n(8258), S = n(9721), v = n(5961), R = n(4745), L = n(9715), A = n(6142), O = n(6285), b = n(2305), I = n(3786), N = n(768), g = n(886), _ = n(717), U = n(6683), C = n(8942), x = n(4540), M = n(9525), P = n(6246), k = n(7876), D = n(9375), B = n(6223), w = n(9205).forEach, F = U("hidden"), G = "Symbol", Y = M("toPrimitive"), V = B.set, W = B.getterFor(G), q = Object.prototype, j = a.Symbol, K = i("JSON", "stringify"), H = O.f, z = b.f, X = L.f, $ = I.f, J = _("symbols"), Z = _("op-symbols"), Q = _("string-to-symbol-registry"), ee = _("symbol-to-string-registry"), te = _("wks"), ne = a.QObject, re = !ne || !ne.prototype || !ne.prototype.findChild, ae = d && c((function () { return 7 != S(z({}, "a", { get: function () { return z(this, "a", { value: 7 }).a } })).a })) ? function (e, t, n) { var r = H(q, t); r && delete q[t], z(e, t, n), r && e !== q && z(q, t, r) } : z, ie = function (e, t) { var n = J[e] = S(j.prototype); return V(n, { type: G, tag: e, description: t }), d || (n.description = t), n }, ue = s ? function (e) { return "symbol" == typeof e } : function (e) { return Object(e) instanceof j }, de = function (e, t, n) { e === q && de(Z, t, n), h(e); var r = y(t, !0); return h(n), f(J, r) ? (n.enumerable ? (f(e, F) && e[F][r] && (e[F][r] = !1), n = S(n, { enumerable: T(0, !1) })) : (f(e, F) || z(e, F, T(1, {})), e[F][r] = !0), ae(e, r, n)) : z(e, r, n) }, oe = function (e, t) { h(e); var n = E(t), r = v(n).concat(le(n)); return w(r, (function (t) { d && !se.call(n, t) || de(e, t, n[t]) })), e }, se = function (e) { var t = y(e, !0), n = $.call(this, t); return !(this === q && f(J, t) && !f(Z, t)) && (!(n || !f(this, t) || !f(J, t) || f(this, F) && this[F][t]) || n) }, ce = function (e, t) { var n = E(e), r = y(t, !0); if (n !== q || !f(J, r) || f(Z, r)) { var a = H(n, r); return !a || !f(J, r) || f(n, F) && n[F][r] || (a.enumerable = !0), a } }, fe = function (e) { var t = X(E(e)), n = []; return w(t, (function (e) { f(J, e) || f(C, e) || n.push(e) })), n }, le = function (e) { var t = e === q, n = X(t ? Z : E(e)), r = []; return w(n, (function (e) { !f(J, e) || t && !f(q, e) || r.push(J[e]) })), r }; o || (g((j = function () { if (this instanceof j) throw TypeError("Symbol is not a constructor"); var e = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, t = x(e), n = function (e) { this === q && n.call(Z, e), f(this, F) && f(this[F], t) && (this[F][t] = !1), ae(this, t, T(1, e)) }; return d && re && ae(q, t, { configurable: !0, set: n }), ie(t, e) }).prototype, "toString", (function () { return W(this).tag })), g(j, "withoutSetter", (function (e) { return ie(x(e), e) })), I.f = se, b.f = de, O.f = ce, R.f = L.f = fe, A.f = le, P.f = function (e) { return ie(M(e), e) }, d && (z(j.prototype, "description", { configurable: !0, get: function () { return W(this).description } }), u || g(q, "propertyIsEnumerable", se, { unsafe: !0 }))), r({ global: !0, wrap: !0, forced: !o, sham: !o }, { Symbol: j }), w(v(te), (function (e) { k(e) })), r({ target: G, stat: !0, forced: !o }, { for: function (e) { var t = String(e); if (f(Q, t)) return Q[t]; var n = j(t); return Q[t] = n, ee[n] = t, n }, keyFor: function (e) { if (!ue(e)) throw TypeError(e + " is not a symbol"); if (f(ee, e)) return ee[e] }, useSetter: function () { re = !0 }, useSimple: function () { re = !1 } }), r({ target: "Object", stat: !0, forced: !o, sham: !d }, { create: function (e, t) { return void 0 === t ? S(e) : oe(S(e), t) }, defineProperty: de, defineProperties: oe, getOwnPropertyDescriptor: ce }), r({ target: "Object", stat: !0, forced: !o }, { getOwnPropertyNames: fe, getOwnPropertySymbols: le }), r({ target: "Object", stat: !0, forced: c((function () { A.f(1) })) }, { getOwnPropertySymbols: function (e) { return A.f(m(e)) } }), K && r({ target: "JSON", stat: !0, forced: !o || c((function () { var e = j(); return "[null]" != K([e]) || "{}" != K({ a: e }) || "{}" != K(Object(e)) })) }, { stringify: function (e, t, n) { for (var r, a = [e], i = 1; arguments.length > i;)a.push(arguments[i++]); if (r = t, (p(t) || void 0 !== e) && !ue(e)) return l(t) || (t = function (e, t) { if ("function" == typeof r && (t = r.call(this, e, t)), !ue(t)) return t }), a[1] = t, K.apply(null, a) } }), j.prototype[Y] || N(j.prototype, Y, j.prototype.valueOf), D(j, G), C[F] = !0 }, 3798: (e, t, n) => { n(7876)("matchAll") }, 972: (e, t, n) => { n(7876)("match") }, 2951: (e, t, n) => { n(7876)("replace") }, 2284: (e, t, n) => { n(7876)("search") }, 4620: (e, t, n) => { n(7876)("species") }, 4211: (e, t, n) => { n(7876)("split") }, 8197: (e, t, n) => { n(7876)("toPrimitive") }, 4319: (e, t, n) => { n(7876)("toStringTag") }, 1733: (e, t, n) => { n(7876)("unscopables") }, 5466: (e, t, n) => { n(7876)("asyncDispose") }, 2989: (e, t, n) => { n(7876)("dispose") }, 8259: (e, t, n) => { n(7876)("observable") }, 9557: (e, t, n) => { n(7876)("patternMatch") }, 4423: (e, t, n) => { n(7876)("replaceAll") }, 1306: (e, t, n) => { n(5843); var r = n(7810), a = n(4624), i = n(1366), u = n(768), d = n(3693), o = n(9525)("toStringTag"); for (var s in r) { var c = a[s], f = c && c.prototype; f && i(f) !== o && u(f, o, s), d[s] = d.Array } }, 7089: (e, t, n) => { var r = n(6343); e.exports = r }, 2219: (e, t, n) => { var r = n(222); e.exports = r }, 40: (e, t, n) => { var r = n(7422); e.exports = r }, 2453: (e, t, n) => { var r = n(2205); e.exports = r }, 259: (e, t, n) => { var r = n(9158); e.exports = r }, 5113: (e, t, n) => { n(1306); var r = n(40), a = n(1366), i = Array.prototype, u = { DOMTokenList: !0, NodeList: !0 }; e.exports = function (e) { var t = e.forEach; return e === i || e instanceof Array && t === i.forEach || u.hasOwnProperty(a(e)) ? r : t } }, 4541: (e, t, n) => { var r = n(8502); e.exports = r }, 8202: (e, t, n) => { var r = n(6535); e.exports = r }, 4187: (e, t, n) => { var r = n(7500); e.exports = r }, 1121: (e, t, n) => { var r = n(5096); e.exports = r }, 3290: (e, t, n) => { var r = n(3945); e.exports = r }, 4241: (e, t, n) => { var r = n(6812); e.exports = r }, 6486: (e, t, n) => { var r = n(3518); e.exports = r }, 7300: (e, t, n) => { var r = n(2239); e.exports = r }, 5576: (e, t, n) => { var r = n(3408); e.exports = r }, 1690: (e, t, n) => { var r = n(1787); e.exports = r }, 3084: function (e, t) { var n, r; "undefined" != typeof self && self, void 0 === (r = "function" == typeof (n = function () { function e() { } e.prototype.saveState = function () { return { idx: this.idx, input: this.input, groupIdx: this.groupIdx } }, e.prototype.restoreState = function (e) { this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx }, e.prototype.pattern = function (e) { this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/"); var t = this.disjunction(); this.consumeChar("/"); for (var n = { type: "Flags", global: !1, ignoreCase: !1, multiLine: !1, unicode: !1, sticky: !1 }; this.isRegExpFlag();)switch (this.popChar()) { case "g": d(n, "global"); break; case "i": d(n, "ignoreCase"); break; case "m": d(n, "multiLine"); break; case "u": d(n, "unicode"); break; case "y": d(n, "sticky") }if (this.idx !== this.input.length) throw Error("Redundant input: " + this.input.substring(this.idx)); return { type: "Pattern", flags: n, value: t } }, e.prototype.disjunction = function () { var e = []; for (e.push(this.alternative()); "|" === this.peekChar();)this.consumeChar("|"), e.push(this.alternative()); return { type: "Disjunction", value: e } }, e.prototype.alternative = function () { for (var e = []; this.isTerm();)e.push(this.term()); return { type: "Alternative", value: e } }, e.prototype.term = function () { return this.isAssertion() ? this.assertion() : this.atom() }, e.prototype.assertion = function () { switch (this.popChar()) { case "^": return { type: "StartAnchor" }; case "$": return { type: "EndAnchor" }; case "\\": switch (this.popChar()) { case "b": return { type: "WordBoundary" }; case "B": return { type: "NonWordBoundary" } }throw Error("Invalid Assertion Escape"); case "(": var e; switch (this.consumeChar("?"), this.popChar()) { case "=": e = "Lookahead"; break; case "!": e = "NegativeLookahead" }o(e); var t = this.disjunction(); return this.consumeChar(")"), { type: e, value: t } }!function () { throw Error("Internal Error - Should never get here!") }() }, e.prototype.quantifier = function () { var e; switch (this.popChar()) { case "*": e = { atLeast: 0, atMost: 1 / 0 }; break; case "+": e = { atLeast: 1, atMost: 1 / 0 }; break; case "?": e = { atLeast: 0, atMost: 1 }; break; case "{": var t = this.integerIncludingZero(); switch (this.popChar()) { case "}": e = { atLeast: t, atMost: t }; break; case ",": e = this.isDigit() ? { atLeast: t, atMost: this.integerIncludingZero() } : { atLeast: t, atMost: 1 / 0 }, this.consumeChar("}") }o(e) }return o(e), "?" === this.peekChar(0) ? (this.consumeChar("?"), e.greedy = !1) : e.greedy = !0, e.type = "Quantifier", e }, e.prototype.atom = function () { var e; switch (this.peekChar()) { case ".": e = this.dotAll(); break; case "\\": e = this.atomEscape(); break; case "[": e = this.characterClass(); break; case "(": e = this.group() }return void 0 === e && this.isPatternCharacter() && (e = this.patternCharacter()), o(e), this.isQuantifier() && (e.quantifier = this.quantifier()), e }, e.prototype.dotAll = function () { return this.consumeChar("."), { type: "Set", complement: !0, value: [i("\n"), i("\r"), i("\u2028"), i("\u2029")] } }, e.prototype.atomEscape = function () { switch (this.consumeChar("\\"), this.peekChar()) { case "1": case "2": case "3": case "4": case "5": case "6": case "7": case "8": case "9": return this.decimalEscapeAtom(); case "d": case "D": case "s": case "S": case "w": case "W": return this.characterClassEscape(); case "f": case "n": case "r": case "t": case "v": return this.controlEscapeAtom(); case "c": return this.controlLetterEscapeAtom(); case "0": return this.nulCharacterAtom(); case "x": return this.hexEscapeSequenceAtom(); case "u": return this.regExpUnicodeEscapeSequenceAtom(); default: return this.identityEscapeAtom() } }, e.prototype.decimalEscapeAtom = function () { return { type: "GroupBackReference", value: this.positiveInteger() } }, e.prototype.characterClassEscape = function () { var e, t = !1; switch (this.popChar()) { case "d": e = s; break; case "D": e = s, t = !0; break; case "s": e = f; break; case "S": e = f, t = !0; break; case "w": e = c; break; case "W": e = c, t = !0 }return o(e), { type: "Set", value: e, complement: t } }, e.prototype.controlEscapeAtom = function () { var e; switch (this.popChar()) { case "f": e = i("\f"); break; case "n": e = i("\n"); break; case "r": e = i("\r"); break; case "t": e = i("\t"); break; case "v": e = i("\v") }return o(e), { type: "Character", value: e } }, e.prototype.controlLetterEscapeAtom = function () { this.consumeChar("c"); var e = this.popChar(); if (!1 === /[a-zA-Z]/.test(e)) throw Error("Invalid "); return { type: "Character", value: e.toUpperCase().charCodeAt(0) - 64 } }, e.prototype.nulCharacterAtom = function () { return this.consumeChar("0"), { type: "Character", value: i("\0") } }, e.prototype.hexEscapeSequenceAtom = function () { return this.consumeChar("x"), this.parseHexDigits(2) }, e.prototype.regExpUnicodeEscapeSequenceAtom = function () { return this.consumeChar("u"), this.parseHexDigits(4) }, e.prototype.identityEscapeAtom = function () { return { type: "Character", value: i(this.popChar()) } }, e.prototype.classPatternCharacterAtom = function () { switch (this.peekChar()) { case "\n": case "\r": case "\u2028": case "\u2029": case "\\": case "]": throw Error("TBD"); default: return { type: "Character", value: i(this.popChar()) } } }, e.prototype.characterClass = function () { var e = [], t = !1; for (this.consumeChar("["), "^" === this.peekChar(0) && (this.consumeChar("^"), t = !0); this.isClassAtom();) { var n = this.classAtom(); if ("Character" === n.type && this.isRangeDash()) { this.consumeChar("-"); var r = this.classAtom(); if ("Character" === r.type) { if (r.value < n.value) throw Error("Range out of order in character class"); e.push({ from: n.value, to: r.value }) } else u(n.value, e), e.push(i("-")), u(r.value, e) } else u(n.value, e) } return this.consumeChar("]"), { type: "Set", complement: t, value: e } }, e.prototype.classAtom = function () { switch (this.peekChar()) { case "]": case "\n": case "\r": case "\u2028": case "\u2029": throw Error("TBD"); case "\\": return this.classEscape(); default: return this.classPatternCharacterAtom() } }, e.prototype.classEscape = function () { switch (this.consumeChar("\\"), this.peekChar()) { case "b": return this.consumeChar("b"), { type: "Character", value: i("\b") }; case "d": case "D": case "s": case "S": case "w": case "W": return this.characterClassEscape(); case "f": case "n": case "r": case "t": case "v": return this.controlEscapeAtom(); case "c": return this.controlLetterEscapeAtom(); case "0": return this.nulCharacterAtom(); case "x": return this.hexEscapeSequenceAtom(); case "u": return this.regExpUnicodeEscapeSequenceAtom(); default: return this.identityEscapeAtom() } }, e.prototype.group = function () { var e = !0; switch (this.consumeChar("("), this.peekChar(0)) { case "?": this.consumeChar("?"), this.consumeChar(":"), e = !1; break; default: this.groupIdx++ }var t = this.disjunction(); this.consumeChar(")"); var n = { type: "Group", capturing: e, value: t }; return e && (n.idx = this.groupIdx), n }, e.prototype.positiveInteger = function () { var e = this.popChar(); if (!1 === a.test(e)) throw Error("Expecting a positive integer"); for (; r.test(this.peekChar(0));)e += this.popChar(); return parseInt(e, 10) }, e.prototype.integerIncludingZero = function () { var e = this.popChar(); if (!1 === r.test(e)) throw Error("Expecting an integer"); for (; r.test(this.peekChar(0));)e += this.popChar(); return parseInt(e, 10) }, e.prototype.patternCharacter = function () { var e = this.popChar(); switch (e) { case "\n": case "\r": case "\u2028": case "\u2029": case "^": case "$": case "\\": case ".": case "*": case "+": case "?": case "(": case ")": case "[": case "|": throw Error("TBD"); default: return { type: "Character", value: i(e) } } }, e.prototype.isRegExpFlag = function () { switch (this.peekChar(0)) { case "g": case "i": case "m": case "u": case "y": return !0; default: return !1 } }, e.prototype.isRangeDash = function () { return "-" === this.peekChar() && this.isClassAtom(1) }, e.prototype.isDigit = function () { return r.test(this.peekChar(0)) }, e.prototype.isClassAtom = function (e) { switch (void 0 === e && (e = 0), this.peekChar(e)) { case "]": case "\n": case "\r": case "\u2028": case "\u2029": return !1; default: return !0 } }, e.prototype.isTerm = function () { return this.isAtom() || this.isAssertion() }, e.prototype.isAtom = function () { if (this.isPatternCharacter()) return !0; switch (this.peekChar(0)) { case ".": case "\\": case "[": case "(": return !0; default: return !1 } }, e.prototype.isAssertion = function () { switch (this.peekChar(0)) { case "^": case "$": return !0; case "\\": switch (this.peekChar(1)) { case "b": case "B": return !0; default: return !1 }case "(": return "?" === this.peekChar(1) && ("=" === this.peekChar(2) || "!" === this.peekChar(2)); default: return !1 } }, e.prototype.isQuantifier = function () { var e = this.saveState(); try { return this.quantifier() } catch (e) { return !1 } finally { this.restoreState(e) } }, e.prototype.isPatternCharacter = function () { switch (this.peekChar()) { case "^": case "$": case "\\": case ".": case "*": case "+": case "?": case "(": case ")": case "[": case "|": case "/": case "\n": case "\r": case "\u2028": case "\u2029": return !1; default: return !0 } }, e.prototype.parseHexDigits = function (e) { for (var t = "", r = 0; r < e; r++) { var a = this.popChar(); if (!1 === n.test(a)) throw Error("Expecting a HexDecimal digits"); t += a } return { type: "Character", value: parseInt(t, 16) } }, e.prototype.peekChar = function (e) { return void 0 === e && (e = 0), this.input[this.idx + e] }, e.prototype.popChar = function () { var e = this.peekChar(0); return this.consumeChar(), e }, e.prototype.consumeChar = function (e) { if (void 0 !== e && this.input[this.idx] !== e) throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx); if (this.idx >= this.input.length) throw Error("Unexpected end of input"); this.idx++ }; var t, n = /[0-9a-fA-F]/, r = /[0-9]/, a = /[1-9]/; function i(e) { return e.charCodeAt(0) } function u(e, t) { void 0 !== e.length ? e.forEach((function (e) { t.push(e) })) : t.push(e) } function d(e, t) { if (!0 === e[t]) throw "duplicate flag " + t; e[t] = !0 } function o(e) { if (void 0 === e) throw Error("Internal Error - Should never get here!") } var s = []; for (t = i("0"); t <= i("9"); t++)s.push(t); var c = [i("_")].concat(s); for (t = i("a"); t <= i("z"); t++)c.push(t); for (t = i("A"); t <= i("Z"); t++)c.push(t); var f = [i(" "), i("\f"), i("\n"), i("\r"), i("\t"), i("\v"), i("\t"), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i(""), i("\u2028"), i("\u2029"), i(""), i(""), i(""), i("\ufeff")]; function l() { } return l.prototype.visitChildren = function (e) { for (var t in e) { var n = e[t]; e.hasOwnProperty(t) && (void 0 !== n.type ? this.visit(n) : Array.isArray(n) && n.forEach((function (e) { this.visit(e) }), this)) } }, l.prototype.visit = function (e) { switch (e.type) { case "Pattern": this.visitPattern(e); break; case "Flags": this.visitFlags(e); break; case "Disjunction": this.visitDisjunction(e); break; case "Alternative": this.visitAlternative(e); break; case "StartAnchor": this.visitStartAnchor(e); break; case "EndAnchor": this.visitEndAnchor(e); break; case "WordBoundary": this.visitWordBoundary(e); break; case "NonWordBoundary": this.visitNonWordBoundary(e); break; case "Lookahead": this.visitLookahead(e); break; case "NegativeLookahead": this.visitNegativeLookahead(e); break; case "Character": this.visitCharacter(e); break; case "Set": this.visitSet(e); break; case "Group": this.visitGroup(e); break; case "GroupBackReference": this.visitGroupBackReference(e); break; case "Quantifier": this.visitQuantifier(e) }this.visitChildren(e) }, l.prototype.visitPattern = function (e) { }, l.prototype.visitFlags = function (e) { }, l.prototype.visitDisjunction = function (e) { }, l.prototype.visitAlternative = function (e) { }, l.prototype.visitStartAnchor = function (e) { }, l.prototype.visitEndAnchor = function (e) { }, l.prototype.visitWordBoundary = function (e) { }, l.prototype.visitNonWordBoundary = function (e) { }, l.prototype.visitLookahead = function (e) { }, l.prototype.visitNegativeLookahead = function (e) { }, l.prototype.visitCharacter = function (e) { }, l.prototype.visitSet = function (e) { }, l.prototype.visitGroup = function (e) { }, l.prototype.visitGroupBackReference = function (e) { }, l.prototype.visitQuantifier = function (e) { }, { RegExpParser: e, BaseRegExpVisitor: l, VERSION: "0.3.5" } }) ? n.apply(t, []) : n) || (e.exports = r) }, 6220: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(5367)), i = r(n(1698)), u = r(n(3304)), d = r(n(1958)); t.default = function (e) { var t = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g, n = e.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, t], "g", { conjunction: "or" }); function r(e) { var t = /^(?:\(\?:\))*\^/, n = /\$(?:\(\?:\))*$/; return t.test(e) && n.test(e) && n.test(e.replace(/\\[\s\S]/g, "")) ? e.replace(t, "").replace(n, "") : e } function o(t, n) { var r = n ? "x" : ""; return e.isRegExp(t) ? t.xregexp && t.xregexp.captureNames ? t : e(t.source, r) : e(t, r) } function s(t) { return t instanceof RegExp ? t : e.escape(t) } function c(e, t, n) { return e["subpattern".concat(n)] = t, e } function f(e, t, n) { return e + (t < n.length - 1 ? "{{subpattern".concat(t, "}}") : "") } e.tag = function (t) { return function (n) { for (var r, a, i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), l = 1; l < i; l++)o[l - 1] = arguments[l]; var p = (0, d.default)(r = (0, u.default)(o).call(o, s)).call(r, c, {}), h = (0, u.default)(a = n.raw).call(a, f).join(""); return e.build(h, p, t) } }, e.build = function (u, d, s) { s = s || ""; var c = (0, i.default)(s).call(s, "x"), f = /^\(\?([\w$]+)\)/.exec(u); f && (s = e._clipDuplicates(s + f[1])); var l = {}; for (var p in d) if (d.hasOwnProperty(p)) { var h = o(d[p], c); l[p] = { pattern: r(h.source), names: h.xregexp.captureNames || [] } } var m, E = o(u, c), y = 0, T = 0, S = [0], v = E.xregexp.captureNames || [], R = E.source.replace(n, (function (e, n, r, i, u) { var d, o, s, c = n || r; if (c) { var f; if (!l.hasOwnProperty(c)) throw new ReferenceError("Undefined property ".concat(e)); n ? (d = v[T], S[++T] = ++y, o = "(?<".concat(d || c, ">")) : o = "(?:", m = y; var p = l[c].pattern.replace(t, (function (e, t, n) { if (t) { if (d = l[c].names[y - m], ++y, d) return "(?<".concat(d, ">") } else if (n) return s = +n - 1, l[c].names[s] ? "\\k<".concat(l[c].names[s], ">") : "\\".concat(+n + m); return e })); return (0, a.default)(f = "".concat(o)).call(f, p, ")") } if (i) { if (d = v[T], S[++T] = ++y, d) return "(?<".concat(d, ">") } else if (u) return v[s = +u - 1] ? "\\k<".concat(v[s], ">") : "\\".concat(S[+u]); return e })); return e(R, s) } }, e.exports = t.default }, 9561: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(2576)), i = r(n(5367)), u = r(n(1698)); t.default = function (e) { function t(e, t, n, r) { return { name: e, value: t, start: n, end: r } } e.matchRecursive = function (n, r, d, o, s) { o = o || "", s = s || {}; var c, f, l, p, h, m = (0, u.default)(o).call(o, "g"), E = (0, u.default)(o).call(o, "y"), y = o.replace(/y/g, ""), T = s.escapeChar, S = s.valueNames, v = [], R = 0, L = 0, A = 0, O = 0; if (r = e(r, y), d = e(d, y), T) { var b, I; if (T.length > 1) throw new Error("Cannot use more than one escape character"); T = e.escape(T), h = new RegExp((0, i.default)(b = (0, i.default)(I = "(?:".concat(T, "[\\S\\s]|(?:(?!")).call(I, e.union([r, d], "", { conjunction: "or" }).source, ")[^")).call(b, T, "])+)+"), o.replace(/[^imu]+/g, "")) } for (; ;) { if (T && (A += (e.exec(n, h, A, "sticky") || [""])[0].length), l = e.exec(n, r, A), p = e.exec(n, d, A), l && p && (l.index <= p.index ? p = null : l = null), l || p) A = (L = (l || p).index) + (l || p)[0].length; else if (!R) break; if (E && !R && L > O) break; if (l) R || (c = L, f = A), ++R; else { if (!p || !R) throw new Error("Unbalanced delimiter found in string"); if (!--R && (S ? (S[0] && c > O && v.push(t(S[0], (0, a.default)(n).call(n, O, c), O, c)), S[1] && v.push(t(S[1], (0, a.default)(n).call(n, c, f), c, f)), S[2] && v.push(t(S[2], (0, a.default)(n).call(n, f, L), f, L)), S[3] && v.push(t(S[3], (0, a.default)(n).call(n, L, A), L, A))) : v.push((0, a.default)(n).call(n, f, L)), O = A, !m)) break } L === A && ++A } return m && !E && S && S[0] && n.length > O && v.push(t(S[0], (0, a.default)(n).call(n, O), O, n.length)), v } }, e.exports = t.default }, 1099: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(153)), i = r(n(2106)), u = r(n(7671)), d = r(n(7640)), o = r(n(5507)), s = r(n(2576)), c = r(n(1698)), f = r(n(5367)), l = r(n(523)); function p(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } t.default = function (e) { var t = {}, n = e._dec, r = e._hex, h = e._pad4; function m(e) { return e.replace(/[- _]+/g, "").toLowerCase() } function E(e) { var t = /^\\[xu](.+)/.exec(e); return t ? n(t[1]) : e.charCodeAt("\\" === e[0] ? 1 : 0) } e.addToken(/\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/, (function (n, a, i) { var u = "P" === n[1] || !!n[2], d = (0, c.default)(i).call(i, "A"), o = m(n[4] || n[3]), s = t[o]; if ("P" === n[1] && n[2]) throw new SyntaxError("Invalid double negation " + n[0]); if (!t.hasOwnProperty(o)) throw new SyntaxError("Unknown Unicode token " + n[0]); if (s.inverseOf) { var p; if (o = m(s.inverseOf), !t.hasOwnProperty(o)) throw new ReferenceError((0, f.default)(p = "".concat("Unicode token missing data " + n[0], " -> ")).call(p, s.inverseOf)); s = t[o], u = !u } if (!s.bmp && !d) throw new SyntaxError("Astral mode required for Unicode token " + n[0]); if (d) { if ("class" === a) throw new SyntaxError("Astral mode does not support Unicode tokens within character classes"); return function (e, n) { var r = n ? "a!" : "a="; return t[e][r] || (t[e][r] = function (e, n) { var r, a, i = t[e], u = ""; return i.bmp && !i.isBmpLast && (u = (0, f.default)(r = "[".concat(i.bmp, "]")).call(r, i.astral ? "|" : "")), i.astral && (u += i.astral), i.isBmpLast && i.bmp && (u += (0, f.default)(a = "".concat(i.astral ? "|" : "", "[")).call(a, i.bmp, "]")), n ? "(?:(?!".concat(u, ")(?:[\ud800-\udbff][\udc00-\udfff]|[\0-]))") : "(?:".concat(u, ")") }(e, n)) }(o, u) } return "class" === a ? u ? function (n) { var a, i, u; return t[n]["b!"] || (t[n]["b!"] = (a = t[n].bmp, i = "", u = -1, (0, l.default)(e).call(e, a, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, (function (e) { var t = E(e[1]); t > u + 1 && (i += "\\u".concat(h(r(u + 1))), t > u + 2 && (i += "-\\u".concat(h(r(t - 1))))), u = E(e[2] || e[1]) })), u < 65535 && (i += "\\u".concat(h(r(u + 1))), u < 65534 && (i += "-\\uFFFF")), i)) }(o) : s.bmp : "".concat((u ? "[^" : "[") + s.bmp, "]") }), { scope: "all", optionalFlags: "A", leadChar: "\\" }), e.addUnicodeData = function (n) { var r, c = function (e, t) { var n; if (void 0 === d.default || null == (0, u.default)(e)) { if ((0, i.default)(e) || (n = function (e, t) { var n; if (e) { if ("string" == typeof e) return p(e, t); var r = (0, s.default)(n = Object.prototype.toString.call(e)).call(n, 8, -1); return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? (0, o.default)(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? p(e, t) : void 0 } }(e)) || t && e && "number" == typeof e.length) { n && (e = n); var r = 0, c = function () { }; return { s: c, n: function () { return r >= e.length ? { done: !0 } : { done: !1, value: e[r++] } }, e: function (e) { throw e }, f: c } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var f, l = !0, h = !1; return { s: function () { n = (0, a.default)(e) }, n: function () { var e = n.next(); return l = e.done, e }, e: function (e) { h = !0, f = e }, f: function () { try { l || null == n.return || n.return() } finally { if (h) throw f } } } }(n); try { for (c.s(); !(r = c.n()).done;) { var f = r.value; if (!f.name) throw new Error("Unicode token requires name"); if (!(f.inverseOf || f.bmp || f.astral)) throw new Error("Unicode token has no character data " + f.name); t[m(f.name)] = f, f.alias && (t[m(f.alias)] = f) } } catch (e) { c.e(e) } finally { c.f() } e.cache.flush("patterns") }, e._getUnicodeProperty = function (e) { var n = m(e); return t[n] } }, e.exports = t.default }, 2559: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(2566)); t.default = function (e) { if (!e.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Blocks"); e.addUnicodeData(a.default) }, e.exports = t.default }, 9858: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(2444)); t.default = function (e) { if (!e.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Categories"); e.addUnicodeData(a.default) }, e.exports = t.default }, 118: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(8021)); t.default = function (e) { if (!e.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Properties"); var t = a.default; t.push({ name: "Assigned", inverseOf: "Cn" }), e.addUnicodeData(t) }, e.exports = t.default }, 7068: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(6783)); t.default = function (e) { if (!e.addUnicodeData) throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts"); e.addUnicodeData(a.default) }, e.exports = t.default }, 3414: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(2769)), i = r(n(6220)), u = r(n(9561)), d = r(n(1099)), o = r(n(2559)), s = r(n(9858)), c = r(n(118)), f = r(n(7068)); (0, i.default)(a.default), (0, u.default)(a.default), (0, d.default)(a.default), (0, o.default)(a.default), (0, s.default)(a.default), (0, c.default)(a.default), (0, f.default)(a.default); var l = a.default; t.default = l, e.exports = t.default }, 2769: (e, t, n) => { var r = n(575); n(8640)(t, "__esModule", { value: !0 }), t.default = void 0; var a = r(n(153)), i = r(n(2106)), u = r(n(7671)), d = r(n(7640)), o = r(n(5507)), s = r(n(5367)), c = r(n(6448)), f = r(n(720)), l = r(n(6748)), p = r(n(523)), h = r(n(1698)), m = r(n(6013)), E = r(n(2576)), y = r(n(1482)), T = r(n(7800)); function S(e, t) { var n; if (void 0 === d.default || null == (0, u.default)(e)) { if ((0, i.default)(e) || (n = function (e, t) { var n; if (e) { if ("string" == typeof e) return v(e, t); var r = (0, E.default)(n = Object.prototype.toString.call(e)).call(n, 8, -1); return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? (0, o.default)(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? v(e, t) : void 0 } }(e)) || t && e && "number" == typeof e.length) { n && (e = n); var r = 0, s = function () { }; return { s, n: function () { return r >= e.length ? { done: !0 } : { done: !1, value: e[r++] } }, e: function (e) { throw e }, f: s } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var c, f = !0, l = !1; return { s: function () { n = (0, a.default)(e) }, n: function () { var e = n.next(); return f = e.done, e }, e: function (e) { l = !0, c = e }, f: function () { try { f || null == n.return || n.return() } finally { if (l) throw c } } } } function v(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } var R = { astral: !1, namespacing: !1 }, L = { exec: RegExp.prototype.exec, test: RegExp.prototype.test, match: String.prototype.match, replace: String.prototype.replace, split: String.prototype.split }, A = {}, O = {}, b = {}, I = [], N = "default", g = "class", _ = { default: /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/, class: /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/ }, U = /\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g, C = void 0 === L.exec.call(/()??/, "")[1], x = void 0 !== (0, T.default)(/x/), M = {}.toString; function P(e) { var t = !0; try { new RegExp("", e), "y" === e && ".." === ".a".replace(new RegExp("a", "gy"), ".") && (t = !1) } catch (e) { t = !1 } return t } var k = P("u"), D = P("y"), B = { g: !0, i: !0, m: !0, u: k, y: D }; function w(e, t, n, r, a) { var i; if (e.xregexp = { captureNames: t }, a) return e; if (e.__proto__) e.__proto__ = Z.prototype; else for (var u in Z.prototype) e[u] = Z.prototype[u]; return e.xregexp.source = n, e.xregexp.flags = r ? (0, y.default)(i = r.split("")).call(i).join("") : r, e } function F(e) { return L.replace.call(e, /([\s\S])(?=[\s\S]*\1)/g, "") } function G(e, t) { var n; if (!Z.isRegExp(e)) throw new TypeError("Type RegExp expected"); var r = e.xregexp || {}, a = function (e) { return x ? (0, T.default)(e) : L.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(e))[1] }(e), i = "", u = "", d = null, o = null; return (t = t || {}).removeG && (u += "g"), t.removeY && (u += "y"), u && (a = L.replace.call(a, new RegExp("[".concat(u, "]+"), "g"), "")), t.addG && (i += "g"), t.addY && (i += "y"), i && (a = F(a + i)), t.isInternalOnly || (void 0 !== r.source && (d = r.source), null != (0, T.default)(r) && (o = i ? F((0, T.default)(r) + i) : (0, T.default)(r))), w(new RegExp(t.source || e.source, a), function (e) { return !(!e.xregexp || !e.xregexp.captureNames) }(e) ? (0, E.default)(n = r.captureNames).call(n, 0) : null, d, o, t.isInternalOnly) } function Y(e) { return (0, m.default)(e, 16) } function V(e, t, n) { return "(" === e.input[e.index - 1] || ")" === e.input[e.index + e[0].length] || "|" === e.input[e.index - 1] || "|" === e.input[e.index + e[0].length] || e.index < 1 || e.index + e[0].length >= e.input.length || L.test.call(/^\(\?[:=!]/, e.input.substr(e.index - 3, 3)) || function (e, t, n) { return L.test.call((0, h.default)(n).call(n, "x") ? /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, (0, E.default)(e).call(e, t)) }(e.input, e.index + e[0].length, n) ? "" : "(?:)" } function W(e) { return (0, m.default)(e, 10).toString(16) } function q(e, t) { return M.call(e) === "[object ".concat(t, "]") } function j(e) { for (; e.length < 4;)e = "0".concat(e); return e } function K(e) { var t = {}; return q(e, "String") ? ((0, p.default)(Z).call(Z, e, /[^\s,]+/, (function (e) { t[e] = !0 })), t) : e } function H(e) { if (!/^[\w$]$/.test(e)) throw new Error("Flag must be a single character A-Za-z0-9_$"); B[e] = !0 } function z(e, t, n, r, a) { for (var i, u, d = I.length, o = e[n], s = null; d--;)if (!((u = I[d]).leadChar && u.leadChar !== o || u.scope !== r && "all" !== u.scope || u.flag && !(0, h.default)(t).call(t, u.flag)) && (i = Z.exec(e, u.regex, n, "sticky"))) { s = { matchLength: i[0].length, output: u.handler.call(a, i, r, t), reparse: u.reparse }; break } return s } function X(e) { R.astral = e } function $(e) { R.namespacing = e } function J(e) { if (null == e) throw new TypeError("Cannot convert null or undefined to object"); return e } function Z(e, t) { if (Z.isRegExp(e)) { if (void 0 !== t) throw new TypeError("Cannot supply flags when copying a RegExp"); return G(e) } if (e = void 0 === e ? "" : String(e), t = void 0 === t ? "" : String(t), Z.isInstalled("astral") && !(0, h.default)(t).call(t, "A") && (t += "A"), b[e] || (b[e] = {}), !b[e][t]) { for (var n, r = { hasNamedCapture: !1, captureNames: [] }, a = N, i = "", u = 0, d = function (e, t) { if (F(t) !== t) throw new SyntaxError("Invalid duplicate regex flag ".concat(t)); e = L.replace.call(e, /^\(\?([\w$]+)\)/, (function (e, n) { if (L.test.call(/[gy]/, n)) throw new SyntaxError("Cannot use flag g or y in mode modifier ".concat(e)); return t = F(t + n), "" })); var n, r = S(t); try { for (r.s(); !(n = r.n()).done;) { var a = n.value; if (!B[a]) throw new SyntaxError("Unknown regex flag ".concat(a)) } } catch (e) { r.e(e) } finally { r.f() } return { pattern: e, flags: t } }(e, t), o = d.pattern, s = (0, T.default)(d); u < o.length;) { do { (n = z(o, s, u, a, r)) && n.reparse && (o = (0, E.default)(o).call(o, 0, u) + n.output + (0, E.default)(o).call(o, u + n.matchLength)) } while (n && n.reparse); if (n) i += n.output, u += n.matchLength || 1; else { var c = Z.exec(o, _[a], u, "sticky"), f = (0, l.default)(c, 1)[0]; i += f, u += f.length, "[" === f && a === N ? a = g : "]" === f && a === g && (a = N) } } b[e][t] = { pattern: L.replace.call(i, /(?:\(\?:\))+/g, "(?:)"), flags: L.replace.call(s, /[^gimuy]+/g, ""), captures: r.hasNamedCapture ? r.captureNames : null } } var p = b[e][t]; return w(new RegExp(p.pattern, (0, T.default)(p)), p.captures, e, t) } Z.prototype = /(?:)/, Z.version = "4.4.1", Z._clipDuplicates = F, Z._hasNativeFlag = P, Z._dec = Y, Z._hex = W, Z._pad4 = j, Z.addToken = function (e, t, n) { var r = (n = n || {}).optionalFlags; if (n.flag && H(n.flag), r) { var a, i = S(r = L.split.call(r, "")); try { for (i.s(); !(a = i.n()).done;)H(a.value) } catch (e) { i.e(e) } finally { i.f() } } I.push({ regex: G(e, { addG: !0, addY: D, isInternalOnly: !0 }), handler: t, scope: n.scope || N, flag: n.flag, reparse: n.reparse, leadChar: n.leadChar }), Z.cache.flush("patterns") }, Z.cache = function (e, t) { return O[e] || (O[e] = {}), O[e][t] || (O[e][t] = Z(e, t)) }, Z.cache.flush = function (e) { "patterns" === e ? b = {} : O = {} }, Z.escape = function (e) { return L.replace.call(J(e), /[-\[\]{}()*+?.,\\^$|#\s]/g, "\\$&") }, Z.exec = function (e, t, n, r) { var a, i, u = "g", d = !1; (a = D && !!(r || t.sticky && !1 !== r)) ? u += "y" : r && (d = !0, u += "FakeY"), t.xregexp = t.xregexp || {}; var o = t.xregexp[u] || (t.xregexp[u] = G(t, { addG: !0, addY: a, source: d ? "".concat(t.source, "|()") : void 0, removeY: !1 === r, isInternalOnly: !0 })); return n = n || 0, o.lastIndex = n, i = A.exec.call(o, e), d && i && "" === i.pop() && (i = null), t.global && (t.lastIndex = i ? o.lastIndex : 0), i }, Z.forEach = function (e, t, n) { for (var r, a = 0, i = -1; r = Z.exec(e, t, a);)n(r, ++i, e, t), a = r.index + (r[0].length || 1) }, Z.globalize = function (e) { return G(e, { addG: !0 }) }, Z.install = function (e) { e = K(e), !R.astral && e.astral && X(!0), !R.namespacing && e.namespacing && $(!0) }, Z.isInstalled = function (e) { return !!R[e] }, Z.isRegExp = function (e) { return "[object RegExp]" === M.call(e) }, Z.match = function (e, t, n) { var r = t.global && "one" !== n || "all" === n, a = (r ? "g" : "") + (t.sticky ? "y" : "") || "noGY"; t.xregexp = t.xregexp || {}; var i = t.xregexp[a] || (t.xregexp[a] = G(t, { addG: !!r, removeG: "one" === n, isInternalOnly: !0 })), u = L.match.call(J(e), i); return t.global && (t.lastIndex = "one" === n && u ? u.index + u[0].length : 0), r ? u || [] : u && u[0] }, Z.matchChain = function (e, t) { return function e(n, r) { var a = t[r].regex ? t[r] : { regex: t[r] }, i = []; function u(e) { if (a.backref) { var t = "Backreference to undefined group: ".concat(a.backref), n = isNaN(a.backref); if (n && Z.isInstalled("namespacing")) { if (!(a.backref in e.groups)) throw new ReferenceError(t) } else if (!e.hasOwnProperty(a.backref)) throw new ReferenceError(t); var r = n && Z.isInstalled("namespacing") ? e.groups[a.backref] : e[a.backref]; i.push(r || "") } else i.push(e[0]) } var d, o = S(n); try { for (o.s(); !(d = o.n()).done;) { var s = d.value; (0, p.default)(Z).call(Z, s, a.regex, u) } } catch (e) { o.e(e) } finally { o.f() } return r !== t.length - 1 && i.length ? e(i, r + 1) : i }([e], 0) }, Z.replace = function (e, t, n, r) { var a = Z.isRegExp(t), i = t.global && "one" !== r || "all" === r, u = (i ? "g" : "") + (t.sticky ? "y" : "") || "noGY", d = t; a ? (t.xregexp = t.xregexp || {}, d = t.xregexp[u] || (t.xregexp[u] = G(t, { addG: !!i, removeG: "one" === r, isInternalOnly: !0 }))) : i && (d = new RegExp(Z.escape(String(t)), "g")); var o = A.replace.call(J(e), d, n); return a && t.global && (t.lastIndex = 0), o }, Z.replaceEach = function (e, t) { var n, r = S(t); try { for (r.s(); !(n = r.n()).done;) { var a = n.value; e = Z.replace(e, a[0], a[1], a[2]) } } catch (e) { r.e(e) } finally { r.f() } return e }, Z.split = function (e, t, n) { return A.split.call(J(e), t, n) }, Z.test = function (e, t, n, r) { return !!Z.exec(e, t, n, r) }, Z.uninstall = function (e) { e = K(e), R.astral && e.astral && X(!1), R.namespacing && e.namespacing && $(!1) }, Z.union = function (e, t, n) { var r, a, i = (n = n || {}).conjunction || "or", u = 0; function d(e, t, n) { var i = a[u - r]; if (t) { if (++u, i) return "(?<".concat(i, ">") } else if (n) return "\\".concat(+n + r); return e } if (!q(e, "Array") || !e.length) throw new TypeError("Must provide a nonempty array of patterns to merge"); var o, s = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g, c = [], f = S(e); try { for (f.s(); !(o = f.n()).done;) { var l = o.value; Z.isRegExp(l) ? (r = u, a = l.xregexp && l.xregexp.captureNames || [], c.push(L.replace.call(Z(l.source).source, s, d))) : c.push(Z.escape(l)) } } catch (e) { f.e(e) } finally { f.f() } var p = "none" === i ? "" : "|"; return Z(c.join(p), t) }, A.exec = function (e) { var t = this.lastIndex, n = L.exec.apply(this, arguments); if (n) { if (!C && n.length > 1 && (0, h.default)(n).call(n, "")) { var r, a = G(this, { removeG: !0, isInternalOnly: !0 }); L.replace.call((0, E.default)(r = String(e)).call(r, n.index), a, (function () { for (var e = arguments.length, t = 1; t < e - 2; ++t)void 0 === (t < 0 || arguments.length <= t ? void 0 : arguments[t]) && (n[t] = void 0) })) } var i = n; if (Z.isInstalled("namespacing") && (n.groups = (0, f.default)(null), i = n.groups), this.xregexp && this.xregexp.captureNames) for (var u = 1; u < n.length; ++u) { var d = this.xregexp.captureNames[u - 1]; d && (i[d] = n[u]) } this.global && !n[0].length && this.lastIndex > n.index && (this.lastIndex = n.index) } return this.global || (this.lastIndex = t), n }, A.test = function (e) { return !!A.exec.call(this, e) }, A.match = function (e) { if (Z.isRegExp(e)) { if (e.global) { var t = L.match.apply(this, arguments); return e.lastIndex = 0, t } } else e = new RegExp(e); return A.exec.call(e, J(this)) }, A.replace = function (e, t) { var n, r, a, i = Z.isRegExp(e); return i ? (e.xregexp && (r = e.xregexp.captureNames), n = e.lastIndex) : e += "", a = q(t, "Function") ? L.replace.call(String(this), e, (function () { for (var e = arguments.length, n = new Array(e), a = 0; a < e; a++)n[a] = arguments[a]; if (r) { var i; Z.isInstalled("namespacing") ? (i = (0, f.default)(null), n.push(i)) : (n[0] = new String(n[0]), i = n[0]); for (var u = 0; u < r.length; ++u)r[u] && (i[r[u]] = n[u + 1]) } return t.apply(void 0, n) })) : L.replace.call(null == this ? this : String(this), e, (function () { for (var e = arguments.length, n = new Array(e), a = 0; a < e; a++)n[a] = arguments[a]; return L.replace.call(String(t), U, i); function i(e, t, a, i) { if (t = t || a) { var u = +t; if (u <= n.length - 3) return n[u] || ""; if ((u = r ? (0, c.default)(r).call(r, t) : -1) < 0) throw new SyntaxError("Backreference to undefined group ".concat(e)); return n[u + 1] || "" } if ("$" === i) return "$"; if ("&" === i || 0 == +i) return n[0]; var d, o; if ("`" === i) return (0, E.default)(d = n[n.length - 1]).call(d, 0, n[n.length - 2]); if ("'" === i) return (0, E.default)(o = n[n.length - 1]).call(o, n[n.length - 2] + n[0].length); if (i = +i, !isNaN(i)) { if (i > n.length - 3) throw new SyntaxError("Backreference to undefined group ".concat(e)); return n[i] || "" } throw new SyntaxError("Invalid token ".concat(e)) } })), i && (e.global ? e.lastIndex = 0 : e.lastIndex = n), a }, A.split = function (e, t) { if (!Z.isRegExp(e)) return L.split.apply(this, arguments); var n, r = String(this), a = [], i = e.lastIndex, u = 0; return t = (void 0 === t ? -1 : t) >>> 0, (0, p.default)(Z).call(Z, r, e, (function (e) { e.index + e[0].length > u && (a.push((0, E.default)(r).call(r, u, e.index)), e.length > 1 && e.index < r.length && Array.prototype.push.apply(a, (0, E.default)(e).call(e, 1)), n = e[0].length, u = e.index + n) })), u === r.length ? L.test.call(e, "") && !n || a.push("") : a.push((0, E.default)(r).call(r, u)), e.lastIndex = i, a.length > t ? (0, E.default)(a).call(a, 0, t) : a }, Z.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, (function (e, t) { if ("B" === e[1] && t === N) return e[0]; throw new SyntaxError("Invalid escape ".concat(e[0])) }), { scope: "all", leadChar: "\\" }), Z.addToken(/\\u{([\dA-Fa-f]+)}/, (function (e, t, n) { var r = Y(e[1]); if (r > 1114111) throw new SyntaxError("Invalid Unicode code point ".concat(e[0])); if (r <= 65535) return "\\u".concat(j(W(r))); if (k && (0, h.default)(n).call(n, "u")) return e[0]; throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u") }), { scope: "all", leadChar: "\\" }), Z.addToken(/\[(\^?)\]/, (function (e) { return e[1] ? "[\\s\\S]" : "\\b\\B" }), { leadChar: "[" }), Z.addToken(/\(\?#[^)]*\)/, V, { leadChar: "(" }), Z.addToken(/\s+|#[^\n]*\n?/, V, { flag: "x" }), Z.addToken(/\./, (function () { return "[\\s\\S]" }), { flag: "s", leadChar: "." }), Z.addToken(/\\k<([\w$]+)>/, (function (e) { var t, n, r = isNaN(e[1]) ? (0, c.default)(t = this.captureNames).call(t, e[1]) + 1 : +e[1], a = e.index + e[0].length; if (!r || r > this.captureNames.length) throw new SyntaxError("Backreference to undefined group ".concat(e[0])); return (0, s.default)(n = "\\".concat(r)).call(n, a === e.input.length || isNaN(e.input[a]) ? "" : "(?:)") }), { leadChar: "\\" }), Z.addToken(/\\(\d+)/, (function (e, t) { if (!(t === N && /^[1-9]/.test(e[1]) && +e[1] <= this.captureNames.length) && "0" !== e[1]) throw new SyntaxError("Cannot use octal escape or backreference to undefined group ".concat(e[0])); return e[0] }), { scope: "all", leadChar: "\\" }), Z.addToken(/\(\?P?<([\w$]+)>/, (function (e) { var t; if (!isNaN(e[1])) throw new SyntaxError("Cannot use integer as capture name ".concat(e[0])); if (!Z.isInstalled("namespacing") && ("length" === e[1] || "__proto__" === e[1])) throw new SyntaxError("Cannot use reserved word as capture name ".concat(e[0])); if ((0, h.default)(t = this.captureNames).call(t, e[1])) throw new SyntaxError("Cannot use same name for multiple groups ".concat(e[0])); return this.captureNames.push(e[1]), this.hasNamedCapture = !0, "(" }), { leadChar: "(" }), Z.addToken(/\((?!\?)/, (function (e, t, n) { return (0, h.default)(n).call(n, "n") ? "(?:" : (this.captureNames.push(null), "(") }), { optionalFlags: "n", leadChar: "(" }); var Q = Z; t.default = Q, e.exports = t.default }, 2566: e => { e.exports = [] }, 2444: e => { e.exports = [] }, 8021: e => { e.exports = [{ name: "ASCII", bmp: "\0-" }] }, 6783: e => { e.exports = [] } }, t = {}; function n(r) { if (t[r]) return t[r].exports; var a = t[r] = { exports: {} }; return e[r].call(a.exports, a, a.exports, n), a.exports } n.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" == typeof window) return window } }(), window.parser = n(8138), window.parseEnv = e; })();